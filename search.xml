<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023，稍有一丝遗憾的大满贯</title>
    <url>/2024/02/03/2023%EF%BC%8C%E7%A8%8D%E6%9C%89%E4%B8%80%E4%B8%9D%E9%81%97%E6%86%BE%E7%9A%84%E5%A4%A7%E6%BB%A1%E8%B4%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="http://bucketpicture.19950628.xyz/picture/0.jpg"></p>

    <div id="aplayer-TxZbZiXf" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="2112517296" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p>​		今年是对自己年度规划安排的第三年，站在时间节点的最高维度去回瞻，也是截止目前最认可自己的一年，当然能得到这些，也舍掉了一些非意愿的东西，总体的满意度是超的。稍有一丝的遗憾，我觉得我已经将自己拉到极限，有这样的一个缺口，我也觉得很无奈。</p>
<p>​		本身这篇年度的Blog，build_date在12月底，由于一直在等一首新的Trance ID发行，所以一直没有推送到个人Web Blog，也就是上面这首《QuickSand》，全球发行于2024年01月12日，今年我想不在沿用《You - Approaching Nirvana》，因为从去年开始，似乎找到自己喜欢并持续热爱的音乐Style。三大主流，独衷Trance，126bpm的Progressive，138bpm的Uplifting，时不时对拍衔接首Melodic Techno，甚是唯美，工业金属的气息，剩下一类House，其实偶尔养养耳，没有给予太多的关注。所以，在24年，将玩音乐纳入兴趣中的一小项，下面这首Melodic Techno是元旦期间，从油管依据SoundLabs提供的Presets模仿出的，个人认为这段Demo，超赞~</p>
<video width='100%' height='250px' controls><source src='http://bucketpicture.19950628.xyz/video/Melodic%20Techno%20Demo.webm ' type=video/webm> Your browser does not support the webm tag.</video>

<p>​		这段Demo音频版也Sync至网易云，基于这些Style，也自行制作收藏了一些私藏的播客，它的体量也一直在增加和完善，后期可能会将这些作为今后跑步的歌单，搭配步频看看，待心脏血氧各方面的反馈。</p>
<p>​		对于今年自己的超认可，着重在于两方面：</p>
<p>​		①.《逃离计划》的主进程，本科学历的落地。还是蛮感谢3年前，具有远瞻性眼光的自己，25岁开始，就很转眼间清楚自己想要什么，要想得到自己想要的，依据我现有能拿的出来的，可以用什么去进行交换，肚子里没货，我可以通过怎样的方式或渠道，能够去进行自我增值，让自己能够沉下去，自此，逆向思维被刻进骨子里。也确实，专科学历对于自己在求职期间，是造成了不少的阻碍，它是自己的一个短板，对于自己有很清晰的认知和定位，评级评不上，窝囊费被一直压榨的超低，即便自己知道自己有能力，但没有任何东西去佐证，依旧还是不会被社会认可。</p>
<p>​		2016年是有转本这样的一个机会，绕过这样的弯路，可是那时毕竟年少，放弃了。因为当初自己更倾向于去读社会这本书，现在看来或许是真的有些愚蠢，但是你说后悔吧，后悔的程度也不是很高，可能是自己现在得到了当初想要的结果，还是选择了向前看。元旦期间收拾猪窝，也翻出了不少，自己在转本期间的佳作，尤其是高等数学。</p>
<p><img src="http://bucketpicture.19950628.xyz/picture/1.jpg"></p>
<p>​		因为那时遇到的一个人，对我这一生的影响，还是挺大的，就是执教我高等数学的那个老师，而且还是个女老师，对，是女老师。首先是某种程度上的佩服，因为一直认为：理工科是一个比较烧脑且极具考量思维能力，脑子要转的快；其次是：每次上课的气场，就是迸发出的那种自信，我笃定那时对自己能力的高度认可；最后是：那眼神，我能Get到的是种自强，我一直追求的自强，除家人以外的初源就是在这里撷取。认知自己，坚信自己，超越自己，感恩自己。</p>
<p>​		7年后，我通过不同的方式和途径，实现对自身学历的第二次救赎，主进程加载完毕。如果今后我能抓住机会， 不放弃第三次的突破。</p>
<p>​		②.《逃离计划》的附加参数之一，心理咨询师考试通过。说实话，为了解锁这一跨领域，自己放弃了SSIA的二级证，代价还是有点大的，因为机会不常有，有且可能仅有一次，错过了就没了。从自身能力综合去评定，我坚信自己一定会通过，一定会是那前50%，一定可以拿到二级SSIA。放弃它的理由，其实是为偿2008年的一个愿。</p>
<p>​		2008年，初二，青春期，通常伴随叛逆和攀比的心理，但就是有那种与众不同，很喜欢揣测人的心理变化过程，那时上网查到有个东西叫心理学，那是第一次了解听说。后来高中，给予了不少关注，也是第一次看一些关于心理学的书，然后慢慢也听说过，像研究心理学的人，本身心理多多少少是有问题的。大学里，上网自由后，初步正式了解关于心理方面的分支，偶尔也会去图书馆扒一扒，曾试想做一名执业，但终究兴趣爱好是不能跟职业划等号。工作后的第二年，就想考个证，但迫于当时沪漂，经济压力，勉强生存，但是自己还是有在了解，因为刚踏入社会，而且又是在上海一线城市，自己从农村来，在社交方面其实是有点内向的，但随着时间的拉长，环境的熟悉，慢慢放开，不否认，借助过心理学的一些尝试，让自己更伪装一点。不过现在自己很清楚自己想深究的一个分支是：沟通心理学，这也将是我接下来几年里，重点去尝试探究的。</p>
<p><img src="http://bucketpicture.19950628.xyz/picture/2.jpg"></p>
<p><img src="http://bucketpicture.19950628.xyz/picture/3.jpg"></p>
<p>​		15年后，用所剩无几的窝囊费，为青春期的好奇买个单，通宵熬了两夜一昼，坐等蓝本本到手。</p>
<p>​		对于《逃离计划》的附加参数，其实说直白一点就是在对自己进行兜底，我的能力决定了自己的下限，而上限取决于自己今后是否有机会，所有跨领域的结果，都是在不断提升下限的高度，我一直在想：如果今后不从事目前这个行业，去另外一个行业，能否依靠现有的储备去养活全家，这是一个持续并值得深究的问题，如果有，在维持的基础上，如何再去提升一个档次的生活质量。</p>
<p>​		翻转切入工作，按照去年的计划，今年大概率是会离职，结束沪漂回无锡进行定居，然后在无锡找份工作重新开始。因为28岁，对于我来说，可以回去结婚成家了，跟对象异地，毕竟不是很好，但就是有时候会事与愿违。5月份，期房交付，本身其实是一件很高兴的事情，想约上她一起去看看以后的新家，看看精装房里还要添置点什么，喜欢点什么，鬼知道后来抽什么风，吵的巨猛。然后，就没有然后了……，原本想早点结束异地，结果却来大反转，有点受打击，阴差阳错的萎靡一段时间。后来年中，没曾想熬走了经理，原本打算回过神，提交离场申请，出去旅个游，计划去拉萨玩一圈就回无锡。</p>
<p>​		新经理接手，什么事情不是很方便，外加手里的活也多，人又在回神阶段，导致那段时间戾气巨重，什么也不怂，不顺心就干架。差一丝丝就离职，感觉待在那似乎已经没有什么价值，不过最终还是听劝，稳了下来。当然如果真的走，自己也不是没有退路，以自身能力，只要不是很挑，不至于没饭吃。</p>
<p>​		总体而言，下半年的工作，还行，没有太多的超负荷，偶尔达到1.2的体量，于往常相比，工作日的加班量减少，算是能接受。但相同的体量，如果换人去处理，感觉依旧会有负担，高效率的投入产出转换，在于前期自身的积累，中期实时的沟通和清晰的流程思维，后期报告的简明扼要。目前正在做一种尝试，就是将自己这为期4年来，所处理的点，以QA模块知识体系，进行文档输出，以非必要不开源形式，存档保留。</p>
<p>​		至于情感，其实真的是有点麻了，不知道要如何去处理，才算的上是合格。5月份搞得这么一出，让我不想再去和比自己年龄小的去处，也不想再去跟娇惯的独生子女沟通。因为一个情绪不稳定的对象，会形成一连串的，不可估量的链路式爆炸影响。从自身去感知，感觉自己不会把爱情这个东西挂在嘴边，更多的是去做，因为它最终还是要回归生活实际，转化为家人般的亲情存在。理想中的是：一种双向奔赴，而又可以各自独立，其目标的一致性都指向今后家的方向。</p>
<p>​		今年唯一让我自身觉得很是愧疚的是老妈找人说的一个女孩子，原本口头答应有时间带人家去上海逛逛，可是后来因为上海天气不是很好，梅雨季，天天下雨，也不是很好出去，就爽了约，失信于人，后来再想去沟通，也不是很好意思，毕竟换位思考一下，我是那个女孩子也不会接受。人是挺好，当初第一次沟通，要不是因为一个答复，可能今年春节，都会订婚。</p>
<p>​		但是不管现在的结果是怎样，从不失去对爱情的向往和追求，一路向前走，不回头。纵使现在的婚姻交易化，也不卑不亢，低头是为了看清脚下的路，让自己走的更长远，而不是被训化；抬头是为了昂扬坚信秉承的信念，而非高傲自大。贤妻扶我青云志，我还贤妻万两金~</p>
<p>​		2024年的规划，目前年后暂时敲定的是先考取《系统集成项目管理工程师》，搞个中级职称，但可能会着手先去处理几件非自我投资增值的事</p>
<p>​		①、将对个人Web Blog进行迁移，使其脱离Github平台的约束，今年是最后一年使用，目前打算从底层更换框架，改用WordPress，由本地Ubuntu-Server提供服务端载体，所有数据本地Docker化，同时进行数据库的主从复制，提高容灾，避免之前Markdown文档丢失的情况</p>
<p>​		②、对DIY NAS进行硬件上的升级及扩容，改用双千螃蟹网卡，区分内外网服务，并更换Windows-Server为Synology System，四盘位扩容至六盘位，增加本地存储桶容量</p>
<p>​		③、搭建个人私有化图床，存储桶放在了七牛云，同时也利用部分CDN进行加速，减少其自身回源流量的消耗</p>
<p>​		④、将之前考取的证书，所使用的所有学习材料，归纳至NAS服务器，并内网穿透开放至博客专区，希望可以发挥它自身应有的最大价值</p>
<p>​		⑤、部署更多私有化个性服务，并对外进行开放（<a href="https://sc.19950628.xyz/generate">短链生成服务</a>调试完毕，已开放）</p>
<p><img src="http://bucketpicture.19950628.xyz/picture/4.png"></p>
<p>​		今年会更加放大化对自我兴趣的投入，相较于其它男孩子来讲，我更喜欢花钱买硬件去玩，买硬盘，买域名，买云服务器，买云存储……</p>
<p><img src="http://bucketpicture.19950628.xyz/picture/5.jpg"></p>
<p><img src="http://bucketpicture.19950628.xyz/picture/6.png"></p>
<p><img src="http://bucketpicture.19950628.xyz/picture/7.png"></p>
<p>​		最最最重要的是：2022年，是人生走向正规的元年，2024年，买辆车，给它加加速，说不定是emm…..    AMG ?</p>
<p><img src="http://bucketpicture.19950628.xyz/picture/8.jpeg"></p>
]]></content>
  </entry>
  <entry>
    <title>保姆级教你搭建hexo个人博客</title>
    <url>/2020/03/28/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E4%BD%A0%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-WvpgOPPh" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="25116188" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>



<h2 id="流程步骤如下："><a href="#流程步骤如下：" class="headerlink" title="流程步骤如下："></a>流程步骤如下：</h2><h3 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h3><p>进入<a href="https://nodejs.org/zh-cn/">Node</a>官网，下载长期支持版本，然后都是下一步，自行操作.安装成功之后，自己可以cmd验证一下，键入：<code>npm -v</code>和<code>node -v</code>，然后会给你反馈一个当前的版本号。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhsaVA.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhyUQU.jpg"></p>
<h3 id="2-安装Git-Bash"><a href="#2-安装Git-Bash" class="headerlink" title="2.安装Git Bash"></a>2.安装Git Bash</h3><p>进入<a href="https://gitforwindows.org/">Git Bash</a>官网，下载即可安装，安装过程中，可能会去调用cmd的窗口，会安装很多的文件，等待即可，但为了能够确保万无一失，强烈建议科学上网，保证链接都能connect.安装完成后，鼠标右键会多了两个功能，回到桌面，鼠标右键，选“git  bash here”，稍作等待，会有一种使用Linux的感觉，键入：<code>git --version</code>，这里注意一下，不可以使用短命令。不妨根据我们操作Linux的习惯，help一下，键入：<code>git --help</code>，同样会出现很详细的命令使用介绍。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhyayF.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhysF1.jpg"></p>
<h3 id="3-注册GitHub账户并配置"><a href="#3-注册GitHub账户并配置" class="headerlink" title="3.注册GitHub账户并配置"></a>3.注册GitHub账户并配置</h3><p>进入<a href="www.github.com">Github</a>官网，完成注册，进入自己的主页，找到右上角“+”，第一个新建仓库，这里注意一下，仓库名格式一定要是：**<u><em>yourname.github.io</em></u><strong>，图示是我已经建立了这样的一个仓库，所以报错了，最后点击下面的创建。因为Github是一个强大的代码托管平台，所以你自己的仓库可以开放给别人看，也可以自己设置为私有的，默认是Public.如果你成功搭建到这步，这时当你去用浏览器访问</strong><u><em>yourname.github.io</em></u>**时，是完全ok的.</p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhyyJx.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhygSK.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhyheH.jpg"></p>
<h3 id="4-生成SSH-Keys"><a href="#4-生成SSH-Keys" class="headerlink" title="4.生成SSH Keys"></a>4.生成SSH Keys</h3><p>这一步通俗一点来讲就是建立一个验证通道。一台PC机，一个Key，回到桌面，右击选择“git bash here”，键入：<code>ssh-keygen -t rsa -C &quot;yourmail&quot;</code>，那么这个时候会反馈一些信息，让你确认。第一次直接按回车就行，是问你将ssh的文件保存在哪里，我们默认就好，其实是保存在自己的C盘用户下面。第二次出现是要求我们后续接入GitHub时，你要有一个密码验证，这时自己键入一个可以记住的密码即可，注意键入过程，跟Linux一样的，不会有提示，输完回车。紧接着，第三次就出现，就是让你重新再输入一遍密码，确认一下，键入成功后，会出现一段图形，反正你看不懂，看到就行，我就不图示了。</p>
<p>接下来，进入刚刚讲的这个C盘用户路径下，找到一个叫“.ssh”的文件夹，打开里面会有两个文件，分别为：id_rsa和id_rsa.pub，这里安装一个工具叫“Notepad++”，打开后者，选中里面所有的内容，复制下来。</p>
<p>接下来回到GitHub，点击头像，路径：settings→ssh and gpg keys→new ssh key，把刚刚复制下来的，全部粘贴进去，为方便管理，title随便取一个名字。测试一下是否成功，打开刚刚的Git Bash，键入：<code>ssh -T git@github.com</code>，如果成功，会有提示“Hi，yourname”。然后我们配置一下个人信息，分别键入：<code>git config --global user.name &quot;yourname&quot;</code>，<code>git config --global user.email &quot;yourmail&quot;</code>，此时这一个流程到这里就结束。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh6kXF.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh6J7d.jpg"></p>
<h3 id="5-安装hexo框架"><a href="#5-安装hexo框架" class="headerlink" title="5.安装hexo框架"></a>5.安装hexo框架</h3><p>这一步是最关键的，因为要用到它去完成核心的东西，注意这里我所描述的每一步，稍有不慎，你自己在操作中可能就会报错，这是我摸索了N次，总结出来的，帮小伙伴们避坑。</p>
<p>在本地新建一个空的文件夹，记住一定要是空的，一般的话，我会去建立一个”Hexo”的空文件夹，进去然后右击选git bash here，分别键入：<code>npm install hexo-cli g</code>，<code>hexo init Blog</code>，<code>cd Blog</code>，<code>npm install</code>，这里的话做一个解释，第一段代码是安装必要的hexo组件；第二段代码是初始化一个名叫“Blog”的文件夹，存放今后的文件；第三段代码是进入Blog这个文件夹；第四段代码安装后续生成网页的文件。第一段代码回车后，不会提示任何信息，因为在安装，请务必耐心等待，手不要贱。安装成功后，可以自己测试一下，键入：<code>hexo -v</code>，会有版本信息反馈，如图所示。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh6NtI.jpg"></p>
<p>接下来，我们就需要开始在本地，调试我们自己的博客了。在调试之前，我们配置一下一个非常重要的文件，方便后期我们部署在GitHub上。文件路径：哪个盘→Hexo文件夹→Blog文件夹→_config.yml，利用之前提到的文本编辑工具notepad++，打开它，我记得是在最后，补全一些信息如图示，温馨提示，里面的每一个冒号后面都有一个空格，千万不要忘记，别踩坑，换成自己的仓库名就行。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh6w1f.jpg"></p>
<p>接下来，开始本地运行调试，安装插件，请注意我这里所有的路径都是在Blog这个文件夹下，去点击“git bash here”，键入：<code>npm install hexo-server --save</code>，插件安装后，正式调试，分别键入：<code>hexo clean</code>，<code>hexo g</code>，<code>hexo s</code>.这里代码做一个解释，第一段代码是删除旧文件；第二段代码是生成新文件；第三段代码是在本地部署运行。当第三段代码结束后，会有一个提示，让你去访问你本地的localhost:4000端口，没有问题的话，大功告成。我把我已经启用的博客网站，简单演示一下，因为我已经换了默认主题，专门定制了一些效果，可能会不太一样，但原理是一样的。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh60c8.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh62hq.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh6X36.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhcSDe.jpg"></p>
<h3 id="6-域名重定向"><a href="#6-域名重定向" class="headerlink" title="6.域名重定向"></a>6.域名重定向</h3><p>在国内，有很多的域名提供商，阿里，腾讯，花生壳……反正多的若干，我这里用的腾讯。因为涉及到备案，可能这些东西之前没接触过的小白，很懵逼，其实开始接触这些，我也不是很懂，后来就渐渐自己摸索明白了，注册我就不讲了哈。</p>
<p>在域名解析之前，配置最后一个重要文件，就是重定向文件，文件路径：那个盘→Hexo文件夹→Blog文件夹→source文件夹，然后新建一个文档，命名为：CNAME，全是大写，添加一段文本，内容为你的网址（例：<a href="">blog.19950628.xyz</a> ） ，保存退出，然后重命名文档，把原先文档后面的“.txt”去掉就行。</p>
<p>域名注册好之后找到它，后面有解析，点击进去，添加图示这些信息，其中第二条的记录值是一个IP地址，怎么来呢？讲一下方法，打开cmd，换成自己名字ping一下就得到这个IP地址了，填进去。最后在之前的git bash中，键入：<code>hexo d</code>，此代码是将所有文件，部署到刚刚我们在GitHub建立的仓库。此时，你可以直接用域名访问自己博客了，到此全程结束。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jhc380.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jhg4w4.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jhgok9.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhgTYR.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>Carrol&#39;S 2022</title>
    <url>/2022/12/31/Carrol%E2%80%98S%202022/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-WRYjRxMC" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="3932159" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>



<p><strong>2022年度关键词：艰辛、庆幸、投资、副业、催婚</strong></p>
<p>2022年的最后一个工作日，其实也并不轻松，相比于2021年度的结尾，很明显工作中的需求量积增加了很多。而在这一年中，经历的事件，是我来上海赚钱，五年来从所未见的。不曾想过，世界级经济都市会因疫情而按下暂停键，也未曾见过人性最肮脏、阴暗的一面……，甚至有些事情，能颠覆二十几年来的三观，但这些在今年很荣幸的全部领略过。4月份保留了这段被各大社交平台杀光的Video，应当被谨记。</p>
<video width='100%' height='250px' controls><source src='http://bucketpicture.19950628.xyz/video/%E5%9B%9B%E6%9C%88%E4%B9%8B%E5%A3%B0.mp4 ' type=video/webm> Your browser does not support the webm tag.</video>



<p>昨晚下班后着手恢复博客系统环境，顺带在想，今年的这章Markdown文档，标题要叫什么。跟往年一样，叫个人年度总结？也斟酌了下，我觉得叫总结是有些高估了，我觉得叫“我的2022”似乎更精准点，因为今年自己没有从横向涉猎面去扩充，而是纵向的从深度去进修了，完成去年自己没完成的目标中的一部分，当然只是一部分，不是全部，是因为疫情，从个人能力角度去评估，自己是有把握all in的，证券从业资格证还剩下一门没考，计划在明年结束沪漂前把证考到手。当然，完成的是今年趁着疫情在家，把Python的一些基础，捋了一遍，因为自学，效果个人认为还是很差，没有频繁的去进行实战，能力还是跟不上，但自己一直坚信，自己就是一块适合编码的料子，给到时间，定会出成果。难在有问题，没人指点，需要自己网上去搜，泡论坛抛问题，很耗费精力，外加自己英文水平不是很好，很多Python问题都是英文原版，自己只能大致看懂一点点，英文是自己的一个短板，这个短板，这辈子没计划想补齐。今年越发有这样的感觉，就是觉着自己沉浸在某个环境下的时候，发现自己24小时有点不够用，包括在工作也是。</p>
<p>今年度过的辛苦程度应该是这几年当中最高的，17年刚来上海，也是刚踏上社会，人比较简单，想的少，自然就活的很轻松，随着交际的扩展，接触不同的人性，是有点麻，仿佛就很黑暗。21年春节回来之后，原定计划是准备跳槽的，但是刚回上海不久，上海被封，一封就是3个月，老老实实猫家里，吃的喝的，物价离谱的鱼都长腿自己跑了，关键是有的东西，有钱还买不到，原本生活费往常就几百块，那3个月，自己算了一笔账，花了接近2&#x2F;3的工资，也在这3个月里，见证了大家嘴上挂着说的“真、善、美”。6月尝试开始部分解封，7月回到现场办公，持续不到3个月，10月开始又居家，可以说2022年有接近半年的时间是居家办公的，所以这一年，大家活的都不容易，从能活好了转向能活下去。</p>
<p>疫情大环境下，有很多公司企业倒闭，每个月工资都发底薪，很庆幸自己从事了这个行业，如果还是以前带团队做销售，我觉得自己要呜呼，团队要整垮，房贷可能会断供，生活费可能都要从信用卡套现透支，渐渐进入死循环，刷信用卡，拆东墙补西墙，永远是个无底洞。有一份稳定的薪水，可以勉强维持房贷，维持在上海的生活，总之是苟。当初17年刚来上海的时候是8个人一起，现在也就一两个，上海， 年轻的时候可以来闯一闯，见见世面，至于定居，对于出身农村的娃来讲，不是一辈子奋斗就可以很轻松换来的。同样的年底，疫情政策的放开，每个人都是阳圈里待“宰”的羔羊，也很荣幸进入决赛圈，至今还是个阳敌，没感受过刀片割嗓子，没感受过发烧烧蜕皮，更没感受过嗅味觉失常等一系列是什么感觉，没备布洛芬，没备急支糖浆，更没备什么连花清瘟，一直认为平时加强锻炼，增强抵抗力是第一位，没事可以带个耳机5公里、10公里，都很棒的，结束回来冲个澡，也很舒服。</p>
<p>6月中下旬结束居家办公回现场，7月干完一整月，8月其实也出了小插曲，8月4号的七夕节，日子反正是超会挑，由于行里与外包厂商解除大部分人员占比，很荣幸的被上家外包踹了。其实当时的心理，不是悲伤，反而觉得是开心更多一点，也不知道为什么。对于自身个人定位来讲，我自己觉得当时即将没工作，对我的冲击影响不是很大，最主要原因是两个：一个是当时原本计划年后回来就主动想要跳，因为疫情，一直被拖，现在正好有机会，不是因为觉得现在的工作环境不好，而是觉得一个人不适合在一个地方工作待的太久，更想出去接触些新技术面；二是因为自己并没有因为现在有一份看似稳定的工作，而放弃学习，自己一直在接触新的技能领域，一直在拓展自己，想让自己变得更值钱，即便被踹，丢了这份工作，以当时自己的能力，找一份同薪酬的工作，自己不是太挑，难度不是很大，因为一直持续的投资自己，所以这种事情如果真的出现，可以将其带来的冲击力降到最低。从来上海赚钱的时候，就一直坚信，投资自己是一个永不会被背叛的过程，实时清楚自己的定位，想要什么，付出回报比是多少，偏向时懂得自我纠正。</p>
<p>当然，大环境的恶劣，其实也催生了更多生存法则，并不是自己有一份工作，就可以持续享益，其实我自己还是比较有忧患意识，外加自己身上背的房贷这座大山，自己心声念念的一直也想买个四轮子，也不是很轻松，需要钱，父母其实年纪大了，也看不下去他们再去干苦力活，出身农村，很多时候都是要强的，就是要独立，增加自己固定收入以外的收入，也很有必要。同样的，我也不例外，搞了份，要相信知识是可以赚钱的，这句话一点都不假。本身自己就是从事IT相关工作，外加自己懂点编程，是一名高玩辣鸡佬，休息时间利用自己找的开源项目进行有偿客制化服务，虽然平时一直不温不火，但这个月异常的惊喜，额外收入可以抵消一下下个季度的房租。同样是玩，出去耍，票子要往外出，还要承当被阳的风险；死肥宅，票子往里进，人还安全。</p>
<p>预期明年的规划是两个方面：一是对Python的进阶，不管是对自动化框架的，还是对爬虫或是AI方面，都开始动手，进行进阶；二是对去年排进计划中的Linux开始基础扫盲。不求多，只求深耕，给自己点时间，一定可以。</p>
<p>沪漂年限的增加，带来的无可厚非就是家里的催婚，粗略框了一下，老母亲给介绍的女孩子，推完实在推不掉，一共5个，会计、个体、幼师、医药、人力，不加之前的领导、朋友啥介绍的，之前推推还了解了解，但是后来渐渐有种在面试的感觉，超级讨厌，蛮反感，而且大多数就是那种，只要你不主动，瞬间结束，回头来，一顿劈头盖脸的臭骂，我脸厚，主要就是这几年被老母亲骂出来的。但是，我就想自己谈，因为没有隔阂，没有拘束，自由度高，什么事情都是我们自己的，父母层面插不了手，这就很棒。</p>
<p>总体来说，2022年是我人生走向正规的元年，甩去刚来上海时的稚嫩，不再一年换一份工作，深耕一个行业，不再时时看银行卡余额过日子，当然这些现有的，一直在未之前许下的小愿望铺路，父母这辈子没出过省，在自己结束沪漂回无锡定居前，一定会把父母带上海玩一圈。一个人在上海，还是最担心父母，也怕突然接到家里电话。</p>
<p>最后想说的就是，因为受各种外界压力的影响，很幸运的遇到了一种适合自己泄压的音乐风格，Progressive Trance</p>
<p>这就是我的2022，一辈子中，这个时间段，我的经历，我的烦恼，我的规划，我的期待，敲定在这篇博客里。</p>
<p>接下来的2023，？</p>
]]></content>
  </entry>
  <entry>
    <title>2021下半年度个人总结</title>
    <url>/2021/12/31/2021%E4%B8%8B%E5%8D%8A%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-fvLLyeZN" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="3932159" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>



<p> <strong>2021下半年度关键词：选择、舍得、知足</strong></p>
<p>首先，觉得是一大超级遗憾的是：20211226-修复更新博客框架的时候，把4月往后的所有博客文章都弄丢了，其中关键的2021上半年度个人总结也没了，尝试各种方式想要去找到历史版本的哈希值，进行版本的回滚，都失败了。但不管怎样，既然已经发生，更着重的是下一步的处理方式，显然已经没有任何处理方式去解决，那就率性让其成为过去，纪念一下就好，继续向前跑</p>
<p><img src="https://s4.ax1x.com/2021/12/31/Tfukfx.jpg"></p>
<p><img src="https://s4.ax1x.com/2021/12/31/TfuV1K.jpg"></p>
<p><img src="https://s4.ax1x.com/2021/12/31/TfuZ6O.png"></p>
<p><img src="https://s4.ax1x.com/2021/12/31/TfueXD.png"></p>
<p>切回正轨，谈谈2021的下半年，之所以年度关键词提炼为选择+舍得，而没有直接归结于失败一词，是我觉得，并没有到一败涂地的程度，算是失败的程度大于成功的程度，比例差不多七三开。失败，失败在上半年度对自己下半年度作出的个人规划，没有达标，虽实际上是因为工作的原因，没时间去处理自己工作外的东西，但并不想以此为借口，完成就完成，没完成就没完成，直面自己的不完美，没那么难。但放弃是绝对不会，充其量往后顺延至2022年度中。</p>
<p>具体工作原因是：因承接某发银行资产托管部中，自认为是超级硬茬的测试需求，关于ETF，一个人，从5月预知消息，6月份正式开始实施执行，历经3个多月，9月11号投产，在此期间，整个季度感觉是在渡劫，就那种状态很萎靡，跟枪打的一样，生活更是一团糟，落腮胡经常不刮，就去上班，熊猫眼，掉头发，记不得加了多少班，通了几次宵，睡了几次椅拼床，n次微信call，每次call时半小时以上都很正常，无数次想要离职滚蛋的想法，想哭忍住了。但真的就很犟，打心里从一开始就觉得，一定能吃下，啃到东西，当初承接需求的时候，傻白甜真的就是冲业务这个人去的，就是上半年度总结报告提到的，之前从没遇到过沟通如此顺畅的业务，超容易Get到彼此的点，直觉告诉我，一定能接，就它。</p>
<p><img src="https://s4.ax1x.com/2021/12/31/TfKV5n.jpg"></p>
<p>三分的成功，成功在此期间，顺利带了个徒弟，外加提升强大的抗压调节能力和对外社交沟通处理问题的能力。一般来说，新人在此项目中的成长定型期是两个月左右，带徒弟，是个居耗体力，精力的一门差事，你要解决很多的“为什么”，那就要求自己有很强大的项目知识体系认知池，这只是第一步。其次，还要让Ta了解，怎么做，这才是最关键的，也是新人的痛点。好的框架体系，真的能让其事半功倍，以最终目的为导向，最大限度的高效率完事齐活。ETF投产后，正值国庆的来临，外加调休，休了两波小长假，一下子舒坦了，终于渡完劫了，之后复盘的相关文档，标题都是ETF渡劫攻略之XXXX</p>
<p>选择了承接，虽然当时有点恨为什么脑子缺根筋要接，但现在看来答案似乎很明确。原以为就这样，投产后ETF就结束了，但现在带来个超级大的困扰，就是只要有关于ETF的需求，全部砸在我身上，这就很难受，不接都不行，跟孙猴子头上的紧箍咒一样，甩都甩不掉，但是每轮迭代原计划都会被分配需求，测试周期是一定的，中间穿插ETF相关需求进来，就会被耽误很多时间，原计划需求又丢不掉，工作量瞬间增加，实打实的讲，基本上工作量总体平衡下来都达120%，需求量爆发时，能达140%~150%，前几天请假去了趟医院，结果报告基本上你都下不去那眼的，就跟装水的桶一样，木桶裂纹，参差不齐。之前还跟同事讲，这个年纪就是拿命换点银子花花。</p>
<p>但是就这样，在某个时间点，时间段，即便你工作量超负荷，在你的上级眼里，Ta评估就觉得这个东西很简单，很快可以搞完。我收回2020下半年度中说过的某些话，它可能是我没经历过时间历练妄加说出的话，只能代表当时那个时间点。人与人之间的沟通讲话，情商真的得在线，尤其是做领导的，情商不在线，干架经常事。对外，你要撑起一片天，掌舵的，要经得起浪打，为那些愿意跟着你打江山的人最大限度内的自由；对内，你要做一个排头标，规范化，让一个Team的动力，源源不断的可持续输出。</p>
<p>明年下半年开始，极大程度会跳槽。一方面因为明年拿房子，预计要结束上海的游离缥缈，另外一方面因为每个男人内心都有征服的欲望，想提个四轮子，需要不少的票子，父母年级大了，伸不出那手去要，一套房子把养老的钱已经掀的个底朝天了，四轮子就自己来吧。还有一个不是决定因素方面是想试向管理层涉足，不想当将军的士兵不是个优秀的士兵，趁身体还没垮，头发还没秃顶，最大加速度往前冲。</p>
<p>工作结束谈个人。我是个不喜欢把工作跟生活混杂在一起的人，下班就绝不提工作的事，除非重要且紧急的事要处理，人就跟蒸发了一样，包括调休，周休。工作期间可以像抽大麻一样，疯狂的很，下了班，就蒸发，出去潇洒，哪嗨往哪钻，不泡吧，不喝酒是禁忌。喜欢玩单反，出去采景，记录生活，但最近发现，自己连张像样的自拍照都没有，以至于被老母亲实力吐槽一番，被安排相亲，都没有拿的出手的像样照片。也的确，性格就是不怎么喜欢拍自己，很清楚自己的定位，颜值就一般般吧，出门能见人，也就知足。同时也是个高阶的资深垃圾佬玩家，喜欢自己组装NAS，玩开源路由操作系统，将其发展成副业，搭建服务器仓库，构建还算过得去私人工作台，上个月刚弄好的，出租屋里，最值钱的一套装备，给瞄一下</p>
<p><img src="https://s4.ax1x.com/2021/12/31/TfloIH.jpg"></p>
<p>不过最近一段时间，一直再考虑过年要不要回去，毕竟也就不到一个月了。回去吧，面临大龄男青年历史性头疼问题，不出意外，今年如果回去，日程绝对被老母亲安排的满满的，谁谁介绍的谁家姑娘，照片已经给人家看了，去见一面喝喝茶，聊一聊；不回吧，年纪大了，一年到头也没多少时间在他们身边，今年回去，老父亲白头发肯定也越多，也怪心疼的。不排斥相亲，也不盲目相亲，合适就处，不合适就当交个朋友，顺老母亲的意，只是不想她赌气。</p>
<p>始终坚持并信仰，谋生的路上不抛弃良知，谋爱的路上不丢失尊严，双向奔赴，才有意义。所以我自己也不断的在通过可行的方式，去搭建这方面的桥梁，老同事，老领导，周边的朋友，死党，基友，闺蜜……，帮你介绍是情分，不帮你是本分，因为他们本身大可不必这样，来着不拒，喝喝茶，吃个饭也花不了多少钱。</p>
<p>另外，就是发现一种很奇葩的现象，最近总是遇到，就是：跟有些人沟通，真的就跟抽出雪藏风葬的40米大砍刀断头一样，开口说话，表达想法，是真的难于上青天，被折磨的没脾气。唉，就不说，你猜，真想说一句：猜你大爷，哪凉快哪待着去，搞得跟求祖宗一样。</p>
<p>2022年，不敲定新个人规划，完成七层2021年的失败，再糟糕的坚持也好过放弃，与此同时，憧憬一下新年能找到个默契度跟拍的合适女孩子吧，这是奢望，能找到锦上添花，暂时找不到就一直毫无保留的投资自己，使劲赚钱，提四轮子，每次回家的压力实在太大了。</p>
<p>2022，遇见更强大的自己！</p>
<p><img src="https://s4.ax1x.com/2021/12/31/TflYPs.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（十八）</title>
    <url>/2021/04/07/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-BUGFmTII" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="26508116" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="使用类和实例"><a href="#使用类和实例" class="headerlink" title="使用类和实例"></a><strong>使用类和实例</strong></h3><p>之前已经接触过如何去创建类，接下来创建完之后就是用。首先对于已创建的类，想要为其添加属性的默认值，此想法是可行的 ，可以在初始化时，直接进行定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Car:</span><br><span class="line">	def __init__(self, make, model, year):</span><br><span class="line">	&quot;&quot;&quot;初始化描述汽车的属性。&quot;&quot;&quot;</span><br><span class="line">	self.make = make</span><br><span class="line">	self.model = model</span><br><span class="line">	self.year = year</span><br><span class="line">	self.odometer_reading = 0</span><br></pre></td></tr></table></figure>

<p>这里形参仅仅只有make、model、year，但是在具体代码块中涉及属性odometer_reading，且初始化设定的值为0，但此做法是有一定的局限性，只有新车的公里数才会默认为0，但凡是开过的车，公里数都会随时间的变化，所以这里就涉及到修改属性的值。</p>
<p>对于修改属性的值，有三种方式，如下所展示的</p>
<h4 id="1-直接修改属性的值"><a href="#1-直接修改属性的值" class="headerlink" title="1.直接修改属性的值"></a><strong>1.直接修改属性的值</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Car:</span><br><span class="line">	def __init__(self, make, model, year):</span><br><span class="line">		&quot;&quot;&quot;初始化描述汽车的属性。&quot;&quot;&quot;</span><br><span class="line">		self.make = make</span><br><span class="line">		self.model = model</span><br><span class="line">		self.year = year</span><br><span class="line">		self.odometer_reading = 0</span><br><span class="line">	</span><br><span class="line">	def get_descriptive_name(self):</span><br><span class="line">		&quot;&quot;&quot;返回整洁的描述性信息。&quot;&quot;&quot;</span><br><span class="line">		long_name = f&quot;&#123;self.year&#125; &#123;self.make&#125; &#123;self.model&#125;&quot;</span><br><span class="line">		return long_name.title()</span><br><span class="line">	</span><br><span class="line">	def read_odometer(self):</span><br><span class="line">		&quot;&quot;&quot;打印一条指出汽车里程的消息。&quot;&quot;&quot;</span><br><span class="line">		print(f&quot;This car has &#123;self.odometer_reading&#125; miles on it.&quot;)</span><br><span class="line"></span><br><span class="line">my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2019)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.odometer_reading = 23</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line">输出：</span><br><span class="line">2019 Audi A4</span><br><span class="line">This car has 23 miles on it.</span><br></pre></td></tr></table></figure>

<p>属性odometer_reading的值由原先默认的0被修改成23</p>
<h4 id="2-通过方法修改属性的值"><a href="#2-通过方法修改属性的值" class="headerlink" title="2.通过方法修改属性的值"></a><strong>2.通过方法修改属性的值</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Car:</span><br><span class="line">	def __init__(self, make, model, year):</span><br><span class="line">		&quot;&quot;&quot;初始化描述汽车的属性。&quot;&quot;&quot;</span><br><span class="line">		self.make = make</span><br><span class="line">		self.model = model</span><br><span class="line">		self.year = year</span><br><span class="line">		self.odometer_reading = 0</span><br><span class="line">	</span><br><span class="line">	def get_descriptive_name(self):</span><br><span class="line">		&quot;&quot;&quot;返回整洁的描述性信息。&quot;&quot;&quot;</span><br><span class="line">		long_name = f&quot;&#123;self.year&#125; &#123;self.make&#125; &#123;self.model&#125;&quot;</span><br><span class="line">		return long_name.title()</span><br><span class="line">	</span><br><span class="line">	def update_odometer(self, mileage):</span><br><span class="line">		&quot;&quot;&quot;将里程表读数设置为指定的值。&quot;&quot;&quot;</span><br><span class="line">		self.odometer_reading = mileage</span><br><span class="line">	</span><br><span class="line">	def read_odometer(self):</span><br><span class="line">		&quot;&quot;&quot;打印一条指出汽车里程的消息。&quot;&quot;&quot;</span><br><span class="line">		print(f&quot;This car has &#123;self.odometer_reading&#125; miles on it.&quot;)</span><br><span class="line"></span><br><span class="line">my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2019)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.update_odometer(23)</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line">输出：</span><br><span class="line">2019 Audi A4</span><br><span class="line">This car has 23 miles on it.</span><br></pre></td></tr></table></figure>

<p>这里直接在类里面从新定义了一个方法update_odometer，并直接对方法进行赋值，来更新属性odometer_reading的值，让其在方法内部实现值变化的运算，后续再调用的过程中直接将实参传递进去即可</p>
<h4 id="3-通过方法对属性的值进行递增"><a href="#3-通过方法对属性的值进行递增" class="headerlink" title="3.通过方法对属性的值进行递增"></a><strong>3.通过方法对属性的值进行递增</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Car:</span><br><span class="line">	def __init__(self, make, model, year):</span><br><span class="line">		&quot;&quot;&quot;初始化描述汽车的属性。&quot;&quot;&quot;</span><br><span class="line">		self.make = make</span><br><span class="line">		self.model = model</span><br><span class="line">		self.year = year</span><br><span class="line">		self.odometer_reading = 0</span><br><span class="line">	</span><br><span class="line">	def get_descriptive_name(self):</span><br><span class="line">		&quot;&quot;&quot;返回整洁的描述性信息。&quot;&quot;&quot;</span><br><span class="line">		long_name = f&quot;&#123;self.year&#125; &#123;self.make&#125; &#123;self.model&#125;&quot;</span><br><span class="line">		return long_name.title()</span><br><span class="line">	</span><br><span class="line">	def update_odometer(self, mileage):</span><br><span class="line">		&quot;&quot;&quot;将里程表读数设置为指定的值。&quot;&quot;&quot;</span><br><span class="line">		self.odometer_reading = mileage</span><br><span class="line">	</span><br><span class="line">	def read_odometer(self):</span><br><span class="line">		&quot;&quot;&quot;打印一条指出汽车里程的消息。&quot;&quot;&quot;</span><br><span class="line">		print(f&quot;This car has &#123;self.odometer_reading&#125; miles on it.&quot;)</span><br><span class="line">		</span><br><span class="line">	def increment_odometer(self, miles):</span><br><span class="line">		&quot;&quot;&quot;将里程表读数增加指定的量。&quot;&quot;&quot;</span><br><span class="line">		self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line">my_used_car = Car(&#x27;subaru&#x27;, &#x27;outback&#x27;, 2015)</span><br><span class="line">print(my_used_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_used_car.update_odometer(23500)</span><br><span class="line">my_used_car.read_odometer()</span><br><span class="line"></span><br><span class="line">my_used_car.increment_odometer(100)</span><br><span class="line">my_used_car.read_odometer()</span><br><span class="line">输出：</span><br><span class="line">2015 Subaru Outback</span><br><span class="line">This car has 23500 miles on it.</span><br><span class="line">This car has 23600 miles on it.</span><br></pre></td></tr></table></figure>

<p>这里是同样的定义了个新的方法increment_odometer，并将其属性miles的值，加上原先odometer_reading的值，重新再赋值给odometer_reading，同样的也是在类中的方法直接完成运算</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>总有一些值得学会</title>
    <url>/2020/11/11/%E6%80%BB%E6%9C%89%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E5%AD%A6%E4%BC%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-BoaThhSe" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1455200688" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="1-喧闹任其喧闹，自由我自为之，我自风情万种与世无争，别人对你的打分是他对你的看法，他不了解你的时候，你又何必去在乎他的打分，关键的是你自己给自己打几分"><a href="#1-喧闹任其喧闹，自由我自为之，我自风情万种与世无争，别人对你的打分是他对你的看法，他不了解你的时候，你又何必去在乎他的打分，关键的是你自己给自己打几分" class="headerlink" title="1.喧闹任其喧闹，自由我自为之，我自风情万种与世无争，别人对你的打分是他对你的看法，他不了解你的时候，你又何必去在乎他的打分，关键的是你自己给自己打几分"></a><strong>1.喧闹任其喧闹，自由我自为之，我自风情万种与世无争，别人对你的打分是他对你的看法，他不了解你的时候，你又何必去在乎他的打分，关键的是你自己给自己打几分</strong></h3><h3 id="2-贪财有道，好色有品，喝酒有量，玩笑有度，没事不会惹事，但也不会怕事，对外顶天立地，对内没有脾气"><a href="#2-贪财有道，好色有品，喝酒有量，玩笑有度，没事不会惹事，但也不会怕事，对外顶天立地，对内没有脾气" class="headerlink" title="2.贪财有道，好色有品，喝酒有量，玩笑有度，没事不会惹事，但也不会怕事，对外顶天立地，对内没有脾气"></a><strong>2.贪财有道，好色有品，喝酒有量，玩笑有度，没事不会惹事，但也不会怕事，对外顶天立地，对内没有脾气</strong></h3><h3 id="3-喜欢就很单纯，不喜欢才会权衡利弊"><a href="#3-喜欢就很单纯，不喜欢才会权衡利弊" class="headerlink" title="3.喜欢就很单纯，不喜欢才会权衡利弊"></a><strong>3.喜欢就很单纯，不喜欢才会权衡利弊</strong></h3><h3 id="4-如果你认定一个人只是因为他对你好，那还是算了，对你好是一个巨大的陷阱，这并不能构成一个男人的优点，并且可替代性太强了，你花几千块雇一个保姆一样也可以做到，甚至做得更好，而坚韧，勇敢，自信，乐观，独立，果断的优秀品质才是无法被替代的，也就是所谓的有趣的灵魂，这应该是才是彼此之间相伴的理由"><a href="#4-如果你认定一个人只是因为他对你好，那还是算了，对你好是一个巨大的陷阱，这并不能构成一个男人的优点，并且可替代性太强了，你花几千块雇一个保姆一样也可以做到，甚至做得更好，而坚韧，勇敢，自信，乐观，独立，果断的优秀品质才是无法被替代的，也就是所谓的有趣的灵魂，这应该是才是彼此之间相伴的理由" class="headerlink" title="4.如果你认定一个人只是因为他对你好，那还是算了，对你好是一个巨大的陷阱，这并不能构成一个男人的优点，并且可替代性太强了，你花几千块雇一个保姆一样也可以做到，甚至做得更好，而坚韧，勇敢，自信，乐观，独立，果断的优秀品质才是无法被替代的，也就是所谓的有趣的灵魂，这应该是才是彼此之间相伴的理由"></a><strong>4.如果你认定一个人只是因为他对你好，那还是算了，对你好是一个巨大的陷阱，这并不能构成一个男人的优点，并且可替代性太强了，你花几千块雇一个保姆一样也可以做到，甚至做得更好，而坚韧，勇敢，自信，乐观，独立，果断的优秀品质才是无法被替代的，也就是所谓的有趣的灵魂，这应该是才是彼此之间相伴的理由</strong></h3><h3 id="5-接纳孤独，保持清醒和独立，把温柔和心软留给值得的人，用相对理智和清醒去压制心中的爱和难过"><a href="#5-接纳孤独，保持清醒和独立，把温柔和心软留给值得的人，用相对理智和清醒去压制心中的爱和难过" class="headerlink" title="5.接纳孤独，保持清醒和独立，把温柔和心软留给值得的人，用相对理智和清醒去压制心中的爱和难过"></a><strong>5.接纳孤独，保持清醒和独立，把温柔和心软留给值得的人，用相对理智和清醒去压制心中的爱和难过</strong></h3><h3 id="6-婚姻不一定幸福，单身也不一定不幸福，出生时一个人，离开时也不可能两个人，爱情是奢侈品，没有也行"><a href="#6-婚姻不一定幸福，单身也不一定不幸福，出生时一个人，离开时也不可能两个人，爱情是奢侈品，没有也行" class="headerlink" title="6.婚姻不一定幸福，单身也不一定不幸福，出生时一个人，离开时也不可能两个人，爱情是奢侈品，没有也行"></a><strong>6.婚姻不一定幸福，单身也不一定不幸福，出生时一个人，离开时也不可能两个人，爱情是奢侈品，没有也行</strong></h3><h3 id="7-人，结婚，是希望遇到事有个人商量，无聊了能有个人说说话，累了一天了，能在一桌开开心心吃个饭，一生实在太长了，总要有个相知相伴的人"><a href="#7-人，结婚，是希望遇到事有个人商量，无聊了能有个人说说话，累了一天了，能在一桌开开心心吃个饭，一生实在太长了，总要有个相知相伴的人" class="headerlink" title="7.人，结婚，是希望遇到事有个人商量，无聊了能有个人说说话，累了一天了，能在一桌开开心心吃个饭，一生实在太长了，总要有个相知相伴的人"></a><strong>7.人，结婚，是希望遇到事有个人商量，无聊了能有个人说说话，累了一天了，能在一桌开开心心吃个饭，一生实在太长了，总要有个相知相伴的人</strong></h3><h3 id="8-两个人在一起的前提：我懂你的故作矜持，你懂我的图谋不轨"><a href="#8-两个人在一起的前提：我懂你的故作矜持，你懂我的图谋不轨" class="headerlink" title="8.两个人在一起的前提：我懂你的故作矜持，你懂我的图谋不轨"></a><strong>8.两个人在一起的前提：我懂你的故作矜持，你懂我的图谋不轨</strong></h3><h3 id="9-没有谁配不上谁，两块钱一包盐，可以配上万的一桌菜，但上万的菜，没有盐也是淡然无味"><a href="#9-没有谁配不上谁，两块钱一包盐，可以配上万的一桌菜，但上万的菜，没有盐也是淡然无味" class="headerlink" title="9.没有谁配不上谁，两块钱一包盐，可以配上万的一桌菜，但上万的菜，没有盐也是淡然无味"></a><strong>9.没有谁配不上谁，两块钱一包盐，可以配上万的一桌菜，但上万的菜，没有盐也是淡然无味</strong></h3><h3 id="10-人生是场马拉松，不能带着一时的苟且，就带着悔恨跑一生"><a href="#10-人生是场马拉松，不能带着一时的苟且，就带着悔恨跑一生" class="headerlink" title="10.人生是场马拉松，不能带着一时的苟且，就带着悔恨跑一生"></a><strong>10.人生是场马拉松，不能带着一时的苟且，就带着悔恨跑一生</strong></h3><h3 id="11-家亡两字嫖和赌，家败两字暴和凶，家贫两字懒和惰，家兴两字勤和俭，家和两字情和爱，家安两字忍和让"><a href="#11-家亡两字嫖和赌，家败两字暴和凶，家贫两字懒和惰，家兴两字勤和俭，家和两字情和爱，家安两字忍和让" class="headerlink" title="11.家亡两字嫖和赌，家败两字暴和凶，家贫两字懒和惰，家兴两字勤和俭，家和两字情和爱，家安两字忍和让"></a><strong>11.家亡两字嫖和赌，家败两字暴和凶，家贫两字懒和惰，家兴两字勤和俭，家和两字情和爱，家安两字忍和让</strong></h3><h3 id="12-个人做事原则：从利益出发，要不要做；从风险出发，该不该搏；从能力出发，该不该干；从结果出发，划不划算。而对不对则为次要因素"><a href="#12-个人做事原则：从利益出发，要不要做；从风险出发，该不该搏；从能力出发，该不该干；从结果出发，划不划算。而对不对则为次要因素" class="headerlink" title="12.个人做事原则：从利益出发，要不要做；从风险出发，该不该搏；从能力出发，该不该干；从结果出发，划不划算。而对不对则为次要因素"></a><strong>12.个人做事原则：从利益出发，要不要做；从风险出发，该不该搏；从能力出发，该不该干；从结果出发，划不划算。而对不对则为次要因素</strong></h3><h3 id="13-女生着重细节，男生着重态度，你不给明确态度，我又何必在意你的细节，相互的两个人才有意义"><a href="#13-女生着重细节，男生着重态度，你不给明确态度，我又何必在意你的细节，相互的两个人才有意义" class="headerlink" title="13.女生着重细节，男生着重态度，你不给明确态度，我又何必在意你的细节，相互的两个人才有意义"></a><strong>13.女生着重细节，男生着重态度，你不给明确态度，我又何必在意你的细节，相互的两个人才有意义</strong></h3>]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（十七）</title>
    <url>/2021/04/03/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-qTIbtYlc" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="534228257" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、创建类"><a href="#一、创建类" class="headerlink" title="一、创建类"></a><strong>一、创建类</strong></h3><p>首先，什么是类？在<a href="https://www.runoob.com/python/python-object.html">菜鸟教程</a>中是这样解释的：它是用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法，对象是类的实例。</p>
<p>那么在创建类的过程中，对于类名约定俗成是用大写字母开头，类名后面试没有括号的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#dog.py</span><br><span class="line"></span><br><span class="line">class Dog:</span><br><span class="line">	&quot;&quot;&quot;一次模拟小狗的简单尝试。&quot;&quot;&quot;</span><br><span class="line">	def __init__(self, name, age):</span><br><span class="line">		&quot;&quot;&quot;初始化属性name和age。&quot;&quot;&quot;</span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line">		</span><br><span class="line">	def sit(self):</span><br><span class="line">		&quot;&quot;&quot;模拟小狗收到命令时蹲下。&quot;&quot;&quot;</span><br><span class="line">		print(f&quot;&#123;self.name&#125; is now sitting.&quot;)</span><br><span class="line">	</span><br><span class="line">	def roll_over(self):</span><br><span class="line">		&quot;&quot;&quot;模拟小狗收到命令时打滚。&quot;&quot;&quot;</span><br><span class="line">		print(f&quot;&#123;self.name&#125; rolled over!&quot;)</span><br></pre></td></tr></table></figure>

<p>类中的函数称为方法，前接触到的有关函数的一切都适用于方法，就目前而言，唯一重要的差别是调用方法的方式。方法 <code>__init__(  )</code>是一个特殊方法，被称为类的构造函数或初始化方法，每当根据Dog类创建新实例时，Python 都会自动运行它，方法的开头和末尾各有两个下划线，这是一种约定，目的是：避免Python默认方法与普通方法发生名称冲突</p>
<p>从上面的dog.py中观察，我们将方法<code>__init__(  )</code>定义成包含三个形参：self、name和age。在这个方法的定义中，形参self必不可少，而且必须位于其他形参的前面，self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数，那为什么必须在方法定义中包含形参self呢？</p>
<p>是因为Python调用这个方法来创建Dog实例时，将自动传入实参self。每个与实例相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。创建Dog实例时，Python将调用Dog类的方法<code>__init__(  )</code>。我们将通过实参向Dog(  )传递名字和年龄，self会自动传递，因此不需要传递它。每当根据Dog类创建实例时，都只需给最后两个形参（name和age）提供值</p>
<p>紧接着两个变量都有前缀self，以self为前缀的变量可供类中的所有方法使用，可以通过类的任何实例来访问。self.name &#x3D; name获取与形参name相关联的值，并将其赋给变量name，然后该变量被关联到当前创建的实例。self.age &#x3D; age的作用与此类似，像这样可通过实例访问的变量称为属性</p>
<h3 id="二、创建实例"><a href="#二、创建实例" class="headerlink" title="二、创建实例"></a><strong>二、创建实例</strong></h3><p>对于上面的类的理解，也可以将类视为有关如何创建实例的说明，好比Dog类是一系列说明，让Python知道如何创建表示特定小狗的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">	&quot;&quot;&quot;一次模拟小狗的简单尝试。&quot;&quot;&quot;</span><br><span class="line">	def __init__(self, name, age):</span><br><span class="line">		&quot;&quot;&quot;初始化属性name和age。&quot;&quot;&quot;</span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line">		</span><br><span class="line">my_dog = Dog(&#x27;Willie&#x27;, 6)</span><br><span class="line">print(f&quot;My dog&#x27;s name is &#123;my_dog.name&#125;.&quot;)</span><br><span class="line">print(f&quot;My dog is &#123;my_dog.age&#125; years old.&quot;)</span><br><span class="line">输出：</span><br><span class="line">My dog&#x27;s name is Willie.</span><br><span class="line">My dog is 6 years old.</span><br></pre></td></tr></table></figure>

<p>调用方法中的属性或者说访问属性，其实这里的所谈到的属性，就相当于函数中的形参。属性的值，就相当于向函数传递的实参，要访问实例的属性，可使用句点表示法，例如上面的实例，重新赋给了变了my_dog，此时要访问第一个属性，那么就可以使用my_dog.name就可以了。同样的，如果要调用方法，就直接my_dog.sit(  )，格式：实例名+.+方法名，这里我把类下的方法名就理解为函数的函数名</p>
<p>当然，如果依据需求来说，需要创建多个实例时，就直接创建后直接调用即可，条件是将每个实例都存储在不同的变量中，或者占用列表或字典的不同位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">	&quot;&quot;&quot;一次模拟小狗的简单尝试。&quot;&quot;&quot;</span><br><span class="line">	def __init__(self, name, age):</span><br><span class="line">		&quot;&quot;&quot;初始化属性name和age。&quot;&quot;&quot;</span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line">		</span><br><span class="line">my_dog = Dog(&#x27;Willie&#x27;, 6)</span><br><span class="line">your_dog = Dog(&#x27;Lucy&#x27;, 3)</span><br><span class="line"></span><br><span class="line">print(f&quot;My dog&#x27;s name is &#123;my_dog.name&#125;.&quot;)</span><br><span class="line">print(f&quot;My dog is &#123;my_dog.age&#125; years old.&quot;</span><br><span class="line">my_dog.sit()</span><br><span class="line"></span><br><span class="line">print(f&quot;\nYour dog&#x27;s name is &#123;your_dog.name&#125;.&quot;) </span><br><span class="line">print(f&quot;Your dog is &#123;your_dog.age&#125; years old.&quot;)</span><br><span class="line">your_dog.sit()</span><br><span class="line">输出：</span><br><span class="line">My dog&#x27;s name is Willie. </span><br><span class="line">My dog is 6 years old.</span><br><span class="line">Willie is now sitting. </span><br><span class="line"></span><br><span class="line">Your dog&#x27;s name is Lucy. </span><br><span class="line">Your dog is 3 years old.</span><br><span class="line">Lucy is now sitting.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（十六）</title>
    <url>/2021/04/02/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-IhWMQMgM" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1834081550" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="将函数存储在模块中"><a href="#将函数存储在模块中" class="headerlink" title="将函数存储在模块中"></a><strong>将函数存储在模块中</strong></h3><p>之前使用函数是可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多，那么接下来还可以进一步将函数存储在称为模块的独立文件中，再将模块导入到主程序中，import语句允许在当前运行的程序文件中使用模块中的代码。通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。</p>
<p>导入模块的方法有多种，这里详细的记录一下几种方式，要让函数是可导入的，得先创建模块。模块是扩展名为.py的文件，包含要导入到程序中的代码。</p>
<h4 id="1-导入整个模块"><a href="#1-导入整个模块" class="headerlink" title="1.导入整个模块"></a><strong>1.导入整个模块</strong></h4><p>首先，创建一个包含函数make_pizza(  )的模块，命名：pizza.py，代码块如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##pizza.py</span><br><span class="line"></span><br><span class="line">def make_pizza(size, *toppings):</span><br><span class="line">	&quot;&quot;&quot;概述要制作的比萨。&quot;&quot;&quot;</span><br><span class="line">	print(f&quot;\nMaking a &#123;size&#125;-inch pizza with the following toppings:&quot;)</span><br><span class="line">	for topping in toppings:</span><br><span class="line">		print(f&quot;- &#123;topping&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>接下来，在pizza.py所在的目录中创建一个名为making_pizzas.py的文件。这个文件导入刚创建的模块，再调用make_pizza(  )两次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##making_pizzas.py</span><br><span class="line"></span><br><span class="line">import pizza</span><br><span class="line"></span><br><span class="line">pizza.make_pizza(16, &#x27;pepperoni&#x27;)</span><br><span class="line">pizza.make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)</span><br><span class="line">输出：</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni </span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings: </span><br><span class="line">- mushrooms </span><br><span class="line">- green peppers </span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure>

<p>要调用被导入模块中的函数，可指定被导入模块的名称pizza和函数名make_pizza(  )，并用句点分隔。这就是第一种全模块导入方法，只需编写一条import语句并在其中指定模块名，就可在程序中使用该模块中的所有函数。</p>
<p>其最后归纳的导入语法是：import+模块名，调用函数语法是：模块名+.+函数体</p>
<h4 id="2-导入特定函数"><a href="#2-导入特定函数" class="headerlink" title="2.导入特定函数"></a><strong>2.导入特定函数</strong></h4><p>首先，先展示归纳的导入特定函数的语法是：from+模块名+import+函数名，还以上面pizza.py为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pizza import make_piazza</span><br><span class="line"></span><br><span class="line">make_pizza(16, &#x27;pepperoni&#x27;) </span><br><span class="line">make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)</span><br><span class="line">输出：</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni </span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings: </span><br><span class="line">- mushrooms </span><br><span class="line">- green peppers </span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure>

<p>如果要导入多个特定函数，就直接在函数名后面直接加，用逗号隔开就行</p>
<h4 id="3-使用as给函数或模块指定别名"><a href="#3-使用as给函数或模块指定别名" class="headerlink" title="3.使用as给函数或模块指定别名"></a><strong>3.使用as给函数或模块指定别名</strong></h4><p>同样的依旧是先展示函数别名语法：from+模块名+import+函数名+as+别名，模块别名语法：import+模块名+as+别名，同样还以上面pizza.py为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pizza import make_piazza as mp()</span><br><span class="line">#或者：import pizza as mp</span><br><span class="line"></span><br><span class="line">mp(16, &#x27;pepperoni&#x27;) </span><br><span class="line">#或者：mp.make_pizza(16, &#x27;pepperoni&#x27;)</span><br><span class="line"></span><br><span class="line">mp(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)</span><br><span class="line">或者：mp.make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni </span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings: </span><br><span class="line">- mushrooms </span><br><span class="line">- green peppers </span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure>

<h4 id="4-导入模块中所有的函数"><a href="#4-导入模块中所有的函数" class="headerlink" title="4.导入模块中所有的函数"></a><strong>4.导入模块中所有的函数</strong></h4><p>可以使用星号运算符可让Python导入模块中的所有函数，语法是：from+模块名+import+星号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pizza import *</span><br><span class="line"></span><br><span class="line">make_pizza(16, &#x27;pepperoni&#x27;) </span><br><span class="line">make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)</span><br><span class="line">输出：</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni </span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings: </span><br><span class="line">- mushrooms </span><br><span class="line">- green peppers </span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure>

<p>之前一直纠结既然有将整个模块导入的这种方式，为何还要有导入模块中所有函数的这种方式，后来才有了以下的诠释：import语句中的星号让Python将模块pizza中的每个函数都复制到这个程序文件中。由于导入了每个函数，可通过名称来调用每个函数，而无须使用句点表示法。然而，使用并非自己编写的大型模块时，最好不要采用这种导入方法。这是因为如果模块中有函数的名称与当前项目中使用的名称相同，可能导致意想不到的结果：Python可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。 最佳的做法是，要么只导入需要使用的函数，要么导入整个模块并使用 句点表示法，这让代码更清晰，更容易阅读和理解</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（十五）</title>
    <url>/2021/04/01/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-OSphSaVI" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="415191926" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、向函数传递列表"><a href="#一、向函数传递列表" class="headerlink" title="一、向函数传递列表"></a><strong>一、向函数传递列表</strong></h3><p>将列表传递给函数后，带来的好处是：函数可以直接访问列表中的内容，提高函数处理列表的效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def greet_users(names):</span><br><span class="line">	&quot;&quot;&quot;向列表中的每位用户发出简单的问候。&quot;&quot;&quot;</span><br><span class="line">	for name in names:</span><br><span class="line">		msg = f&quot;Hello, &#123;name.title()&#125;!&quot;</span><br><span class="line">		print(msg)</span><br><span class="line">usernames = [&#x27;hannah&#x27;, &#x27;ty&#x27;, &#x27;margot&#x27;]</span><br><span class="line">greet_users(usernames)</span><br><span class="line">输出：</span><br><span class="line">Hello, Hannah!</span><br><span class="line">Hello, Ty!</span><br><span class="line">Hello, Margot!</span><br></pre></td></tr></table></figure>

<p>在之前单独接触列表时，曾涉及到列表中的元素是可以直接进行修改的，同样的在这里函数中列表也是可以修改的，两者是通的，需要注意的是：函数对列表作出的任何修改都是永久性的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##以下代码块是未使用函数实现的，未使用函数，未使用函数！！！</span><br><span class="line"></span><br><span class="line"># 首先创建一个列表，其中包含一些要打印的设计。</span><br><span class="line">unprinted_designs = [&#x27;phone case&#x27;, &#x27;robot pendant&#x27;, &#x27;dodecahedron&#x27;]</span><br><span class="line">completed_models = []</span><br><span class="line"># 模拟打印每个设计，直到没有未打印的设计为止。</span><br><span class="line"># 打印每个设计后，都将其移到列表completed_models中。</span><br><span class="line">while unprinted_designs:</span><br><span class="line">	current_design = unprinted_designs.pop()</span><br><span class="line">	print(f&quot;Printing model: &#123;current_design&#125;&quot;)</span><br><span class="line">	completed_models.append(current_design)</span><br><span class="line"># 显示打印好的所有模型。</span><br><span class="line">print(&quot;\nThe following models have been printed:&quot;)</span><br><span class="line">for completed_model in completed_models:</span><br><span class="line">	print(completed_model)</span><br><span class="line">输出：</span><br><span class="line">Printing model: dodecahedron</span><br><span class="line">Printing model: robot pendan</span><br><span class="line">Printing model: phone case</span><br><span class="line"></span><br><span class="line">The following models have been printed:</span><br><span class="line">dodecahedron</span><br><span class="line">robot pendant</span><br><span class="line">phone case</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##以下代码块是使用函数实现的，使用函数，使用函数！！！</span><br><span class="line">def print_models(unprinted_designs, completed_models):</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	模拟打印每个设计，直到没有未打印的设计为止。 </span><br><span class="line">	打印每个设计后，都将其移到列表completed_models中。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    while unprinted_designs:</span><br><span class="line">    current_design = unprinted_designs.pop()</span><br><span class="line">    print(f&quot;Printing model: &#123;current_design&#125;&quot;)</span><br><span class="line">    completed_models.append(current_design)</span><br><span class="line">def show_completed_models(completed_models):</span><br><span class="line">	&quot;&quot;&quot;显示打印好的所有模型。&quot;&quot;&quot;</span><br><span class="line">	print(&quot;\nThe following models have been printed:&quot;)</span><br><span class="line">	for completed_model in completed_models:</span><br><span class="line">		print(completed_model)</span><br><span class="line">unprinted_designs = [&#x27;phone case&#x27;, &#x27;robot pendant&#x27;, &#x27;dodecahedron&#x27;]</span><br><span class="line">completed_models = []</span><br><span class="line">print_models(unprinted_designs, completed_models)</span><br><span class="line">show_completed_models(completed_models)</span><br><span class="line">输出：</span><br><span class="line">Printing model: dodecahedron</span><br><span class="line">Printing model: robot pendan</span><br><span class="line">Printing model: phone case</span><br><span class="line"></span><br><span class="line">The following models have been printed:</span><br><span class="line">dodecahedron</span><br><span class="line">robot pendant</span><br><span class="line">phone case</span><br></pre></td></tr></table></figure>

<p>但是由于函数对列表的修改是永久性的，无法保证原列表不受影响，所以这里引入了之前所提到的切片副本的概念，即向函数传递的非源列表，而是源列表的副本，这样函数修改的列表即为列表的副本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##以下代码块是使用函数及列表切片副本实现的，使用函数及列表切片副本，使用函数及列表切片副本！！！</span><br><span class="line">def print_models(unprinted_designs[:],, completed_models):</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	模拟打印每个设计，直到没有未打印的设计为止。 </span><br><span class="line">	打印每个设计后，都将其移到列表completed_models中。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    while unprinted_designs:</span><br><span class="line">    current_design = unprinted_designs.pop()</span><br><span class="line">    print(f&quot;Printing model: &#123;current_design&#125;&quot;)</span><br><span class="line">    completed_models.append(current_design)</span><br><span class="line">def show_completed_models(completed_models):</span><br><span class="line">	&quot;&quot;&quot;显示打印好的所有模型。&quot;&quot;&quot;</span><br><span class="line">	print(&quot;\nThe following models have been printed:&quot;)</span><br><span class="line">	for completed_model in completed_models:</span><br><span class="line">		print(completed_model)</span><br><span class="line">unprinted_designs = [&#x27;phone case&#x27;, &#x27;robot pendant&#x27;, &#x27;dodecahedron&#x27;]</span><br><span class="line">completed_models = []</span><br><span class="line">print_models(unprinted_designs, completed_models)</span><br><span class="line">show_completed_models(completed_models)</span><br><span class="line">输出：</span><br><span class="line">Printing model: dodecahedron</span><br><span class="line">Printing model: robot pendan</span><br><span class="line">Printing model: phone case</span><br><span class="line"></span><br><span class="line">The following models have been printed:</span><br><span class="line">dodecahedron</span><br><span class="line">robot pendant</span><br><span class="line">phone case</span><br></pre></td></tr></table></figure>

<h3 id="二、传递任意数量的实参"><a href="#二、传递任意数量的实参" class="headerlink" title="二、传递任意数量的实参"></a><strong>二、传递任意数量的实参</strong></h3><p>其实向函数传递任意数量的实参，书中把它看做向函数传递元组，元组里包含多个元素。因为有时候，预先不知道函数需要接受多少个实参，但在Python是允许函数从调用语句中收集任意数量的实参的，而在我自己理解的是：向函数传递列表，因为列表和元组很相似，最根本的区别是：列表中的元素是可以修改的，而元组中的元素是不可以修改的。然而我们去向形参传递实参的时候，实参的元素本就是一个可变的过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def make_pizza(*toppings):</span><br><span class="line">	&quot;&quot;&quot;打印顾客点的所有配料。&quot;&quot;&quot;</span><br><span class="line">	print(toppings)</span><br><span class="line">make_pizza(&#x27;pepperoni&#x27;)</span><br><span class="line">make_pizza(&#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)</span><br><span class="line">输出：</span><br><span class="line">(&#x27;pepperoni&#x27;,) </span><br><span class="line">(&#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)</span><br></pre></td></tr></table></figure>

<p>形参名*toppings中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封装到这个元组中，即便函数只收到一个值，当然如果想要结合位置，可以使实参和形参保持对应关系，值得注意的是：如果有需要传递不确定数量的实参时，形参位置必须要放在最后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def make_pizza(size, *toppings):</span><br><span class="line">	&quot;&quot;&quot;概述要制作的比萨。&quot;&quot;&quot;</span><br><span class="line">	print(f&quot;\nMaking a &#123;size&#125;-inch pizza with the following toppings:&quot;)</span><br><span class="line">	for topping in toppings:</span><br><span class="line">		print(f&quot;- &#123;topping&#125;&quot;)</span><br><span class="line">make_pizza(16, &#x27;pepperoni&#x27;)</span><br><span class="line">make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)</span><br><span class="line">输出：</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings:</span><br><span class="line">- mushrooms </span><br><span class="line">- green peppers </span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure>

<p>接下的的代码块示例是我在接触使用任意数量的关键字实参时，觉得有点绕的地方，这里Key一下，防止日后纠结转不过来，个人理解的其实质是：函数体括号中存在的是一个完整的字典，首先函数处理的是先让字典user_info里先有第一个键值对：’first_name’:’first’，其次处理的是让字典user_info里再有第二个键值对：’last_name’:’last’，接下来由于**user_info可以接受任意数量的实参，所以这时接收了location&#x3D;’princeton’和field&#x3D;’physics’这两个键值对，所以最后一共在字典user_info里会有4个键值对，而不是之前一直纠结的只有’location’:’princeton’和’field’: ‘physics’这两个键值对了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def build_profile(first, last, **user_info):</span><br><span class="line">	&quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切。&quot;&quot;&quot;</span><br><span class="line">	user_info[&#x27;first_name&#x27;] = first</span><br><span class="line">	user_info[&#x27;last_name&#x27;] = last</span><br><span class="line">	return user_info</span><br><span class="line">user_profile = build_profile(&#x27;albert&#x27;, </span><br><span class="line">							&#x27;einstein&#x27;,</span><br><span class="line">                            location=&#x27;princeton&#x27;, 															field=&#x27;physics&#x27;)</span><br><span class="line">print(user_profile)</span><br><span class="line">输出：</span><br><span class="line">&#123;&#x27;location&#x27;: &#x27;princeton&#x27;, &#x27;field&#x27;: &#x27;physics&#x27;, &#x27;first_name&#x27;: &#x27;albert&#x27;, &#x27;last_name&#x27;: &#x27;einstein&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>啊，终于把这里弄理解，搞懂了，一直卡在这里~~~</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（十四）</title>
    <url>/2021/03/31/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-DuUnsapD" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1449678888" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a><strong>返回值</strong></h3><p>返回值是函数执行结束后返回的一个或一组值，可使用return语句将值返回到调用函数的代码行，返回值能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序</p>
<p>首先，来一看一下函数返回一个简单值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def get_formatted_name(first_name, last_name): </span><br><span class="line">	&quot;&quot;&quot;返回整洁的姓名。&quot;&quot;&quot; </span><br><span class="line">	full_name = f&quot;&#123;first_name&#125; &#123;last_name&#125;&quot;</span><br><span class="line">	return full_name.title() </span><br><span class="line">musician = get_formatted_name(&#x27;jimi&#x27;, &#x27;hendrix&#x27;) </span><br><span class="line">print(musician)</span><br><span class="line">输出：Jimi Hendrix</span><br></pre></td></tr></table></figure>

<p>但有时name不只是只有first_name, last_name，也许还会有middle_name……或者更多，所以此时就会涉及到让实参变成可选，我们可以把可能用不到的实参进行默认初始化，且放于函数括号的最后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def get_formatted_name(first_name, last_name, middle_name=&#x27;&#x27;):</span><br><span class="line">	&quot;&quot;&quot;返回整洁的姓名。&quot;&quot;&quot;</span><br><span class="line">	if middle_name:	</span><br><span class="line">		full_name = f&quot;&#123;first_name&#125; &#123;middle_name&#125; &#123;last_name&#125;&quot;</span><br><span class="line">	else:</span><br><span class="line">		full_name = f&quot;&#123;first_name&#125; &#123;last_name&#125;&quot;</span><br><span class="line">	return full_name.title()</span><br><span class="line">musician = get_formatted_name(&#x27;jimi&#x27;, &#x27;hendrix&#x27;)</span><br><span class="line">print(musician)</span><br><span class="line">musician = get_formatted_name(&#x27;john&#x27;, &#x27;hooker&#x27;, &#x27;lee&#x27;)</span><br><span class="line">print(musician)</span><br><span class="line">输出：</span><br><span class="line">Jimi Hendrix</span><br><span class="line">John Lee Hooker</span><br></pre></td></tr></table></figure>

<p>当然，函数在进行返回时，返回的类型是多样化的，可能是：字符串、数值、列表甚至字典等比较复杂的数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def build_person(first_name, last_name):</span><br><span class="line">	&quot;&quot;&quot;返回一个字典，其中包含有关一个人的信息。&quot;&quot;&quot;</span><br><span class="line">	person = &#123;&#x27;first&#x27;: first_name, &#x27;last&#x27;: last_name&#125;</span><br><span class="line">	return person</span><br><span class="line">musician = build_person(&#x27;jimi&#x27;, &#x27;hendrix&#x27;)</span><br><span class="line">print(musician)</span><br><span class="line">输出：&#123;&#x27;first&#x27;: &#x27;jimi&#x27;, &#x27;last&#x27;: &#x27;hendrix&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>倘若对上面的代码块进行如下的优化，那么函数的代码逻辑又将变得更为复杂</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def build_person(first_name, last_name, age=None):</span><br><span class="line">	&quot;&quot;&quot;返回一个字典，其中包含有关一个人的信息。&quot;&quot;&quot;</span><br><span class="line">	person = &#123;&#x27;first&#x27;: first_name, &#x27;last&#x27;: last_name&#125;</span><br><span class="line">	if age:</span><br><span class="line">		person[&#x27;age&#x27;] = age</span><br><span class="line">	return person</span><br><span class="line">musician = build_person(&#x27;jimi&#x27;, &#x27;hendrix&#x27;, age=27)</span><br><span class="line">print(musician)</span><br><span class="line">输出：&#123;&#x27;first&#x27;: &#x27;jimi&#x27;, &#x27;last&#x27;: &#x27;hendrix&#x27;,&#x27;age&#x27;:&#x27;27&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>与此同时，上面的示例是结合if语句来进行条件测试，因为此时age有数值，所以布尔类型是True，将27赋予变量元素age，最终通过函数返回一个字典，字典中包含年龄的键值对。但往往也会跟while循环相结合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def get_formatted_name(first_name, last_name):</span><br><span class="line">	&quot;&quot;&quot;返回整洁的姓名。&quot;&quot;&quot;</span><br><span class="line">	full_name = f&quot;&#123;first_name&#125; &#123;last_name&#125;&quot;</span><br><span class="line">	return full_name.title()</span><br><span class="line">while True:</span><br><span class="line">	print(&quot;\nPlease tell me your name:&quot;)</span><br><span class="line">    print(&quot;(enter &#x27;q&#x27; at any time to quit)&quot;)</span><br><span class="line">    f_name = input(&quot;First name: &quot;)</span><br><span class="line">    if f_name == &#x27;q&#x27;:</span><br><span class="line">    	break</span><br><span class="line">    l_name = input(&quot;Last name: &quot;)</span><br><span class="line">    if l_name == &#x27;q&#x27;:</span><br><span class="line">    	break</span><br><span class="line">    formatted_name = get_formatted_name(f_name, l_name)   </span><br><span class="line">    print(f&quot;\nHello, &#123;formatted_name&#125;!&quot;)</span><br><span class="line">输出：</span><br><span class="line">Please tell me your name:</span><br><span class="line">(enter &#x27;q&#x27; at any time to quit)</span><br><span class="line">First name: eric</span><br><span class="line">Last name: matthes</span><br><span class="line"></span><br><span class="line">Hello, Eric Matthes!</span><br><span class="line"></span><br><span class="line">Please tell me your name:</span><br><span class="line">(enter &#x27;q&#x27; at any time to quit)</span><br><span class="line">First name: q</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（十三）</title>
    <url>/2021/03/30/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-ssCxszNR" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1457154397" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a><strong>定义函数</strong></h3><p>首先了解一下定义函数的格式是：def+函数名+括号+冒号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def greet_user(): </span><br><span class="line"> 	&quot;&quot;&quot;显示简单的问候语。&quot;&quot;&quot; </span><br><span class="line">    print(&quot;Hello!&quot;) </span><br><span class="line">greet_user()</span><br><span class="line">输出：Hello!</span><br></pre></td></tr></table></figure>

<p>紧跟在def greet_user(  ):后面的所有缩进行构成了函数体，代码块的第二行文本是称为文档字符串的注释，描述了函数是做什么的。 文档字符串用三引号括起，Python使用它们来生成有关程序中函数的文档。代码行print(“Hello!”)是函数体内的唯一一行代码，因此greet_user(  )只做一项工作：打印Hello! </p>
<p>由于这个函数不需要任何信息，调用它时只需输入greet_user(  )即可，假设需要向此函数传参才能执行输出，可以在括号中进行添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def greet_user(username):</span><br><span class="line">	&quot;&quot;&quot;显示简单的问候语。&quot;&quot;&quot;</span><br><span class="line">	print(f&quot;Hello, &#123;username.title()&#125;!&quot;)</span><br><span class="line">greet_user(&#x27;jesse&#x27;)</span><br><span class="line">输出：Hello, Jesse!</span><br></pre></td></tr></table></figure>

<p>仔细观察发现，一般来说我们所讲的传参，默认是实参，也就是函数在真正执行时，最终输出的，但是我们在定义函数的时候，括号中也有一个参数，这样的参数是形参。简单通俗一点来讲：形参就是一个影子，负责占坑，最终输出的是实参</p>
<p>位置实参，必定是跟顺序相关，具体的是指：实参的顺序和形参的顺序相同，要不然会出现信息关联不一致的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def describe_pet(animal_type, pet_name):</span><br><span class="line">	&quot;&quot;&quot;显示宠物的信息。&quot;&quot;&quot;</span><br><span class="line">	print(f&quot;\nI have a &#123;animal_type&#125;.&quot;)</span><br><span class="line">	print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)</span><br><span class="line">describe_pet(&#x27;hamster&#x27;, &#x27;harry&#x27;)</span><br><span class="line">输出：</span><br><span class="line">I have a hamster.</span><br><span class="line">My hamster&#x27;s name is Harry.</span><br></pre></td></tr></table></figure>

<p>在函数被定义后，我们可以多次的进行调用，次数不受任何限制</p>
<p>但是有时为了防止位置顺序没有按要求一一对应，那么还有一种补救，就是直接将实参和形参绑定在一起，写死，这样也可以，我们把这样方式称作为：关键字实参</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def describe_pet(animal_type, pet_name):</span><br><span class="line">	&quot;&quot;&quot;显示宠物的信息。&quot;&quot;&quot;</span><br><span class="line">	print(f&quot;\nI have a &#123;animal_type&#125;.&quot;)</span><br><span class="line">	print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)</span><br><span class="line">##从这里开始就是直接写死的情况，但最终达到的效果都是一样的</span><br><span class="line">describe_pet(animal_type=&#x27;hamster&#x27;, pet_name=&#x27;harry&#x27;)</span><br><span class="line">describe_pet(pet_name=&#x27;harry&#x27;, animal_type=&#x27;hamster&#x27;)</span><br><span class="line">输出：</span><br><span class="line">I have a hamster.</span><br><span class="line">My hamster&#x27;s name is harry.</span><br></pre></td></tr></table></figure>

<p>与此同时，如果编写函数时，描述的是某一类的集合时，我们是可以给每个形参指定默认值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def describe_pet(pet_name, animal_type=&#x27;dog&#x27;):</span><br><span class="line">	&quot;&quot;&quot;显示宠物的信息。&quot;&quot;&quot;</span><br><span class="line">	print(f&quot;\nI have a &#123;animal_type&#125;.&quot;)</span><br><span class="line">	print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)</span><br><span class="line">describe_pet(pet_name=&#x27;willie&#x27;)</span><br></pre></td></tr></table></figure>

<p>这里就是直接将动物的类型默认为是狗，如果不对animal_type进行传参的话，那输出默认的animal_type就是狗，但如果后续传参animal_type &#x3D; ‘cat’，那此时以传参的为准，Python会将原先默认的animal_type忽略掉。</p>
<p>但由于我们在实际运用的过程中，会根据自身的习惯进行编码，所以也可能会混合使用，这也是等效的函数调用的好处</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（十二）</title>
    <url>/2021/03/29/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-znoYBxDB" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1423241987" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="利用while循环处理列表"><a href="#利用while循环处理列表" class="headerlink" title="利用while循环处理列表"></a><strong>利用while循环处理列表</strong></h3><p>在Python中，接触最频繁的，无非是：变量、、循环、列表、元素、元组、字典、函数、方法、类…..尽管有些还没接触，很快就会碰到</p>
<p>while对列表的处理，通常发生在列表与列表之间，从一个列表到另外一个列表，来回变动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首先，创建一个待验证用户列表 </span><br><span class="line"># 和一个用于存储已验证用户的空列表</span><br><span class="line">unconfirmed_users = [&#x27;alice&#x27;, &#x27;brian&#x27;, &#x27;candace&#x27;] </span><br><span class="line">confirmed_users = [] </span><br><span class="line"></span><br><span class="line"># 验证每个用户，直到没有未验证用户为止</span><br><span class="line"># 将每个经过验证的用户都移到已验证用户列表中</span><br><span class="line">while unconfirmed_users: </span><br><span class="line">	current_user = unconfirmed_users.pop() </span><br><span class="line">	print(f&quot;Verifying user: &#123;current_user.title()&#125;&quot;) 			</span><br><span class="line">	confirmed_users.append(current_user) </span><br><span class="line"></span><br><span class="line"># 显示所有已验证的用户</span><br><span class="line">print(&quot;\nThe following users have been confirmed:&quot;) </span><br><span class="line">for confirmed_user in confirmed_users: </span><br><span class="line">	print(confirmed_user.title())</span><br><span class="line">输出：</span><br><span class="line">Verifying user: Candace </span><br><span class="line">Verifying user: Brian </span><br><span class="line">Verifying user: Alice </span><br><span class="line"></span><br><span class="line">The following users have been confirmed: </span><br><span class="line">Candace </span><br><span class="line">Brian </span><br><span class="line">Alice</span><br></pre></td></tr></table></figure>

<p>之前在刚开始接触列表时，曾经提及到删除列表中的某个元素，使用的是方法.remove(  )，当但是也提醒的是：它只删除第一个指定的值，如果要删除的值可能在列表中出现多次，就需要使用循环来确保将每个值都删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pets = [&#x27;dog&#x27;, &#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;cat&#x27;, &#x27;rabbit&#x27;, &#x27;cat&#x27;] </span><br><span class="line">while &#x27;cat&#x27; in pets:</span><br><span class="line">	pets.remove(&#x27;cat&#x27;) </span><br><span class="line">print(pets)</span><br><span class="line">输出：[&#x27;dog&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;rabbit&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="利用while循环处理字典"><a href="#利用while循环处理字典" class="headerlink" title="利用while循环处理字典"></a><strong>利用while循环处理字典</strong></h3><p>对于利用while循环来处理列表，不深究，不细究。因为对于字典来讲，前面说过它里面的数据都是以键值对的形式存在的，那么对于利用while循环，需保存的数据就会渐渐增加，越来越多后容易造成代码的复杂，就跟嵌套中的第三种，字典字典一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">responses = &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 设置一个标志，指出调查是否继续</span><br><span class="line">polling_active = True</span><br><span class="line"></span><br><span class="line">while polling_active:</span><br><span class="line"># 提示输入被调查者的名字和回答</span><br><span class="line">	name = input(&quot;\nWhat is your name? &quot;)</span><br><span class="line">	response = input(&quot;Which mountain would you like to climb someday? &quot;)</span><br><span class="line"># 将回答存储在字典中</span><br><span class="line">	responses[name] = response</span><br><span class="line"># 看看是否还有人要参与调查</span><br><span class="line">	repeat = input(&quot;Would you like to let another person respond? (yes/ no)</span><br><span class="line">	if repeat == &#x27;no&#x27;:</span><br><span class="line">		polling_active = False</span><br><span class="line"># 调查结束，显示结果</span><br><span class="line">print(&quot;\n--- Poll Results ---&quot;)</span><br><span class="line">for name, response in responses.items():</span><br><span class="line">	print(f&quot;&#123;name&#125; would like to climb &#123;response&#125;.&quot;)</span><br><span class="line">	</span><br><span class="line">输出：</span><br><span class="line">What is your name? </span><br><span class="line">Eric Which mountain would you like to climb someday? </span><br><span class="line">Denali Would you like to let another person respond? (yes/ no) yes </span><br><span class="line"></span><br><span class="line">What is your name?</span><br><span class="line">Lynn Which mountain would you like to climb someday?</span><br><span class="line">Devil&#x27;s Thumb Would you like to let another person respond? (yes/ no) no </span><br><span class="line"></span><br><span class="line">--- Poll Results --- </span><br><span class="line">Eric would like to climb Denali. </span><br><span class="line">Lynn would like to climb Devil&#x27;s Thumb.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>永远相信美好的事情即将发生</title>
    <url>/2021/03/28/%E6%B0%B8%E8%BF%9C%E7%9B%B8%E4%BF%A1%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%BA%8B%E6%83%85%E5%8D%B3%E5%B0%86%E5%8F%91%E7%94%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-lMErSeBY" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="510309106" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p>其实最近一直想写写自己的生活的，但一直比较忙，可能4月会稍微的放缓一下脚步，自己一个人带着单反出去散散心。</p>
<p>过年偷偷的回了一趟家，跟爸妈一起过个年.也是临时果断下的决定，先前好不容易抢到的高铁票，在种种原因下被逼退了票，直到三十晚上那天毅然决然的还是再买了票回家，有家人在身边才叫过年，一个人待在上海过年，过个寂寞锤子。在上海一年到头，这几年一个人，雷打不动一年回家三次：春节、五一、国庆。父母在，人生尚有来往；父母去，人生犹如单程票。所以这个规矩不能破，我也深知每年这个时候，老父母也指望着回家，归途。</p>
<p>尽管到了适婚年龄，每次回去都被烦，很狂躁，但也就真的听着，每次家里过年办饭，舅舅们总把这个敏感的话题拎出来，其实我也知道整个家族都很急，因为不管是在我爸这边，还是在我妈这边，我都是最小的一个，他们就怕娶不到老婆，毕竟待在农村里久了，思维可能有一种定型。</p>
<p>但从我自己内心最真实的想法出发，自己目前的状态是：想谈是真的想谈，也可以谈了，但因为工作性质的原因，接触异性的机会很少，这是其一；其二，我深知自己的性格和脾气，在爱情这方面是个一路向前走的品性，遇到有些合适人，也会很主动去靠近，发起请求，但只要对方不响应或者返回不合适的馈值，我也很果断的撒手，即便再合适，错过了就错过了，不会回头。在我爱的人和爱我的人中，二者选其一，我会很直接果断，义无反顾的去选择爱我的人，因为两者彼此双向的奔赴，懂得珍惜才是今后在一起生活的夯实基础，前提是经济条件还行。</p>
<p>其三，是因为来上海这几年让我认清种种现实，没有平白无故的帮助，凡事都有目的性，目的性可好可坏，免费的东西最贵。要想在上海这个地方饿不死，过上中等偏下的生活，就要果断独立，就要舍得给自己投资，让自己更加值钱，赚取更高的薪资，但永远不要给别人打工，有机会自己一定要创业，但目前我只能靠给别人打工来维持生计。说的这些都是自己悟的思维想法，更多的还是要花上很大时间去投入实践，由于从事IT这一块，我花了很大一部分非工作时间及资金去投入在探索某些新技术领域，自行的宅在家里借鉴性学习，可能说学习有点过，就说玩吧，就是那种玩带有技术性的东西，所以也没太多的时间像有些朋友一样当海王，撩妹一大群，说实话家教在那里，注定跟这种类型的人不在一个Level上。</p>
<p>年前，2月7号，也有幸认识一个女孩子，没有后来，其实是我钟意的，说来也挺……<br>事由当天晚上，发了个圈，因为一起合租的室友回老家发展，一个人租个超大单间有点奢侈，毕竟租金不便宜，想找个室友摊租金，实在找不到就准备搬家。不久后，圈下评论就沦陷了，大意基本上就是让找对象啥的，以后就不用为租房啥的发愁，有之前领导要介绍的，有身边朋友要介绍的，而她就是朋友介绍的。</p>
<p>聊了一段时间后，其实我感觉还行，性格啥的还好，也合得来。2月28号，两个人周日想约着见一面，其实我是不想那天去的，因为上海那段时间天气都不好，不是阴天就是下雨，最后还是在徐汇那家多抓鱼书店碰了个面，下午点了个下午茶，聊了聊。见面那一刻，心情也没大起大落，很正常，很淡稳，好像就很自来熟那种。好似就见个朋友，没有高期待，因为之前看过她照片，挺质朴本分的一个女孩子，微微淡妆不失端雅，我平常穿休闲装穿习惯，就简简单单的，撑了一把伞.<br>3月15号，很突然的，就没然后了……各自回归平静，有这样的果，必定有先前的因，但具体什么因，我觉得也没必要再盯着人家去深究。</p>
<p>3月13号，请了一天假，连着周六日，找了个单间小窝，搬了家，还不错，是个精装修的小民房，带个独卫，租金还算过得去。但失去的是：自己不能再做饭了，没了厨房，也不靠近菜场，能做的就是煮一些即食，做个粥，煮个鸡蛋，炖个银耳莲子羹……炒菜一律Pass。其实，要不是自己做菜的生活成本低，吃的健康，我是真的不想做饭，不是不会也不是懒，而是因为全是电磁炉，炒出的菜，都不好吃，没胃口，没煤气灶铁锅炒的有味。</p>
<p>当然，除了这些，还有就是自己的作息时间更加规律，一般10点半左右就躺下，身体感觉真的不如之前刚来上海那段时间。个人更加自律，更专心的做自己需要的和想要的事，近期针对个人搭建的博客域名到期，完善了新域名的切换，技术方面也在为转自动化测试作铺垫，每天Python的学习进度及知识点的整理，同步更新博客的编程测试模块，一切都在如期的进行着，想要成为一个怎样的人就是一个怎样的人，狠一点。</p>
<p>搬到小单间，就一点不太好，隔断墙，隔音效果非常不好，隔壁稍微大点的5个单间，住着5对小情侣，伤害性不大，侮辱性极强。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（十一）</title>
    <url>/2021/03/27/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-WmsvUzYP" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="16494132" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a><strong>While循环</strong></h3><p> 编程界的三大循环：if、for、while。if之前是在遍历的时候开始接触，for之前是在元素是否在列表中开始接触，而while从此刻开始认识。while循环是不断运行，直到指定的条件不满足为止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">current_number = 1 </span><br><span class="line">while current_number &lt;= 5: </span><br><span class="line">	print(current_number) </span><br><span class="line">	current_number += 1</span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>当然，无限的循环在程序中执行时，也会受到人为的干扰或者终止。其中，我们也可以在被执行程序中添加由用户决定什么时候停止循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prompt = &quot;\nTell me something, and I will repeat it back to you:&quot; </span><br><span class="line">prompt += &quot;\nEnter &#x27;quit&#x27; to end the program. &quot;</span><br><span class="line">message = &quot;&quot;</span><br><span class="line">while message != &#x27;quit&#x27;: </span><br><span class="line">	message = input(prompt) </span><br><span class="line">	print(message)</span><br><span class="line">输出：</span><br><span class="line">Tell me something, and I will repeat it back to you: </span><br><span class="line">Enter &#x27;quit&#x27; to end the program. Hello everyone! </span><br><span class="line">Hello everyone!</span><br></pre></td></tr></table></figure>

<p>为使被执行程序，更加简洁直接，因为上述代码中，美中不足的是：将quit也作为输出展示了出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prompt = &quot;\nTell me something, and I will repeat it back to you:&quot; </span><br><span class="line">prompt += &quot;\nEnter &#x27;quit&#x27; to end the program. &quot; </span><br><span class="line">message = &quot;&quot; </span><br><span class="line">while message != &#x27;quit&#x27;: </span><br><span class="line">	message = input(prompt) </span><br><span class="line">	if message != &#x27;quit&#x27;: </span><br><span class="line">		print(message)</span><br><span class="line">输出：</span><br><span class="line">Tell me something, and I will repeat it back to you: </span><br><span class="line">Enter &#x27;quit&#x27; to end the program. Hello everyone! </span><br><span class="line">Hello everyone! </span><br><span class="line"></span><br><span class="line">Tell me something, and I will repeat it back to you: </span><br><span class="line">Enter &#x27;quit&#x27; to end the program. Hello again. </span><br><span class="line">Hello again. </span><br><span class="line"></span><br><span class="line">Tell me something, and I will repeat it back to you: </span><br><span class="line">Enter &#x27;quit&#x27; to end the program. quit</span><br></pre></td></tr></table></figure>

<p>那么对于有些被执行程序，并不是被编码完成后就必须要进行执行，一般是达到某个条件或者说是触发了某个开关后，再去执行。我们把这一过程称作为：标志（相当于总开关）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prompt = &quot;\nTell me something, and I will repeat it back to you:&quot; </span><br><span class="line">prompt += &quot;\nEnter &#x27;quit&#x27; to end the program. &quot; </span><br><span class="line">active = True</span><br><span class="line">while active: </span><br><span class="line">	message = input(prompt) </span><br><span class="line">	if message == &#x27;quit&#x27;: </span><br><span class="line">		active = False</span><br><span class="line">	else:</span><br><span class="line">		print(message)</span><br></pre></td></tr></table></figure>

<p>假设一下：如果循环正在进行，人为的立即退出循环，可否实现？通常利用break去实现。</p>
<p>break语句用于控制程序流程，可用来控制哪些代码行将执行、哪些代码行不执行，从而让程序按你的要求执行你要执行的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prompt = &quot;\nPlease enter the name of a city you have visited:&quot; </span><br><span class="line">prompt += &quot;\n(Enter &#x27;quit&#x27; when you are finished.) &quot;</span><br><span class="line">while True: </span><br><span class="line">city = input(prompt) </span><br><span class="line">if city == &#x27;quit&#x27;: </span><br><span class="line">	break </span><br><span class="line">else:</span><br><span class="line">	print(f&quot;I&#x27;d love to go to &#123;city.title()&#125;!&quot;)</span><br><span class="line">输出：</span><br><span class="line">Please enter the name of a city you have visited: </span><br><span class="line">(Enter &#x27;quit&#x27; when you are finished.) New York </span><br><span class="line">I&#x27;d love to go to New York!</span><br><span class="line"></span><br><span class="line">Please enter the name of a city you have visited: </span><br><span class="line">(Enter &#x27;quit&#x27; when you are finished.) quit</span><br></pre></td></tr></table></figure>

<p>当然，break语句不仅仅局限于用于while循环中，在Python的任意循环中都可以使用。</p>
<p>既然有退出，相对应的就有继续，continue。要返回循环开头，并根据条件测试结果决定是否继续执行循环，就可使用continue语句，它不像break语句那样不再执行余下的代码并退出整个循环。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">current_number = 0 </span><br><span class="line">while current_number &lt; 10: </span><br><span class="line">	current_number += 1 </span><br><span class="line">	if current_number % 2 == 0: </span><br><span class="line">		continue </span><br><span class="line">	print(current_number)</span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（十）</title>
    <url>/2021/03/26/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-eVlQmnAt" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1890905" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="接收用户输入"><a href="#接收用户输入" class="headerlink" title="接收用户输入"></a><strong>接收用户输入</strong></h3><p>首先，什么是接收用户输入？何种情况下接收用户输入？</p>
<p>接收用户输入，说直白一点就是从用户手里拿数据，确保程序的正常执行；一般情况下当需要和用户进行交互，向程序提供一些信息后，得到想要的输出结果时，采取函数input(  )接收用户输入。</p>
<p>对于函数input(  )的工作原理是：让程序暂停运行，等待用户输入一些文本，获取用户输入后，Python将其赋给一个变量，以供使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message = input(&quot;Tell me something, and I will repeat it back to you: &quot;) print(message)</span><br><span class="line">输出：</span><br><span class="line">Tell me something, and I will repeat it back to you: Hello everyone!</span><br><span class="line">Hello everyone!</span><br></pre></td></tr></table></figure>

<p>有时候，提示可能超过一行，在这种情况下，可将提示赋给一个变量，再将该变量传递给函 </p>
<p>数input(  )。这样，即便提示超过一行，input(  )语句也会非常清晰</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prompt = &quot;If you tell us who you are, we can personalize the messages you see.&quot; prompt += &quot;\nWhat is your first name? &quot;</span><br><span class="line">name = input(prompt) </span><br><span class="line">print(f&quot;\nHello, &#123;name&#125;!&quot;)</span><br><span class="line">输出：</span><br><span class="line">If you tell us who you are, we can personalize the messages you see.</span><br><span class="line">What is your first name? Eric</span><br><span class="line"></span><br><span class="line">Hello, Eric!</span><br></pre></td></tr></table></figure>

<p>以上接触的是怎样接收用户输入，那接下来是接收用户输入的数据类型</p>
<p>数值类型：使用int(  )</p>
<p>在接收用户输入时，Python默认将接收的信息类型定义为字符串，但针对像某些变量，如：年龄，数量，第几名……这些都是数值类型，所以就不能定义为字符串，为解决这个问题，可使用函数int(  )，它让Python将输入视为数值，函数int(  )将数的字符串表示转换为数值表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age = input(&quot;How old are you? &quot;)</span><br><span class="line">age = int(age)</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">	print(&#x27;You are so old&#x27;)</span><br></pre></td></tr></table></figure>

<p>假设未对接收年龄数值进行转换，在PyCharm中运行，会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">How old are you? 40</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:/Pycharm/Project/PythonTest/Test.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    if age &gt;= 18:</span><br><span class="line">TypeError: &#x27;&gt;=&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure>

<p>既然谈及到数值，必定也会接触到一些关于数值类的运算，简单提及一下求模运算，%表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">number = input(&quot;Enter a number, and I&#x27;ll tell you if it&#x27;s even or odd: &quot;) </span><br><span class="line">number = int(number)</span><br><span class="line">if number % 2 == 0:</span><br><span class="line">	print(f&quot;\nThe number &#123;number&#125; is even.&quot;) </span><br><span class="line">else:</span><br><span class="line">	print(f&quot;\nThe number &#123;number&#125; is odd.&quot;)</span><br><span class="line">输出：</span><br><span class="line">Enter a number, and I&#x27;ll tell you if it&#x27;s even or odd: 44</span><br><span class="line"></span><br><span class="line">The number 44 is even.</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（九）</title>
    <url>/2021/03/25/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-pHrBtxAj" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1372514696" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a><strong>嵌套</strong></h3><p>有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套。现实情况中在列表中嵌套字典、在字典中嵌套列表甚至在字典中嵌套字典。</p>
<p>首先，字典列表就是字典放在列表中，先小字典，后大列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alien_0 = &#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125; </span><br><span class="line">alien_1 = &#123;&#x27;color&#x27;: &#x27;yellow&#x27;, &#x27;points&#x27;: 10&#125; </span><br><span class="line">alien_2 = &#123;&#x27;color&#x27;: &#x27;red&#x27;, &#x27;points&#x27;: 15&#125;</span><br><span class="line">aliens = [alien_0, alien_1, alien_2] </span><br><span class="line">for alien in aliens: </span><br><span class="line">	print(alien)</span><br><span class="line">输出：</span><br><span class="line">&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125; </span><br><span class="line">&#123;&#x27;color&#x27;: &#x27;yellow&#x27;, &#x27;points&#x27;: 10&#125;</span><br><span class="line">&#123;&#x27;color&#x27;: &#x27;red&#x27;, &#x27;points&#x27;: 15&#125;</span><br></pre></td></tr></table></figure>

<p>其次，列表字典就是列表放在字典中，先小列表，后大字典</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pizza = &#123;</span><br><span class="line">	&#x27;crust&#x27;: &#x27;thick&#x27;,</span><br><span class="line">    &#x27;toppings&#x27;: [&#x27;mushrooms&#x27;, &#x27;extra cheese&#x27;],</span><br><span class="line">    &#125;</span><br><span class="line">print(f&quot;You ordered a &#123;pizza[&#x27;crust&#x27;]&#125;-crust pizza &quot; </span><br><span class="line">	&quot;with the following toppings:&quot;)</span><br><span class="line">for topping in pizza[&#x27;toppings&#x27;]:</span><br><span class="line">	print(&quot;\&quot;+topping)</span><br><span class="line">输出：</span><br><span class="line">You ordered a thick-crust pizza with the following toppings: </span><br><span class="line">	mushrooms </span><br><span class="line">	extra cheese</span><br></pre></td></tr></table></figure>

<p>如果函数调用print()中的字符串很长，可以在合适的位置分行。只需要在每行末尾都加上引号，同时对于除第一行外的其他各行，都在行首加上引号并缩进。这样，Python将自动合并圆括号内的所有字符串，如上第一次的print输出</p>
<p>那么在什么样的情况下使用到列表字典？一般是字典中的键关联了多个值，此时可以直接使用。如：键-topping所对应的值有多个，那么久可以使用键与列表相关联，然后将键的值放入列表中。下面看一个稍微复杂一点点的逻辑代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favorite_languages = &#123; </span><br><span class="line">	&#x27;jen&#x27;: [&#x27;python&#x27;, &#x27;ruby&#x27;], </span><br><span class="line">	&#x27;sarah&#x27;: [&#x27;c&#x27;], </span><br><span class="line">	&#x27;edward&#x27;: [&#x27;ruby&#x27;, &#x27;go&#x27;],</span><br><span class="line">    &#x27;phil&#x27;: [&#x27;python&#x27;, &#x27;haskell&#x27;], </span><br><span class="line">    &#125; </span><br><span class="line">for name, languages in favorite_languages.items():</span><br><span class="line">	print(f&quot;\n&#123;name.title()&#125;&#x27;s favorite languages are:&quot;) </span><br><span class="line">	for language in languages: </span><br><span class="line">		print(f&quot;\t&#123;language.title()&#125;&quot;)</span><br><span class="line">输出：</span><br><span class="line">Jen&#x27;s favorite languages are: </span><br><span class="line">	Python </span><br><span class="line">	Ruby</span><br><span class="line"></span><br><span class="line">Sarah&#x27;s favorite languages are:</span><br><span class="line">	C </span><br><span class="line">	</span><br><span class="line">Edward&#x27;s favorite languages are: </span><br><span class="line">	Ruby </span><br><span class="line">	Go </span><br><span class="line"></span><br><span class="line">Phil&#x27;s favorite languages are: </span><br><span class="line">	Python </span><br><span class="line">	Haskell</span><br></pre></td></tr></table></figure>

<p>在这里可以尝试对上面示例的代码进行优化，使其更加轻量化。思路：可在遍历字典的 for 循环开头添加一条 if 语句，通过查看 len(languages) 的值来确定当前的被调查者喜欢的语言是否有多种。如果他喜欢的语言有多种，就像以前一样显示输出；如果只有一种，就相应修改输出的措辞，如显示 Sarah’s favorite language is C。后期时间来的及的话，我会把在PyCharm上执行的结果更新上。</p>
<p>最后，字典字典就是在字典放在字典中，先小字典，后大字典。但需要注意的是：在字典中嵌套字典，代码可能很快复杂起来，所以一般情况下不建议使用此嵌套，逼不得已最终使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">users = &#123; </span><br><span class="line">	&#x27;aeinstein&#x27;: &#123;</span><br><span class="line">    	&#x27;first&#x27;: &#x27;albert&#x27;, </span><br><span class="line">    	&#x27;last&#x27;: &#x27;einstein&#x27;, </span><br><span class="line">    	&#x27;location&#x27;: &#x27;princeton&#x27;,</span><br><span class="line">    	&#125;,</span><br><span class="line">    </span><br><span class="line">    &#x27;mcurie&#x27;: &#123; </span><br><span class="line">    	&#x27;first&#x27;: &#x27;marie&#x27;,</span><br><span class="line">    	&#x27;last&#x27;: &#x27;curie&#x27;, </span><br><span class="line">    	&#x27;location&#x27;: &#x27;paris&#x27;, </span><br><span class="line">    	&#125;,</span><br><span class="line">    &#125; </span><br><span class="line">for username, user_info in users.items():</span><br><span class="line">	print(f&quot;\nUsername: &#123;username&#125;&quot;) </span><br><span class="line">	full_name = f&quot;&#123;user_info[&#x27;first&#x27;]&#125; &#123;user_info[&#x27;last&#x27;]&#125;&quot; </span><br><span class="line">	location = user_info[&#x27;location&#x27;] </span><br><span class="line">	print(f&quot;\tFull name: &#123;full_name.title()&#125;&quot;) </span><br><span class="line">	print(f&quot;\tLocation: &#123;location.title()&#125;&quot;)</span><br><span class="line">输出：</span><br><span class="line">Username: aeinstein </span><br><span class="line">	Full name: Albert Einstein </span><br><span class="line">	Location: Princeton </span><br><span class="line"></span><br><span class="line">Username: mcurie </span><br><span class="line">	Full name: Marie Curie </span><br><span class="line">	Location: Paris</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（八）</title>
    <url>/2021/03/24/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-HpJxlUsK" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="493458103" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a><strong>遍历字典</strong></h3><p>首先回忆复习一下，遍历列表，使用for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">magicians = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;] </span><br><span class="line">for magician in magicians:</span><br><span class="line">	print(magician)</span><br><span class="line">输出：</span><br><span class="line">alice</span><br><span class="line">david</span><br><span class="line">carolina</span><br></pre></td></tr></table></figure>

<p>对于字典如需进行遍历，同样的也可以使用for循环，但需要注意的是：由于字典存储信息的方式是以键值对记录的，所以在访问后返回时一般情况下，是一个键值对的列表，进而引入一个新的方法.items(  )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user_0 = &#123; &#x27;username&#x27;: &#x27;efermi&#x27;, &#x27;first&#x27;: &#x27;enrico&#x27;, &#x27;last&#x27;: &#x27;fermi&#x27;, &#125;</span><br><span class="line">for key, value in user_0.items():</span><br><span class="line">	print(f&quot;\nKey: &#123;key&#125;&quot;)</span><br><span class="line">	print(f&quot;Value: &#123;value&#125;&quot;)</span><br><span class="line">输出：</span><br><span class="line">Key: username </span><br><span class="line">Value: efermi</span><br><span class="line"></span><br><span class="line">Key: first</span><br><span class="line">Value: enrico</span><br><span class="line"></span><br><span class="line">Key: last</span><br><span class="line">Value: fermi</span><br></pre></td></tr></table></figure>

<p>仔细观察发现：在最后一个键值对后面也加上逗号，起目的是为以后在下一行添加键值对做好准备</p>
<p>与列表不一样的是：在字典中可以单独访问字典中所有的键，引入方法.key(  )；也可以单独访问字典中所有的值，引入方法.value(  )，这里较列表来看，多了一个选择</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favorite_languages = &#123; </span><br><span class="line">	&#x27;jen&#x27;: &#x27;python&#x27;, </span><br><span class="line">	&#x27;sarah&#x27;: &#x27;c&#x27;, </span><br><span class="line">	&#x27;edward&#x27;: &#x27;ruby&#x27;,</span><br><span class="line">    &#x27;phil&#x27;: &#x27;python&#x27;, </span><br><span class="line">    &#125;</span><br><span class="line">for name in favorite_languages.keys():</span><br><span class="line">	print(name.title())</span><br><span class="line">输出：</span><br><span class="line">Jen</span><br><span class="line">Sarah</span><br><span class="line">Edward</span><br><span class="line">Phil</span><br></pre></td></tr></table></figure>

<p>实际上随着接触的Python知识量积累，带来越来越多的玩法，像之前接触过函数sorted(  )，即按照特定顺序排列，也可以穿插在其中使用，提这一嘴是因为：在Python 3.7版本及更高，遍历字典时将按插入的顺序返回其中的元素，但实际是你不可以事先一个个排好，再插入，所以加入这种玩法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favorite_languages = &#123; </span><br><span class="line">	&#x27;jen&#x27;: &#x27;python&#x27;, </span><br><span class="line">	&#x27;sarah&#x27;: &#x27;c&#x27;, </span><br><span class="line">	&#x27;edward&#x27;: &#x27;ruby&#x27;,</span><br><span class="line">    &#x27;phil&#x27;: &#x27;python&#x27;,</span><br><span class="line">    &#125; </span><br><span class="line">for name in sorted(favorite_languages.keys()):</span><br><span class="line">	print(name.title())</span><br><span class="line">输出：</span><br><span class="line">Edward</span><br><span class="line">Jen</span><br><span class="line">Phil</span><br><span class="line">Sarah</span><br></pre></td></tr></table></figure>

<p>以上是对键的一些操作，其实还有更多，这里没有进行细探。接下来对值，进行一些操作玩法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favorite_languages = &#123; </span><br><span class="line">	&#x27;jen&#x27;: &#x27;python&#x27;, </span><br><span class="line">	&#x27;sarah&#x27;: &#x27;c&#x27;, </span><br><span class="line">	&#x27;edward&#x27;: &#x27;ruby&#x27;,</span><br><span class="line">    &#x27;phil&#x27;: &#x27;python&#x27;, </span><br><span class="line">    &#125;</span><br><span class="line">for language in favorite_languages.values():</span><br><span class="line">	print(language.title())</span><br><span class="line">输出：</span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">Ruby</span><br><span class="line">Python</span><br></pre></td></tr></table></figure>

<p>仔细观察发现，输出的值中第一个和第四个都为Python，进行了重复，但喜欢的语言在最终的输出中都会是唯一性的，所以这里要进行去重，引入集合这个新的函数.set(  )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favorite_languages = &#123; </span><br><span class="line">	&#x27;jen&#x27;: &#x27;python&#x27;, </span><br><span class="line">	&#x27;sarah&#x27;: &#x27;c&#x27;, </span><br><span class="line">	&#x27;edward&#x27;: &#x27;ruby&#x27;,</span><br><span class="line">    &#x27;phil&#x27;: &#x27;python&#x27;, </span><br><span class="line">    &#125;</span><br><span class="line">for language in set(favorite_languages.values()):</span><br><span class="line">	print(language.title())</span><br><span class="line">输出：</span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">Ruby</span><br></pre></td></tr></table></figure>

<p>但在阅读一些书籍时，也会看到大括号里只有一些像元素的东西，这里要注意一下的是：此情况可能就不是字典了，而是集合，集合和字典非常相似，都是用大括号括起来的，但一眼望去的区别就是：字典是以键值对的方式存储的，多个键值对是用逗号隔开的，键与值之间使用冒号相关联的，但集合是单一的，所以很像列表中的元素</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（七）</title>
    <url>/2021/03/23/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-emodilck" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1403435714" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a><strong>字典</strong></h3><p>在Python中，字典是另一种可变容器模型，且可存储任意类型对象。字典是一系列键值对，每个键都与一个值相关联，可使用键来访问相关联的值。与键相关联的值可以是数、字符串、列表乃至字典，字典的每个键值对用冒号分割，每个键值对之间用逗号分割，整个字典包括在一对大括号{  }中 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alien_0 = &#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;</span><br><span class="line">print(alien_0[&#x27;color&#x27;])</span><br><span class="line">print(alien_0[&#x27;points&#x27;])</span><br><span class="line">输出：</span><br><span class="line">green </span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>那么对于列表来讲，想要访问里面的元素，可以根据元素的索引位置，进行访问。但由于在字典中谈不上什么索引的概念，所以想要访问的话，可以通过与值关联的键来进行访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alien_0 = &#123;&#x27;color&#x27;: &#x27;green&#x27;&#125;</span><br><span class="line">print(alien_0[&#x27;color&#x27;])</span><br><span class="line">输出：green</span><br></pre></td></tr></table></figure>

<p>但在实际应用过程中，字典里的键值对随时会增加或者减少，这就需要随时能够对其进行操作，一般操作包括：增加，修改，删除。</p>
<p>增加：变量后+[‘键’] &#x3D; 数值或者’字符串’，这里稍微注意下的是：在Python 3.7版本及更高版本的字典中，键值对的排序与添加的顺序直接关联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##增加</span><br><span class="line">alien_0 = &#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;</span><br><span class="line">alien_0[&#x27;x_position&#x27;] = 0</span><br><span class="line">alien_0[&#x27;y_position&#x27;] = 25</span><br><span class="line">print(alien_0)</span><br><span class="line">输出：&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5, &#x27;y_position&#x27;: 25, &#x27;x_position&#x27;: 0</span><br></pre></td></tr></table></figure>

<p>之前接触的列表，在开始使用时，是可以创建一个空列表的。同理，字典在使用前也是可以创建一个空字典的，后期也可以不断的向里面已添加键值对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alien_0 = &#123;&#125;</span><br><span class="line">alien_0[&#x27;color&#x27;] = &#x27;green&#x27;</span><br><span class="line">alien_0[&#x27;points&#x27;] = 5</span><br><span class="line">print(alien_0)</span><br><span class="line">输出：&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;</span><br></pre></td></tr></table></figure>

<p>修改：遵循与增加相同的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alien_0 = &#123;&#x27;color&#x27;: &#x27;green&#x27;&#125;</span><br><span class="line">alien_0[&#x27;color&#x27;] = &#x27;yellow&#x27;</span><br><span class="line">print(alien_0)</span><br><span class="line">输出：alien_0 = &#123;&#x27;color&#x27;: &#x27;yellow&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>删除：在列表中的删除，有一种删除方式是：使用del删除列表中的某个元素，格式是：del+变量[元素索引号]，并且这里的删除是永久性的，后续被删除的元素是不可以再次被访问的</p>
<p>同样的，在字典中的删除，也可以使用del去实现，格式和列表中删除元素很相似，只不过将其中的元素索引号换成字典中的键，仅此而已，删除后的键值对也是无法再次被访问的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alien_0 = &#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;</span><br><span class="line">del alien_0[&#x27;points&#x27;]</span><br><span class="line">print(alien_0)</span><br><span class="line">输出：&#123;&#x27;color&#x27;: &#x27;green&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>那么假设访问字典中某个不存在的键值对时，这是一种特使情况，就需要做相对应的处理，如果不处理，运行时将直接报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alien_0 = &#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;speed&#x27;: &#x27;slow&#x27;&#125;</span><br><span class="line">print(alien_0[&#x27;points&#x27;])</span><br><span class="line">报错输出：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;alien_no_points.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    print(alien_0[&#x27;points&#x27;])</span><br><span class="line">KeyError: &#x27;points&#x27;</span><br></pre></td></tr></table></figure>

<p>如何处理？这里引入新的方法.get(  )</p>
<p>方法.get(  )的使用是需要指定两个参数，一个是必要参数，一个是非必要参数。第一个必要参数是：键，即访问字典中不存在的键；第二个非必要参数是：返回的值，即访问字典中的键不存在时，需要返回什么的信息（值）给使用者。如果不指定第二个的非必要参数，那么返回时，Python直接返回的是None。</p>
<p>方法.get(  )的逻辑是：如果字典中存在访问的键，那就将反馈与之相关联的值；如果不存在，那就反馈指定的默认值，即上面所提到的第二个非必要参数，如果不指定这个第二个非必要的参数，Python将返回None，并且这里的None并非错误，而是一个表示所需值不存在的特殊值。</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（六）</title>
    <url>/2021/03/22/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-MESIHxaO" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1817295062" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="if语句结构"><a href="#if语句结构" class="headerlink" title="if语句结构"></a><strong>if语句结构</strong></h3><p>对于if语句结构，有以下几种情况，不过不管是哪种结构，在使用的过程中都应当注意条件测试和执行程序的格式，尤其是缩进</p>
<p>首先最简单的就是，一个条件测试，一个操作，不过个人喜欢把操作称为执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##仅为示范</span><br><span class="line">if conditional_test:</span><br><span class="line">	do something</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age = 19</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">	print(&quot;You are old enough to vote!&quot;)</span><br><span class="line">输出：You are old enough to vote!</span><br></pre></td></tr></table></figure>

<p>此处缩进的作用与在for循环中相同，如果测试通过了，将执行if语句后面所有缩进的代码行，否则将忽略它们</p>
<p>其次if语句结构，在英语中经常接触到，就是if……else……，此结构一般运用在条件测试通过时执行一个操作，在没有通过时执行另一个操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age = 17</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">	print(&quot;You are old enough to vote!&quot;)</span><br><span class="line">	print(&quot;Have you registered to vote yet?&quot;)</span><br><span class="line">else:</span><br><span class="line">	print(&quot;Sorry, you are too young to vote.&quot;)</span><br><span class="line">	print(&quot;Please register to vote as soon as you turn 18!&quot;)</span><br><span class="line">输出：</span><br><span class="line">Sorry, you are too young to vote.</span><br><span class="line">Please register to vote as soon as you turn 18!</span><br></pre></td></tr></table></figure>

<p>另外，在常见的if语句结构中还会看到：if……elif……else，这种结构。它的意思是：依次检查每个条件测试，直到遇到通过了的条件测试。测试通过后，Python将执行紧跟在它后面的代码，并跳过余下的测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age = 12</span><br><span class="line">if age &lt; 4:</span><br><span class="line">	print(&quot;Your admission cost is $0.&quot;)</span><br><span class="line">elif age &lt; 18:</span><br><span class="line">	print(&quot;Your admission cost is $25.&quot;)</span><br><span class="line">else:</span><br><span class="line">	print(&quot;Your admission cost is $40.&quot;)</span><br><span class="line">输出：Your admission cost is $25.</span><br></pre></td></tr></table></figure>

<p>为使代码更加简单轻量化，对原代码进行优化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age = 12</span><br><span class="line">if age &lt; 4: </span><br><span class="line">	price = 0 </span><br><span class="line">elif age &lt; 18:</span><br><span class="line">	price = 25 </span><br><span class="line">else:</span><br><span class="line">	price = 40</span><br><span class="line">print(f&quot;Your admission cost is $&#123;price&#125;.&quot;)</span><br><span class="line">输出：Your admission cost is $25.</span><br></pre></td></tr></table></figure>

<p>这里需要插一句嘴的是：elif代码块并不是只能有一个，它是可以有多个穿插在if和else中间的，但带来的缺点就是：臃肿</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age = 12</span><br><span class="line">if age &lt; 4:</span><br><span class="line">	price = 0</span><br><span class="line">elif age &lt; 18:</span><br><span class="line">	price = 25</span><br><span class="line">elif age &lt; 65:</span><br><span class="line">	price = 40</span><br><span class="line">else:</span><br><span class="line">	price = 20</span><br><span class="line">print(f&quot;Your admission cost is $&#123;price&#125;.&quot;)</span><br><span class="line">输出：Your admission cost is $25.</span><br></pre></td></tr></table></figure>

<p>与此同时，既然elif代码可以有多个，那么else代码块也可以省略。在Python中并不要求if-elif结构后面必须有else代码块，在有些情况下，else代码块很有用，而在其他一些情况下，使用一条elif语句来处理特定的情形更清晰</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age = 12</span><br><span class="line">if age &lt; 4:</span><br><span class="line">	price = 0</span><br><span class="line">elif age &lt; 18:</span><br><span class="line">	price = 25</span><br><span class="line">elif age &lt; 65:</span><br><span class="line">	price = 40</span><br><span class="line">elif age &gt;= 65:</span><br><span class="line">	price = 20</span><br><span class="line">print(f&quot;Your admission cost is $&#123;price&#125;.&quot;)</span><br><span class="line">输出：Your admission cost is $25.</span><br></pre></td></tr></table></figure>

<p>总之，如果只想执行一个代码块，就使用if……elif……else结构；如果要 执行多个代码块，就使用一系列独立的if语句</p>
<p>当遇到需要if语句去处理列表时，也可以结合之前的遍历这一块的内容，也就是使用for去进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requested_toppings = [&#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;]</span><br><span class="line">for requested_topping in requested_toppings:</span><br><span class="line">	if requested_topping == &#x27;green peppers&#x27;:</span><br><span class="line">		print(&quot;Sorry, we are out of green peppers right now.&quot;)</span><br><span class="line">	else:</span><br><span class="line">		print(f&quot;Adding &#123;requested_topping&#125;.&quot;)</span><br><span class="line">print(&quot;\nFinished making your pizza!&quot;)</span><br><span class="line">输出：</span><br><span class="line">Adding mushrooms.</span><br><span class="line">Sorry, we are out of green peppers right now.</span><br><span class="line">Adding extra cheese.</span><br><span class="line"></span><br><span class="line">Finished making your pizza!</span><br></pre></td></tr></table></figure>

<p>但是也有可能会遇到一种个特殊的情况，就是：列表为空这种情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requested_toppings = []</span><br><span class="line">if requested_toppings:</span><br><span class="line">	for requested_topping in requested_toppings:</span><br><span class="line">		print(f&quot;Adding &#123;requested_topping&#125;.&quot;)</span><br><span class="line">	print(&quot;\nFinished making your pizza!&quot;)</span><br><span class="line">else:</span><br><span class="line">	print(&quot;Are you sure you want a plain pizza?&quot;)</span><br><span class="line">输出：Are you sure you want a plain pizza?</span><br></pre></td></tr></table></figure>

<p>同样的，还有一种情况就是，对多个列表进行处理时，又将如何去进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">available_toppings = [&#x27;mushrooms&#x27;, &#x27;olives&#x27;, &#x27;green peppers&#x27;, &#x27;pepperoni&#x27;, &#x27;pineapple&#x27;, &#x27;extra cheese&#x27;]</span><br><span class="line">requested_toppings = [&#x27;mushrooms&#x27;, &#x27;french fries&#x27;, &#x27;extra cheese&#x27;]</span><br><span class="line"></span><br><span class="line">for requested_topping in requested_toppings:</span><br><span class="line">	if requested_topping in available_toppings:</span><br><span class="line">		print(f&quot;Adding &#123;requested_topping&#125;.&quot;)</span><br><span class="line">	else:</span><br><span class="line">		print(f&quot;Sorry, we don&#x27;t have &#123;requested_topping&#125;.&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;\nFinished making your pizza!&quot;)</span><br><span class="line">输出：</span><br><span class="line">Adding mushrooms.</span><br><span class="line">Sorry, we don&#x27;t have french fries.</span><br><span class="line">Adding extra cheese.</span><br><span class="line"></span><br><span class="line">Finished making your pizza!</span><br></pre></td></tr></table></figure>

<p>以上所有使用到for进行遍历和if语句结构的，都要仔细检查最后面的冒号，冒号，冒号！！！</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（五）</title>
    <url>/2021/03/21/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-NAifArLS" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1814136516" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><strong>if语句</strong></h3><p>其实if语句在循环中算是一个比较重要的体系，直白点讲，就是如果满足一个怎样的条件，那么我就执行什么程序，要不然的话就执行什么程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cars = [&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span><br><span class="line">for car in cars:</span><br><span class="line">	if car == &#x27;bmw&#x27;:</span><br><span class="line">		print(car.upper())</span><br><span class="line">	else:</span><br><span class="line">		print(car.title())</span><br><span class="line">输出：</span><br><span class="line">Audi</span><br><span class="line">BMW</span><br><span class="line">Subaru</span><br><span class="line">Toyota</span><br></pre></td></tr></table></figure>

<p>其实每条if语句的核心都是一个值为True或False的表达式，这种表达式称为条件测试。Python根据条件测试的值为True还是False来决定是否执行if语句中的代码。如果条件测试的值True，Python就执行紧跟在if语句后面的代码；如果为False，Python就忽略这些代码。</p>
<p>大多数条件测试将一个变量的当前值同特定值进行比较，最简单的条件测试检查变量的值是否与特定值相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">car = &#x27;audi&#x27;</span><br><span class="line">car == &#x27;bmw&#x27;</span><br><span class="line">输出：False</span><br></pre></td></tr></table></figure>

<p>在Python中检查是否相等时，区分字母大小写是值得被关注的，一般来说都会将变量的值转换为小写的，然后再进行比较。这里值得注意的，即便这里进行了方法.lower(  )的转换，但原始变量的值，是不会变的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">car = &#x27;Audi&#x27;</span><br><span class="line">car.lower() == &#x27;audi&#x27;</span><br><span class="line">输出：True</span><br></pre></td></tr></table></figure>

<p>如果要判断两个值是否不等，可结合使用惊叹号和等号（!&#x3D;），其中的惊叹号表示不</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requested_topping = &#x27;mushrooms&#x27;</span><br><span class="line">if requested_topping != &#x27;anchovies&#x27;:</span><br><span class="line">	print(&quot;Hold the anchovies!&quot;)</span><br><span class="line">输出：Hold the anchovies!</span><br></pre></td></tr></table></figure>

<p>以上接触的是对字符串中含有字母的一些示例，接下来将会接触到带有一些数值的示例，检查数值是否相等或者不相等，非常简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age = 18</span><br><span class="line">age == 18</span><br><span class="line">输出：True</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">answer = 17</span><br><span class="line">if answer != 42:</span><br><span class="line">	print(&quot;That is not the correct answer. Please try again!&quot;)</span><br><span class="line">输出：That is not the correct answer. Please try again!</span><br></pre></td></tr></table></figure>

<p>同时在条件语句中可包含各种数学比较，如小于、小于等于、大于、大于等于</p>
<p>以上不管是带字母的还是带数值的，都接触的是单一的检查条件，但往往实际情况是有多个检查条件，所以接下来就会使用到一些关键字and和or</p>
<p>and，表示且的关系，也就是说只有在检查条件都满足的情况下，执行程序</p>
<p>or，表示或的关系，也就是说检查条件只要满足其中的一个，就执行某段程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age_0 = 22</span><br><span class="line">age_1 = 18</span><br><span class="line"></span><br><span class="line">age_0 &gt;= 21 and age_1 &gt;= 21</span><br><span class="line">输出：False</span><br><span class="line"></span><br><span class="line">age_0 &gt;= 21 or age_1 &gt;= 21</span><br><span class="line">输出：True</span><br><span class="line">age_0 &gt;= 24 or age_1 &gt;= 17</span><br><span class="line">输出：True</span><br><span class="line">##一般建议是：不管and还是or，表达式都加上括号，增强代码的阅读性</span><br></pre></td></tr></table></figure>

<p>当然，有些时候也会碰到像检查特定值是否在或者不在某个列表中的情况，这时通常会用到in和not in这两个关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requested_toppings = [&#x27;mushrooms&#x27;, &#x27;onions&#x27;, &#x27;pineapple&#x27;]</span><br><span class="line">mushrooms&#x27; in requested_toppings</span><br><span class="line">输出：True</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">banned_users = [&#x27;andrew&#x27;, &#x27;carolina&#x27;, &#x27;david&#x27;]</span><br><span class="line">user = &#x27;marie&#x27;</span><br><span class="line">if user not in banned_users:</span><br><span class="line">	print(f&quot;&#123;user.title()&#125;, you can post a response if you wish.&quot;)</span><br><span class="line">输出：Marie, you can post a response if you wish.</span><br></pre></td></tr></table></figure>

<p>这里简单带一个概念就是：布尔表达式，其结果就只有两个，要么True，要么False</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（四）</title>
    <url>/2021/03/20/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-YOHVUHfh" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1365898499" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a><strong>元组</strong></h3><p>在未接触元组之前，一直接触的是列表，列表是可以修改的，但是元组是不可以修改的，在Python中将不能修改的值称为不可变的，而不可变的列表被称为元组。</p>
<p>元组看起来很像列表，但使用圆括号而非中括号来标识。定义元组后，就可使用索引来访问其元素，就像访问列表元素一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dimensions = (200, 50) </span><br><span class="line">print(dimensions[0]) </span><br><span class="line">print(dimensions[1])</span><br><span class="line">输出：</span><br><span class="line">200</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<p>假设去做一个尝试，去修改元组中某个元素的值，Python是会报错的，实际是不可取的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#仅为实验尝试，实际不可取，不可取，不可取</span><br><span class="line">dimensions = (200, 50)</span><br><span class="line">dimensions[0] = 250</span><br><span class="line">错误信息：</span><br><span class="line">Traceback (most recent call last): </span><br><span class="line">  File &quot;dimensions.py&quot;, line 2, in &lt;module&gt; </span><br><span class="line">    dimensions[0] = 250 </span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure>

<p>严格地说，元组是由逗号标识的，圆括号只是让元组看起来更整洁、更清晰。如果你要定义只包含一个元素的元组，必须在这个元素后面加上逗号。创建只包含一个元素的元组通常没有意义，但自动生成的元组有可能只有一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_t = (3,)</span><br></pre></td></tr></table></figure>

<p>像列表一样，也可以使用for循环来遍历元组中的所有值，就像遍历列表时一样，Python返回元组中所有的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dimensions = (200, 50)</span><br><span class="line">for dimension in dimensions:</span><br><span class="line">	print(dimension)</span><br><span class="line">输出：</span><br><span class="line">200</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<p>虽然不能修改元组的元素，但可以重新给存储元组的变量赋值，相比于列表，元组是更简单的数据结构，如果需要存储的一组值在程序的整个生命周期内都不变，就可以使用元组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dimensions = (200, 50)</span><br><span class="line">print(&quot;Original dimensions:&quot;) </span><br><span class="line">for dimension in dimensions:</span><br><span class="line">	print(dimension)</span><br><span class="line">	</span><br><span class="line">dimensions = (400, 100)</span><br><span class="line">print(&quot;\nModified dimensions:&quot;)</span><br><span class="line">for dimension in dimensions:</span><br><span class="line">	print(dimension)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Original dimensions:</span><br><span class="line">200</span><br><span class="line">50</span><br><span class="line"></span><br><span class="line">Modified dimensions:</span><br><span class="line">400</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（三）</title>
    <url>/2021/03/19/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-PspJOkLj" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1392600538" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a><strong>切片</strong></h3><p>之前接触的都是对列表中的单个元素进行操作，但有时也会对列表中的部分元素进行操作，此时有项技术专门这一块的应运，称作“切片”</p>
<p>要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range(  )一样，Python在到达第二个索引之前的元素后停止。要输出列表中的前三个元素，需要指定索引0和3，这将返回索引为0、1和2的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]</span><br><span class="line">print(players[0:3])</span><br><span class="line">输出：[&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;]</span><br></pre></td></tr></table></figure>

<p>假设不指定前索引位置，那么默认是从列表中的第0索引位开始，同样道理，不指定后索引位置，那么默认是从列表中的最后一个索引位结束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;] </span><br><span class="line">print(players[:4])</span><br><span class="line">输出：[&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;] </span><br><span class="line">print(players[2:])</span><br><span class="line">输出：[&#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]</span><br></pre></td></tr></table></figure>

<p>在之前对列表中单一元素进行访问，可以使用负索引，在这里也同样适用，负索引返回离列表末尾相应距离的元素，因此可以输出列表末尾的任意切片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;] </span><br><span class="line">print(players[-3:])</span><br><span class="line">输出：[&#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]</span><br></pre></td></tr></table></figure>

<p>在前面操作访问列表中的单一元素时，接触到遍历这样的一个概念，同样的在这里也会涉及到，因为都是列表中的元素，只不过这里部分元素添加了索引位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]</span><br><span class="line">for player in players[:3]:</span><br><span class="line">	print(player.title())</span><br><span class="line">输出：</span><br><span class="line">Charles </span><br><span class="line">Martina </span><br><span class="line">Michael</span><br></pre></td></tr></table></figure>

<p>与此同时，为方便快速创建相同列表，我们也常常复制现有的列表，在Python中，我们把复制后的新列表，称作为原列表的副本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_foods = [&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;]</span><br><span class="line">friend_foods = my_foods[:]</span><br><span class="line">print(friend_foods)</span><br><span class="line">输出：[&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;]</span><br></pre></td></tr></table></figure>

<p>很多情况下，手忙脚乱，不注意细节时，会将原列表直接赋给新列表，此方法是不可行的，下面是一段错误的演示，请务必注意，是错误的，不可采取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_foods = [&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;]</span><br><span class="line"></span><br><span class="line"># 以下是不可取的，不可取，不可取</span><br><span class="line">friend_foods = my_foods</span><br><span class="line">my_foods.append(&#x27;cannoli&#x27;) </span><br><span class="line">friend_foods.append(&#x27;ice cream&#x27;)</span><br><span class="line">print(my_foods)</span><br><span class="line">print(friend_foods)</span><br><span class="line">输出：</span><br><span class="line">[&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;, &#x27;cannoli&#x27;, &#x27;ice cream&#x27;]</span><br><span class="line">[&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;, &#x27;cannoli&#x27;, &#x27;ice cream&#x27;]</span><br></pre></td></tr></table></figure>

<p>这里将my_foods赋给friend_foods，而不是将my_foods的副本赋给friend_foods。这种语法实际上是让Python将新变量friend_foods关联到已与my_foods相关联的列表，因此这两个变量指向同一个列表。有鉴于此，当我们将’cannoli’添加到my_foods中时，它也将出现在friend_foods中。同样，虽然’ice cream’好像只被加入到了friend_foods中，但它也将出现在这两个列表中。输出表明，两个列表是相同的，这并非我们想要的结果。</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（二）</title>
    <url>/2021/03/18/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-OVIANGHU" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1407238316" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、列表的排序"><a href="#一、列表的排序" class="headerlink" title="一、列表的排序"></a><strong>一、列表的排序</strong></h3><p>对列表中的元素进行排序，如果想永久性排序，无法恢复到原先的序列的话，可以使用方法.sort( )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;] </span><br><span class="line">cars.sort() </span><br><span class="line">print(cars)</span><br><span class="line">输出：[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span><br></pre></td></tr></table></figure>

<p>上面 正的排序，也可以进行反的排序，只要在括号中，传递参数reverse &#x3D; True 即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;] </span><br><span class="line">cars.sort(reverse=True) </span><br><span class="line">print(cars)</span><br><span class="line">输出：[&#x27;toyota&#x27;, &#x27;subaru&#x27;, &#x27;bmw&#x27;, &#x27;audi&#x27;]</span><br></pre></td></tr></table></figure>

<p>如果需要对列表进行临时性的排序，也可以使用函数sorted( )，此函数不会影响元素原先在列表中的排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;] </span><br><span class="line">print(sorted(cars))</span><br><span class="line">输出：[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span><br></pre></td></tr></table></figure>

<p>同样的，上面是正的排序，也可以进行反的排序，括号中传递参数reverse &#x3D; True 即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">want_place = [&#x27;masaladi&#x27;,&#x27;hanbougo&#x27;,&#x27;adruse&#x27;,&#x27;youhu&#x27;]</span><br><span class="line">print(sorted(want_place,reverse = True))</span><br><span class="line">输出：[&#x27;youhu&#x27;, &#x27;masaladi&#x27;, &#x27;hanbougo&#x27;, &#x27;adruse&#x27;]</span><br></pre></td></tr></table></figure>

<p>如果仅仅想让列表中的元素倒过来排序，可以使用方法.reverse( )去实现，此方法对列表的排序也是永久的，但不过好处是双次使用后，即可恢复到原先的元素排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]</span><br><span class="line">cars.reverse()</span><br><span class="line">print(cars)</span><br><span class="line">输出：[&#x27;subaru&#x27;, &#x27;toyota&#x27;, &#x27;audi&#x27;, &#x27;bmw&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="二、数值列表"><a href="#二、数值列表" class="headerlink" title="二、数值列表"></a><strong>二、数值列表</strong></h3><p>有时我们需要快速的去造数，可以使用函数rang(  )去实现，但需要注意的是：括号中的区间和索引一样都是包头不包尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for value in range(1, 5):</span><br><span class="line">	print(value)</span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>这只是我们输出出来的数，如果要将这些数，放入一个列表中，需要使用到函数list(  )去进行转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">numbers = list(range(1, 6)) </span><br><span class="line">print(numbers)</span><br><span class="line">输出：[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<p>有时看到一些资料中，还会在括号中加入第三个数，我们把这第三个数，称作为步长，通俗一点讲，就是两个相邻的数，中间间隔几，这个几就是步长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">even_numbers = list(range(2, 11, 2)) </span><br><span class="line">print(even_numbers)</span><br><span class="line">输出：[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure>

<p>当需要将数成次方倍的翻时，常用两个 ** 去实现，以2次方举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">squares = []</span><br><span class="line">for value in range(1, 11):</span><br><span class="line">	square = value ** 2</span><br><span class="line">	squares.append(square)</span><br><span class="line">print(squares)</span><br><span class="line">输出：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>

<p>为使得代码简洁化，后期熟练时可直接省去中间新变量square</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">squares = [] </span><br><span class="line">	for value in range(1,11):</span><br><span class="line">	squares.append(value**2) </span><br><span class="line">print(squares)</span><br><span class="line">输出：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>

<p>同时在Python中，有几个专门用于处理数字列表的Python函数。例如，你可以轻松地找出数字列表的最大值、最小值和总和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span><br><span class="line">min(digits)</span><br><span class="line">max(digits)</span><br><span class="line">sum(digits)</span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line">9</span><br><span class="line">45</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后期在阅读别人代码时，可能会遇到列表解析，这里简单提一嘴，要使用这种语法，首先指定一个描述性的列表名，如squares。然后，指定一个左方括号，并定义一个表达式，用于生成要存储到列表中的值。在这个示例中，表达式为value**2，它计算平方值。接下来，编 写一个for循环，用于给表达式提供值，再加上右方括号，需要注意的是：这里的for后面时候没有冒号的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">squares = [value**2 for value in range(1, 11)] </span><br><span class="line">print(squares)</span><br><span class="line">输出：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践（第二版）》自学笔记（一）</title>
    <url>/2021/03/02/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-jiHuHnse" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1813864802" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、搞清楚变量和字符串及字符串大小写的一些方法"><a href="#一、搞清楚变量和字符串及字符串大小写的一些方法" class="headerlink" title="一、搞清楚变量和字符串及字符串大小写的一些方法"></a><strong>一、搞清楚变量和字符串及字符串大小写的一些方法</strong></h3><p>变量一般位于代码前半部分，像学生姓名，学科，成绩……默认的话用英文去阐述</p>
<p>字符串一般都在单引号或双引号里面，常位于代码后半部分，比如定义一个变量：name，叫什么，叫Carrol，那简单点就是：name &#x3D; “Carrol”，完事</p>
<p>首先，什么是方法，方法是Python可对数据执行的操作。字符串的首字母大写，使用到的方法是：.title( )，假设有一个变量并赋值：name &#x3D; carrol chen，当使用方法.title( )后，即：print(name.title( ))，响应框的输出是：Carrol Chen，在name.title( )中，name后面的句点（.）让Python对变量name执行方法title()指定的操作。每个方法后面都跟着一对圆括号，这是因为方法通常需要额外的信息来完成其工作。这种信息是在圆括号内提供的，函数title( )不需要额外的信息，因此它后面的圆括号是空的。同理字符串全大写或者全小写，使用到的方法分别是：.upper( )和.lower( )。</p>
<p>当字符串有时需要用到某些变量的值时，会采用f字符串，有时还会用到换行，空格，准确讲是叫制表符，换行是：\n；空格是：\t。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first_name = &quot;ada&quot; </span><br><span class="line">last_name = &quot;lovelace&quot; </span><br><span class="line">full_name = f&quot;&#123;first_name&#125; &#123;last_name&#125;&quot; </span><br><span class="line">print(f&quot;Hello, &#123;full_name.title()&#125;!&quot;)</span><br></pre></td></tr></table></figure>

<p>有时候字符串会含有空格，通俗一点讲就是单引号或者双引号里面有空格，此时可以用方法：.strip( )去除，不管空格是在左还是在右，如果明确是要去左边的话，可以用方法：.lstrip( )；要去右边的话，可以用方法：.rstrip( )</p>
<p>最后在变量和简单的数据类型这里，提一个小细节是：常量在命名定义时，全部使用大写字母去定义</p>
<h3 id="二、列表的增、删、改"><a href="#二、列表的增、删、改" class="headerlink" title="二、列表的增、删、改"></a><strong>二、列表的增、删、改</strong></h3><p>Python中列表是用[ ]来表示的，就是一对方括号，里面放的一些东西，我们叫元素，用单引号表示，并用逗号隔开。列表可以为空，里面的元素，从左往右的索引依次是0、1、2、3…….，索引是从0开始的</p>
<p>增：末尾增加，使用到的方法是：.append( )，其中括号中需要加入具体的元素值；插入某个元素进列表中，使用的方法是：.insert( )，在这里需要两个额外的信息，此方法才可执行，一是需要插入的元素，需要放在列表中的那个位置，即索引是哪里，二是具体的元素，中间用逗号隔开。比方说：已有一个列表：name，那在首位插入一个’Carrol‘的名字，可以：name.insert(0,’Carrol’)</p>
<p>删：如果是知道元素在列表中的索引位置，那可以直接使用del语句，但del语句将元素（值）从列表中删除后，就无法再访问了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span><br><span class="line">del motorcycles[0] </span><br><span class="line">print(motorcycles)</span><br><span class="line">输出：[&#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span><br></pre></td></tr></table></figure>

<p>如果想继续使用列表中被删除的元素（值），可以使用方法.pop( )，需要注意的是，括号中不输入索引号，此方法默认删除列表中最后一个索引位置的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span><br><span class="line">popped_motorcycle = motorcycles.pop() </span><br><span class="line">print(motorcycles) </span><br><span class="line">print(popped_motorcycle)</span><br><span class="line">输出：[&#x27;honda&#x27;, &#x27;yamaha&#x27;] </span><br><span class="line">	  suzuki</span><br></pre></td></tr></table></figure>

<p>如果括号中指定索引位置，就删除索引位置的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span><br><span class="line">first_owned = motorcycles.pop(0)</span><br><span class="line">print(f&quot;The first motorcycle I owned was a &#123;first_owned.title()&#125;.&quot;)</span><br></pre></td></tr></table></figure>

<p>如果有时候只知道元素的值，却不知道元素所在的索引号，此时可以使用方法.remove( )，同样的，删除之后还可以继续使用该元素，但需要注意的是此方法只删除第一个指定的值，如果要删除的值可能在列表中出现多次，就需要使用循环来确保将每个值都删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]</span><br><span class="line">too_expensive = &#x27;ducati&#x27;</span><br><span class="line">motorcycles.remove(too_expensive)</span><br><span class="line">print(motorcycles)</span><br><span class="line">print(f&quot;\nA &#123;too_expensive.title()&#125; is too expensive for me.&quot;)</span><br></pre></td></tr></table></figure>

<p>改：在列表中，是可以对某个索引位置的元素（值）进行修改的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span><br><span class="line">motorcycles[0] = &#x27;ducati&#x27;</span><br><span class="line">print(motorcycles)</span><br><span class="line">输出：[&#x27;ducati&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>保姆级教你搭建个人工作站服务器</title>
    <url>/2021/02/05/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%B7%A5%E4%BD%9C%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-iroeXWuC" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="405467805" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、宿主系统的选择和配置"><a href="#一、宿主系统的选择和配置" class="headerlink" title="一、宿主系统的选择和配置"></a><strong>一、宿主系统的选择和配置</strong></h3><p>目前接触到主流Linux系统，分别是CentOS和Ubuntu，以后者作为示范例。</p>
<p>宿主机安装好Ubuntu系统后，打开Ubuntu终端命令行，执行下列命令行进行相关设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.设置root密码</span><br><span class="line">sudo passwd root</span><br><span class="line"></span><br><span class="line">#2.为避免每次都要输入密码，配置一下visudo</span><br><span class="line">sudo visudo</span><br><span class="line"></span><br><span class="line">#3.在文件最后添加一下代码，这里的Carrol改为自己的用户名</span><br><span class="line">Carrol ALL=(ALL) NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line">#4.对软件源文件进行备份</span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"></span><br><span class="line">#5.软件源更换为阿里源</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">#6.在原有的软件源链接前面全部加上#，进行注释，添加下列阿里源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#7.对软件列表进行更新</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>

<h3 id="二、安装Python3和Pip及设置"><a href="#二、安装Python3和Pip及设置" class="headerlink" title="二、安装Python3和Pip及设置"></a><strong>二、安装Python3和Pip及设置</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.安装Python3和Pip</span><br><span class="line">sudo apt install python3</span><br><span class="line">sudo apt install python3-pip</span><br><span class="line"></span><br><span class="line">#2.Pip源更新为清华源</span><br><span class="line">cd ~</span><br><span class="line">mkdir .pip</span><br><span class="line">sudo vim ~/.pip/pip.conf</span><br><span class="line"></span><br><span class="line">#3.配置文件进行设置</span><br><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple/ </span><br><span class="line">[install]</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br><span class="line"></span><br><span class="line">#4.检查终端命令行输入Python是否为Python3版本，不是则删除原有软链接，创建新软链接</span><br><span class="line">sudo rm /usr/bin/python</span><br><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python</span><br><span class="line">sudo ln -s /usr/bin/pip3 /usr/bin/pip</span><br></pre></td></tr></table></figure>

<h3 id="三、远程连接配置"><a href="#三、远程连接配置" class="headerlink" title="三、远程连接配置"></a><strong>三、远程连接配置</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.安装SSH并开启服务</span><br><span class="line">sudo apt install ssh</span><br><span class="line"></span><br><span class="line">#2.Windows远程连接，建议安装Xrdp，安装后自行启动</span><br><span class="line">sudo apt install xrdp </span><br><span class="line"></span><br><span class="line">#3.验证Xrdp是否自启动</span><br><span class="line">sudo systemctl status xrdp</span><br><span class="line"></span><br><span class="line">#4.由于默认情况下，xrdp 使用/etc/ssl/private/ssl-cert-snakeoil.key，它仅仅对ssl-cert用户组成语可读，所以需要运行下面的命令，将xrdp用户添加到这个用户组</span><br><span class="line">sudo adduser xrdp ssl-cert  </span><br><span class="line">sudo systemctl restart xrdp</span><br></pre></td></tr></table></figure>

<h3 id="四、安装FRP内网穿透及配置"><a href="#四、安装FRP内网穿透及配置" class="headerlink" title="四、安装FRP内网穿透及配置"></a><strong>四、安装FRP内网穿透及配置</strong></h3><p>FRP分为FRPS（Server）和FRPC（Client）两个包 ，其中前者安装到我们的云服务器上，后者安装在需要被外网访问到的各个设备上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.下载好服务端FRP的压缩包，并解压</span><br><span class="line">tar -zxvf 包名</span><br><span class="line"></span><br><span class="line">#2.配置frps.ini文件</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000 				# frp服务的端口号，可以自己定</span><br><span class="line">dashboard_port = 7500			# frp的web界面的端口号</span><br><span class="line">dashboard_user = Carrol			# web界面的登陆账户，自己修改</span><br><span class="line">dashboard_pwd = admin			# web界面的登陆密码，自己修改</span><br><span class="line">authentication_method = token</span><br><span class="line">token = admin 					# frp客户端连接时的密码，自己修改</span><br><span class="line"></span><br><span class="line">#3.保存配置并启动</span><br><span class="line">./frps -c ./frps.ini</span><br><span class="line"></span><br><span class="line">#4.下载好客户端FRP的压缩包，并解压</span><br><span class="line">tar -zxvf 包名</span><br><span class="line"></span><br><span class="line">#5.配置frps.ini文件</span><br><span class="line">[common]</span><br><span class="line">server_addr = xx.xx.xx.xx 		# 云服务器的公网IP</span><br><span class="line">authentication_method = token</span><br><span class="line">token = admin					# 服务端配置的frp连接密码 </span><br><span class="line">server_port = 7000 				# 服务端配置的frp服务端口</span><br><span class="line"> </span><br><span class="line">#6.公网IP服务端口重定向,假如我用SSH客户端访问公网的20022端口，就可以经过反向代理直接访问到本地的22端口；同理需要连接远程桌面的话，只需要访问公网的23389端口就可以</span><br><span class="line">[Fusion-ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 20022</span><br><span class="line">​</span><br><span class="line">[Fusion-rdp]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 23389</span><br><span class="line"> </span><br><span class="line">#7.添加开机自启动脚本，并配置相关内容</span><br><span class="line">sudo vim /etc/systemd/system/frpc.service</span><br><span class="line">[Fusion]</span><br><span class="line">Description=Frp Server Daemon</span><br><span class="line">After=syslog.target network.target</span><br><span class="line">Wants=network.target</span><br><span class="line">​</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/bin/frp/frpc -c /usr/local/bin/frp/frpc.ini	#修改为frp实际安装目录</span><br><span class="line">ExecStop=/usr/bin/killall frpc</span><br><span class="line">RestartSec=1min					#启动失败1分钟后再次启动</span><br><span class="line">KillMode=control-group</span><br><span class="line">Restart=always					#重启控制：总是重启</span><br><span class="line">​</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">#8.执行命令启用脚本</span><br><span class="line">sudo systemctl enable frpc.service</span><br><span class="line">sudo systemctl start frpc.service</span><br><span class="line"></span><br><span class="line">#9.执行下面命令，查看服务状态，是running的话，就说明可以了</span><br><span class="line">sudo systemctl status frpc.service</span><br></pre></td></tr></table></figure>

<p>Linux 的软件安装目录是也是有讲究的，按照习惯一般把上面的frp软件解压防在<code>/usr/local/bin</code></p>
<ul>
<li><code>/usr</code>：系统级的目录，可以理解为<code>C:/Windows/</code></li>
<li><code>/usr/lib</code>：可以理解为<code>C:/Windows/System32</code> </li>
<li><code>/usr/local</code>：用户级的程序目录，可以理解为<code>C:/Progrem Files/</code>，用户自己编译的软件默认会安装到这个目录下</li>
<li><code>/opt</code>：用户级的程序目录，可以理解为<code>D:/Software</code>，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接<code>rm -rf</code>掉即可。在硬盘容量不够时，也可将<code>/opt</code>单独挂载到其他磁盘上使用</li>
</ul>
<p>源码放哪里？  </p>
<ul>
<li><code>/usr/src</code>：系统级的源码目录</li>
<li><code>/usr/local/src</code>：用户级的源码目录</li>
</ul>
<h3 id="五、安装Samba及配置"><a href="#五、安装Samba及配置" class="headerlink" title="五、安装Samba及配置"></a><strong>五、安装Samba及配置</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.安装samba 和samba-common-bin</span><br><span class="line">sudo apt-get install samba samba-common-bin</span><br><span class="line"></span><br><span class="line">#2.配置/etc/samba/smb.conf文件</span><br><span class="line">sudo nano /etc/samba/smb.conf</span><br><span class="line"></span><br><span class="line">#3.文件最后添加下列相关信息</span><br><span class="line">[home]										# 共享文件夹显示的名称</span><br><span class="line">comment = Fusion WorkStation Storage		# 说明信息</span><br><span class="line">valid users = Carrol,root					# 可以访问的用户</span><br><span class="line">path = /home/Carrol/						# 共享文件的路径</span><br><span class="line">browseable = yes							# 可被其他人看到资源名称（非内容）</span><br><span class="line">writable = yes								# 可写</span><br><span class="line">create mask = 0664							# 新建文件的权限为 664</span><br><span class="line">directory mask = 0775						# 新建目录的权限为 775</span><br><span class="line"></span><br><span class="line">#4.运行下列命令，测试一下配置文件是否有错误，根据提示做相应修改</span><br><span class="line">testparm</span><br><span class="line"></span><br><span class="line">#5.添加登陆账户并创建密码，必须是Linux已存在的用户</span><br><span class="line">sudo smbpasswd -a pi</span><br><span class="line"></span><br><span class="line">#6.重启服务</span><br><span class="line">sudo /etc/init.d/samba-ad-dc restart</span><br><span class="line"></span><br><span class="line">#7.但是Windows可能会出现无法点开的情况，这里需要在Windows的凭据管理器中添加账户信息（开始菜单里搜索凭据管理器即可打开），点击添加Windows凭据，输入你的服务器名称和账户密码</span><br></pre></td></tr></table></figure>

<p>至此相关前期工程已满足普通正常使用，如需后期的相关配置设置教程，可移步至原作：稚晖大佬的<a href="https://zhuanlan.zhihu.com/p/336429888">原文</a></p>
]]></content>
      <categories>
        <category>router</category>
      </categories>
  </entry>
  <entry>
    <title>2020下半年度个人总结</title>
    <url>/2020/12/31/2020%E4%B8%8B%E5%8D%8A%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-UCQrRykA" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="3932159" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p>2020年，没有上半年度的个人总结，因为今年注定有些遗憾和不完美</p>
<p>与其说是个人下半年度总结，还不如更接地气的讲，哪些事是对自己产生影响比较大的回忆。其实对于自身来讲，我很清楚自己想要的是什么，并一直坚信一种信念是：“你想成为一个什么样的人，你就是一个什么样的人”。</p>
<p>2020下半年度个人总结，出于最原始的目的是想为自己沪漂这一路走过的磕磕绊绊作一个载入，也为后来者提供一个借鉴。在此期间，有舍有得，也有失而复得，而更多的是作了很多的选择。</p>
<h3 id="一、事业"><a href="#一、事业" class="headerlink" title="一、事业"></a><strong>一、事业</strong></h3><p>目前从事的IT行业的软件测试工作，现处涉及的领域是银行金融，之所以没有把它用【工作】二字概括，是因为这段时间的重要性，我是把它切实的融入到自身发展规划中去进行考虑的。</p>
<p>在快要成为历史的2020年年底，冒着巨大的风险，依然遵循自己的内心，选择了非跨行型跳槽。我很清楚在未来自身的10年黄金时间和自己从事的IT软件行业10年的生命周期是紧紧牵连。从25岁到35岁，在此期间的我想给自己多做一些加法，在能够承受的范围内经历的更多，让自己在未来职业生涯中拥有更多的自信和勇气。</p>
<p>然而这次的经历，不得不让我对学历重新的进行审视。对于技术性的打工人来讲，一二线城市的要求是越来越高，越来越专业正规化。起步是本科，都是一种很普遍正常的现象，大专学历在去年下半年开始，在这个行业已经开始不淡定了，今年更是勒的上紧。同样对于大专学历的我来讲，也感到一阵急促，庆幸的是自己意识到形势，读了升本，暂未被这个行业所淘汰，赶上末班车。所以我是真心的建议：大专生走向社会，只要自己的收入还说的过去，一定要把升学历这个动作提前规划好。不要像我浑浑噩噩，混吃等死玩完了第一个宝贵的3年时间才去规划。</p>
<p>至于目前技术这一块，自己在接触一些开发编程语言，之前开始的时候有些迷茫，选择C语言，但后来通过身边一些从事IT行业同事建议，步入到Java的学习中。可是从一个小白，一下子开始接触，Java的友好度不是太好，随后自行接触到Python，现在一直在学习基础中，推荐一本书，<a href="www.ituring.com.cn">图灵社区</a>里的<a href="https://www.ituring.com.cn/book/2784">《Python编程：从入门到实践（第二版）》</a>，对新手的友好度还是不错的。另外通过一些媒体平台，简单了解一些前端JavaScript、数据库MySQL和Linux操作系统的基础知识点，但是我总感觉学的不深入，知识了解的皮毛很空洞。所以，明年的计划中是想将重心回归到测试这条主干线上来，Python基本知识点消化完之后，走自动化测试或者接口测试的路线。同样的，也会将这一过程中的QA同步至个人博客下的<a href="https://www.carrol.xyz/categories/software-testing/">编程测试</a>分栏，方便后续再遇到此状况，得到解决的方法。</p>
<p>截止目前，我自己最满意的技术实操，是通过不断的上网找资料，不断的折腾，不断的优化，亲自为自己搭建了这么一个博客平台，来记载平时的点点滴滴，可能明年会经历一次域名到期的更换，到时候会换上一个长达10年的白金小姨子域名。</p>
<h3 id="二、生活"><a href="#二、生活" class="headerlink" title="二、生活"></a><strong>二、生活</strong></h3><p>2016年12月28号校招来的上海，生活了三年左右，其实和大部分来城打工者的心态差不多，当时就想能够走出省，去大城市看看外面的世界，也没考虑过太多。经过这几年的时间来看，其实上海的生活成本并不像外人嘴中高的那么离谱，对于我这种“土鳖”来讲，真的没太大。除非自己作的太狠，要不然对于一个拥有一份工作的人来讲，都是可以能够接受的，女孩子的话，每个月比男孩子再多个千把两千块化妆品、衣服消费费用啥的。我不知道是不是没处对象的原因，可能在这一块，我的生活压力几乎没什么，每个月固定的房租，交通费，餐饮费，保险费，偶尔买买衣服和电子垃圾的费用，其他的也没什么。有时间就自己做饭，也不点外卖，自己也偏点胖，吃的也想健康点。周六周日休息，就好好的补一个大懒觉，醒来洗洗做个饭，上会网看看电影，今年由于疫情的原因，很少也出去潇洒，单反都在家吃灰。今年的自由时间偏重，可能还是大部分砸在玩电子垃圾和技术提升层面的多一些。</p>
<p>去年过年回家，嘴上一直吵吵着要换个好一点的房间，但看了看租金，自己还是舍不得，还是继续选择稍微次一点的单间，合租稍微相对划算一点。自己也讨厌搬来搬去，这是每个来上海打工人的共同憎恶点，也想在上海买个房，但终究败于现实，农村出来的小“土鳖”，口袋一贫如洗，也少了在上海买房这样白日梦。</p>
<p>但买房的小心愿不能丢，6月底7月初，25岁生日，父母倾其所有，置办了一套房，自己也背上一座山，彻彻底底成为一个房奴。怎么讲呢，那时候的心情还是比较复杂的。首先映入脑子的是：老爸老妈自己的养老金全掏出来，再加上借亲戚的，要是买了房之后，我拿这么点屁工资，还不上了该怎么办？快近60岁的老两口，要是在这期间，不慎得个什么病，那又得怎么办？……反正那时候脑子都是一种悲喜交加的状态，当时交首付，一部分刷的卡，一部分付的现金，20几年，从来没手摸过那么的一百元钞票，都是一沓一沓的，一万块，好多，再想想十万，一百万，得有多少。同时也挺开心，毕竟有了一个家，有了烟火气，喜还是大于悲的。</p>
<p>今年春节回来之后可能要进行一次搬家，因为一起合租的小伙伴要回老家了，也是有点突如其来。每天乘地铁来回上下班，也发现今年的现象，好多来上海的外地人都提前早早的回去了。三年前，当初一起来上海的七个小伙伴，几乎没几个留下来的，不知道为什么，也许在上海生存，真的很难，但我认为完全自己可以拼一把。因为之前我也曾有离开的想法，但可能自己思维比较清晰，清楚自己要的什么，怎么去改变自己所处的局面，就留下来了，跑步就是那时候养成的。那时刚来上海，底薪2K+全勤0.2K+提成，几个人去外滩说过的话，假如今后有一天，月薪过万就去东方明珠上去潇洒一圈，而今破了万，我依旧还是没去潇洒过，当初的年少轻狂，现在想想，月薪过万那够啊，够也就够喝个西北风。</p>
<p>未来的生活，正如我之前记载的，两个字【无畏】，也有两个计划，一是从2021年开始，每年回家过年，用单反拍张全家福；二是在2021~2022年的某个时间段，散去银行卡里的积蓄，带一家人来上海兜兜转转，记忆里老妈这辈子还没出过省。</p>
<h3 id="三、情感"><a href="#三、情感" class="headerlink" title="三、情感"></a><strong>三、情感</strong></h3><p>受家文化的影响，骨子里就很重情顾家</p>
<p>首先是恩情。从跨入IT行业以来，其实中间磕磕绊绊的有很多，最关键的就是怎样找到一份工作，能让自己在上海先活下去。得上天怜悯眷顾，遇到一个跟我姐差不多大的姐，我们以“大兄弟”互称，从开始就业到后续跳槽，也一直在不停的提供帮助。虽说这是她的工作，但我认为就业这件事始终跟任何人没有丝毫关系，自己拿的薪水不分人家一分钱，别人没有任何义务去帮你，但能够不断提供帮助，提供渠道，给予援手，尤其是在你最需要帮助的时候，不顾一切拉你一把的，这份恩情要铭记。以后不管怎样，当对方有需要的时候，能力范围里，定当全力以赴，哪怕舍掉某些东西。</p>
<p>其次是友情。玩的好算是至交的，原本就没几个，现在又在上海，基本没几个了。不需要有太多的酒肉之友，圈子小而干净，我很喜欢，买房的时候，就得益于跟自己一起玩的兄弟，提供的信息。不奢求太多，有空联系联系吃个饭，没事大家都忙，也要赚钱养家糊口，不扯淡。都说低质量的社交，不如高质量的独处，就很巴适。</p>
<p>最后就是爱情。从我自身出发来看，真的没去想过太多，只是家里催的紧，有点急，介绍过几个，都是没结果。自己想谈对象么？打心里是真想。那为什么不谈？怕自己目前经济能力不够，养自己一个人还行，养两个人可能会有点压力，怕对方跟着自己吃苦，耽误人家，索性就自己一个人，干脆果断。不可否认，自己情商低，不会说甜言蜜语，只想踏踏实实的，自己也渣不起来，因为家教在那摆着。对于相亲，我的态度很直接： 不拒绝但也不会盲目接受，合适就处，不合适就散。相亲，其实是让自己去认识一个人，而不是去谈恋爱，它是一个低预期的东西，就是去见个面，多认识个朋友，再此基础上慢慢去了解对方，发现彼此之间的优点。大家彼此都很独立，不是谁离开谁就活不下去，也没有必要看对方脸色去作舔狗。真诚简单一点：我想，你也想，嗳，大家聊一聊，还不错，喜欢彼此就都主动一点，一拍即合。深知自己是个人，寻找的是一个今后能持家的伴侣，能一起走过几十年美好时光的人，不是找个祖宗天天供着的。不会因为寂寞，无聊，对方长得漂亮等条件而在一起，不管是男孩子也好，还是女孩子也罢，都不要因为一时的满足感而去谈恋爱，毕竟谈了也都是需求型的恋爱，在得到满足之后，会逐渐消退掉初始的情感。人对爱的渴望，就和人在口渴的时候想要喝水一样的，是一种本能，理性一点。</p>
<h3 id="四、性格"><a href="#四、性格" class="headerlink" title="四、性格"></a><strong>四、性格</strong></h3><p>并不算活跃，多了几分沉稳，擅长沟通。相对比下，脾气其实并没有发现有多大的改变，还是铁憨憨。更大的改变可能是在沟通这一块，因为在上半年里听了几本书，其中有一本书叫《非暴力沟通》，也记载了一篇<a href="https://www.carrol.xyz/2020/04/05/%E3%80%8A%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E3%80%8B%E5%90%AC%E4%B9%A6%E8%AE%B0">听书记</a>，我觉得里面的方法真的挺实用，沟通后整个人都很舒畅，具有积极向上引导的一面，传递一种正能能量，所以整个人看的也挺开，性子也挺耐了。</p>
<p>但也在很多方面约束着自己，可以放松，但绝不能放纵，可以放肆自己还未退化的青春，但同时也会为自己的选择去负责。疯狂的时候也会熬夜打游戏，但是不会耽误明天自己的正事，也怕放松过度成放纵，受到惩罚。</p>
<p><strong>2020，就这样吧；2021，启程~~~</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Cookie、Session、Token、JWT简单说明</title>
    <url>/2020/12/03/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-tNYsuJhx" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="20110049" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h4 id="一、什么是-Cookie？"><a href="#一、什么是-Cookie？" class="headerlink" title="一、什么是 Cookie？"></a><strong>一、什么是 Cookie？</strong></h4><p><strong>1.HTTP 是无状态的协议</strong>：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次请求的发送者是不是同一个客户端。服务器与浏览器为了进行会话跟踪，就必须主动的去维护一个状态，这个状态用于告诉服务端前后两个请求是否来自同一个浏览器。这个状态就需要通过 Cookie 或者 Session 来实现</p>
<p><strong>2.Cookie 存储在客户端</strong>：Cookie 是服务器发送到用户浏览器，并进行保存到本地的数据，它会在浏览器下次向同一服务器再发起请求时被再一次被带到并发送到服务器上面</p>
<p><strong>3.Cookie 是不可跨域名</strong>：每个 Cookie 都会绑定单一的域名，无法在别的域名下获取使用</p>
<h4 id="二、什么是-Session？"><a href="#二、什么是-Session？" class="headerlink" title="二、什么是 Session？"></a><strong>二、什么是 Session？</strong></h4><p>1.Session 是区别 Cookie 的另一种记录服务器和客户端会话状态的机制<br>2.Session 是基于Cookie 实现的，Session 存储在服务器端，Sessionid 会被存储到客户端的 Cookie 中</p>
<p><img src="https://s3.ax1x.com/2020/12/03/DTxcy8.jpg"></p>
<p><strong>3.Session 认证流程</strong></p>
<p>a.用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</p>
<p>b.服务器响应客户端的请求，并返回唯一标识信息Sessionid 给浏览器</p>
<p>c.浏览器把返回的Sessionid 存储到 Cookie 中，同时Cookie 记录次Sessionid 属于哪个域名</p>
<p>d.当用户第二次访问服务器的时候，请求自动判断此域名下是否存在 Cookie 信息，如果存在就将Cookie 信息发送给服务端，服务端会从 Cookie 中获取 sessionid，再根据 sessionid 查找对应的 Session 信息，如果找到 Session 证明用户已经登录，可以执行后面操作，如果没有找到，说明用户没有登录或者失败</p>
<h5 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a><strong>Cookie 和 Session 的区别</strong></h5><p>1.安全性：Session 比 Cookie 安全，Session 是存储在服务器端，Cookie 是存储在客户端</p>
<p>2.存储值的类型不同：Cookie 只支持存字符串数据，设置为其它类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</p>
<p>3.有效期不同：Cookie 可设置为长时间保持，Session 的失效时间比较短，客户端关闭就会失效</p>
<p>4.存储大小不同：单个 Cookie 保持的数据不能超过 4KB，Session 存储数据高于 Cookie，当访问量过多，会占用更多的服务器资源。</p>
<h4 id="三、什么是-Token（令牌）？"><a href="#三、什么是-Token（令牌）？" class="headerlink" title="三、什么是 Token（令牌）？"></a><strong>三、什么是 Token（令牌）？</strong></h4><p>1.访问接口（API）时所需要的资源凭证，比如订单接口需要带上登录返回的 token 值，才能访问订单接口数据</p>
<p>2.常见的 token 组成：UID（用户唯一的身份标识）、time（当前时间的时间戳）、sign（签名，token+ 请求数据进行几次 md5 之后的值）</p>
<p>3.Token 的特点：服务端无状态化、可扩展性好；支持移动端设备；安全性好；支持跨程序调用</p>
<p><strong>Token 的身份验证流程：</strong></p>
<p><img src="https://s3.ax1x.com/2020/12/03/D7pSsK.jpg"></p>
<p>①、客户端使用用户名和密码，请求登录</p>
<p>②、服务端收到请求，验证用户名和密码</p>
<p>③、验证成功之后，服务端返回一个 token，并把这个 token 发送给客户端</p>
<p>④、客户端收到 token 之后，会把它存储起来，放入 Cookie 里面</p>
<p>⑤、客户端每次想服务器请求资源的时候，都需要带着这个 token</p>
<p>⑥、服务端收到请求的时候，验证客户端请求里面带着的 token，如果验证成功，就向客户端返回请求的数据</p>
<p>4.每一次请求都需要携带 token，需要把 token 放到 HTTP 的请求头里面，基于 token 的用户认证，服务端不用存放 token 数据。</p>
<h5 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a><strong>Token 和 Session 的区别</strong></h5><p>1.Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。</p>
<p>2.Token 是一种令牌，访问接口(API)时需要的凭证，也像古代进入到城里需要腰牌一样，Token 使服务器无状态化，不会存储会话信息。</p>
<p>3.Token 的安全性要好于 Session，每次请求都有签名，也就会出现每次的 Token 都会变化，也可以防止一定的攻击、</p>
<h4 id="四、什么是-JWT？"><a href="#四、什么是-JWT？" class="headerlink" title="四、什么是 JWT？"></a><strong>四、什么是 JWT？</strong></h4><p>1.JSON Web Token（简称 JWT）是目前最流行的跨越认证解决方案，是一种认证授权机制</p>
<p>2.JMT 是在网络应用环境之间传递声明，而执行的一种基于 JSON 的开发标准</p>
<p><strong>JWT 的认证流程：</strong></p>
<p><img src="https://p6-tt.byteimg.com/origin/pgc-image/c6d0b613372d4226aac79b23a6332b18?from=pc" alt="搞测试，Cookie、Session、Token、JWT？"></p>
<p>①、用户输入用户名&#x2F;密码登录，服务器认证成功之后，会返回一个 JWT 给客户端</p>
<p>②、客户端将 token 保存到本地（通常使用 localstorge）</p>
<p>③、当用户访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT</p>
<p>④、服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</p>
<p>⑤、JWT 内部保护了一些会话信息，减少了需要查询数据库的需要</p>
<p>⑥、JWT 并不使用 Cookie，可以使用任何域名提供你的 API 服务，不需要担心跨域的问题</p>
<p>⑦、用户的状态不存储在服务端的内存中，是一种无状态的认证机制</p>
<h5 id="Token-和-JWT-的区别"><a href="#Token-和-JWT-的区别" class="headerlink" title="Token 和 JWT 的区别"></a><strong>Token 和 JWT 的区别</strong></h5><p><strong>1.相同点：</strong></p>
<ul>
<li>都是访问资源的令牌</li>
<li>都可以记录用户的信息</li>
<li>都是使服务端无状态化</li>
<li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li>
</ul>
<p><strong>2.两者的区别：</strong></p>
<ul>
<li>Token：服务端验证收到客户端发送过来的 Token 时，需要查询数据库获取用户信息，验证 Token 是否有效</li>
<li>JWT：将 Token 和请求信息加密后存储在客户端，服务端只需要使用密钥进行校验即可，不需要查询或者减少查询数据库，因为 JWT 自己包含了用户信息和加密的数据</li>
</ul>
<p><strong>3.常见的前后端鉴权方式：</strong></p>
<ul>
<li>Session-Cookie</li>
<li>Token 验证（包括 JWT，sso）</li>
<li>Oauth2.0</li>
</ul>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>实用性技巧分享（1）——Linux搭建KMS服务器</title>
    <url>/2020/11/29/%E5%AE%9E%E7%94%A8%E6%80%A7%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94Linux%E6%90%AD%E5%BB%BAKMS%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-CFzcfmWO" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1438640937" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h4 id="1-下载-vlmcsd"><a href="#1-下载-vlmcsd" class="headerlink" title="1.下载 vlmcsd"></a><strong>1.下载 vlmcsd</strong></h4><p>下载文件并解压，把 <code>binaries\Linux\intel\static\</code> 下的 <code>vlmcsd-x64-musl-static</code> 上传至 <code>VPS/usr/bin/</code> 目录下，并改名为 <code>vlmcsd</code></p>
<h4 id="2-给予执行权限"><a href="#2-给予执行权限" class="headerlink" title="2.给予执行权限"></a><strong>2.给予执行权限</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/bin/vlmcsd</span><br></pre></td></tr></table></figure>

<h4 id="3-开启KMS服务"><a href="#3-开启KMS服务" class="headerlink" title="3.开启KMS服务"></a><strong>3.开启KMS服务</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/vlmcsd</span><br></pre></td></tr></table></figure>

<p>默认为 1688 端口，激活时无需输入端口号。如需更为其他端口，可以像下面这样，据说改了端口不容易被发现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/vlmcsd -L 0.0.0.0:2333</span><br></pre></td></tr></table></figure>

<h4 id="4-防火墙开放端口"><a href="#4-防火墙开放端口" class="headerlink" title="4.防火墙开放端口"></a><strong>4.防火墙开放端口</strong></h4><p>De­bian 系统，使用 UFW 管理防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ufw allow 1688/tcp</span><br><span class="line">ufw reload</span><br></pre></td></tr></table></figure>

<h4 id="5-设置开机启动"><a href="#5-设置开机启动" class="headerlink" title="5.设置开机启动"></a><strong>5.设置开机启动</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/rc.local</span><br></pre></td></tr></table></figure>

<p>如果不需要修改端口就直接加入 <code>/usr/bin/vlmcsd</code>，需要修改端口就加入 <code>/usr/bin/vlmcsd -L 0.0.0.0:2333</code>（2333 改为自己想设定的端口即可）</p>
<h4 id="6-测试-KMS-服务器"><a href="#6-测试-KMS-服务器" class="headerlink" title="6.测试 KMS 服务器"></a><strong>6.测试 KMS 服务器</strong></h4><p>在解压的文件中进入到 <code>binaries\Windows\intel\</code> 这个路径中，打开 cmd，把 <code>vlmcs-Windows-x64.exe</code> 拖进去，在后面输入刚刚部署好的 KMS 服务器的 IP。返回信息显示 successful，就说明 KMS 服务器可用。</p>
]]></content>
      <categories>
        <category>router</category>
      </categories>
  </entry>
  <entry>
    <title>OpenWrt编译步骤</title>
    <url>/2020/11/27/OpenWrt%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-SpNgXcsq" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="32451978" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、首次编译"><a href="#一、首次编译" class="headerlink" title="一、首次编译"></a><strong>一、首次编译</strong></h3><h4 id="1-克隆-Open­Wrt-源码"><a href="#1-克隆-Open­Wrt-源码" class="headerlink" title="1.克隆 Open­Wrt 源码"></a><strong>1.克隆 Open­Wrt 源码</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/coolsnowwolf/lede openwrt</span><br></pre></td></tr></table></figure>

<h4 id="2-进入源码目录"><a href="#2-进入源码目录" class="headerlink" title="2.进入源码目录"></a><strong>2.进入源码目录</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd openwrt</span><br></pre></td></tr></table></figure>

<h4 id="3-下载-feeds-源中的软件包源码"><a href="#3-下载-feeds-源中的软件包源码" class="headerlink" title="3.下载 feeds 源中的软件包源码"></a><strong>3.下载 feeds 源中的软件包源码</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scripts/feeds update -a</span><br></pre></td></tr></table></figure>

<p>feeds 是扩展的软件包，独立于 Open­Wrt 源码之外，所以需要单独进行拉取和更新</p>
<h4 id="4-安装-feeds-中的软件包"><a href="#4-安装-feeds-中的软件包" class="headerlink" title="4.安装 feeds 中的软件包"></a><strong>4.安装 feeds 中的软件包</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scripts/feeds install -a</span><br></pre></td></tr></table></figure>

<h4 id="5-调整-Open­Wrt-系统组件"><a href="#5-调整-Open­Wrt-系统组件" class="headerlink" title="5.调整 Open­Wrt 系统组件"></a><strong>5.调整 Open­Wrt 系统组件</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>首次编译建议只选择架构，其它都不要动，这样编译成功率会更高，如果不打算调整组件则输入<code>make defconfig</code>，它会检测编译环境并生成默认的编译配置文件</p>
<h4 id="6（1）-预下载编译所需的软件包"><a href="#6（1）-预下载编译所需的软件包" class="headerlink" title="6（1）.预下载编译所需的软件包"></a><strong>6（1）.预下载编译所需的软件包</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://e.coding.net/yao7778899/openwrt-dependent-dl.git dl</span><br><span class="line"># 依赖库源码总计约850M</span><br></pre></td></tr></table></figure>

<h4 id="6（2）-预下载编译所需的软件包"><a href="#6（2）-预下载编译所需的软件包" class="headerlink" title="6（2）.预下载编译所需的软件包"></a><strong>6（2）.预下载编译所需的软件包</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make download -j8 V=s</span><br></pre></td></tr></table></figure>

<p>-j8是指使用8个线程下载，理论上是数字越大下载越快，但似乎有个上限，实测5线程以上其实速度相差不了多少，在网络好的情况下，基本在5分钟以内能下载完</p>
<h4 id="7-检查文件完整性"><a href="#7-检查文件完整性" class="headerlink" title="7.检查文件完整性"></a><strong>7.检查文件完整性</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find dl -size -1024c -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>此命令可以列出下载不完整的文件（根据多次编译的经验，得出小于1k的文件属于下载不完整），如果存在这样的文件可以使用<code>find dl -size -1024c -exec rm -f &#123;&#125; \;</code>命令将它们删除，然后重新执行<code>make download</code>下载并反复检查，确认所有文件完整可大大提高编译成功率，避免浪费时间</p>
<h4 id="8-开始编译"><a href="#8-开始编译" class="headerlink" title="8.开始编译"></a><strong>8.开始编译</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j1 V=s</span><br></pre></td></tr></table></figure>

<p><code>-j1</code>：使用单线程编译。新手推荐单线程编译，一是因为玄学问题可能成功率高，二是方便查看错误日志</p>
<p><code>V=s</code>：输出详细日志，用于编译失败时找出错误</p>
<h3 id="二、再次编译"><a href="#二、再次编译" class="headerlink" title="二、再次编译"></a><strong>二、再次编译</strong></h3><h4 id="1-进入源码目录"><a href="#1-进入源码目录" class="headerlink" title="1.进入源码目录"></a><strong>1.进入源码目录</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd openwrt</span><br></pre></td></tr></table></figure>

<h4 id="2-更新"><a href="#2-更新" class="headerlink" title="2.更新"></a><strong>2.更新</strong></h4><h5 id="a-更新系统软件包"><a href="#a-更新系统软件包" class="headerlink" title="a.更新系统软件包"></a><strong>a.更新系统软件包</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;apt update &amp;&amp; apt upgrade -y&quot;</span><br></pre></td></tr></table></figure>

<p>主要作用是更新在编译环境搭建时所安装的编译组件</p>
<h5 id="b-拉取-Open­Wrt-源码更新"><a href="#b-拉取-Open­Wrt-源码更新" class="headerlink" title="b.拉取 Open­Wrt 源码更新"></a><strong>b.拉取 Open­Wrt 源码更新</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h5 id="c-更新并安装-feeds-源中的软件包源码"><a href="#c-更新并安装-feeds-源中的软件包源码" class="headerlink" title="c.更新并安装 feeds 源中的软件包源码"></a><strong>c.更新并安装 feeds 源中的软件包源码</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scripts/feeds update -a &amp;&amp; ./scripts/feeds install -a</span><br></pre></td></tr></table></figure>

<h4 id="3-文件清理（可选）"><a href="#3-文件清理（可选）" class="headerlink" title="3.文件清理（可选）"></a><strong>3.文件清理（可选）</strong></h4><h5 id="a-清除旧的编译产物"><a href="#a-清除旧的编译产物" class="headerlink" title="a.清除旧的编译产物"></a><strong>a.清除旧的编译产物</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>

<p>在源码有大规模更新或者内核更新后执行，以保证编译质量。此操作会删除<code>/bin</code>和<code>/build_dir</code>目录中的文件</p>
<h5 id="b-清除旧的编译产物、交叉编译工具及工具链等目录"><a href="#b-清除旧的编译产物、交叉编译工具及工具链等目录" class="headerlink" title="b.清除旧的编译产物、交叉编译工具及工具链等目录"></a><strong>b.清除旧的编译产物、交叉编译工具及工具链等目录</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make dirclean</span><br></pre></td></tr></table></figure>

<p>更换架构编译前必须执行，此操作会删除<code>/bin</code>和<code>/build_dir</code>目录的中的文件(<code>make clean</code>)以及<code>/staging_dir</code>、<code>/toolchain</code>、<code>/tmp</code>和<code>/logs</code>中的文件</p>
<h5 id="c-清除-Open­Wrt-源码以外的文件"><a href="#c-清除-Open­Wrt-源码以外的文件" class="headerlink" title="c.清除 Open­Wrt 源码以外的文件"></a><strong>c.清除 Open­Wrt 源码以外的文件</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make distclean</span><br></pre></td></tr></table></figure>

<p>除非是做开发，并打算 push 到 GitHub 这样的远程仓库，否则几乎用不到。此操作相当于<code>make dirclean</code>外加删除<code>/dl</code>、<code>/feeds</code>目录和<code>.config</code>文件</p>
<h5 id="d-还原-Open­Wrt-源码到初始状态"><a href="#d-还原-Open­Wrt-源码到初始状态" class="headerlink" title="d.还原 Open­Wrt 源码到初始状态"></a><strong>d.还原 Open­Wrt 源码到初始状态</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clean -xdf</span><br></pre></td></tr></table></figure>

<p>如果把源码改坏了，或者长时间没有进行编译时使用</p>
<h5 id="e-清除临时文件"><a href="#e-清除临时文件" class="headerlink" title="e.清除临时文件"></a><strong>e.清除临时文件</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf tmp</span><br></pre></td></tr></table></figure>

<p>删除执行<code>make menuconfig</code>后产生的一些临时文件，包括一些软件包的检索信息，删除后会重新加载<code>package</code>目录下的软件包，若不删除会导致一些新加入的软件包不显示</p>
<h5 id="f-删除编译配置文件"><a href="#f-删除编译配置文件" class="headerlink" title="f.删除编译配置文件"></a><strong>f.删除编译配置文件</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -f .config</span><br></pre></td></tr></table></figure>

<p>在不删除的情况下如果取消选择某些组件它的依赖组件不会自动取消，所以对于需要调整组件的情况下建议删除。</p>
<h4 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a><strong>4.编译</strong></h4><h5 id="a-调整-Open­Wrt-系统组件"><a href="#a-调整-Open­Wrt-系统组件" class="headerlink" title="a.调整 Open­Wrt 系统组件"></a><strong>a.调整 Open­Wrt 系统组件</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>如果不打算调整组件则输入<code>make defconfig</code>，它会检测编译环境并根据更新自动调整编译配置文件</p>
<h5 id="b-预下载编译所需的软件包"><a href="#b-预下载编译所需的软件包" class="headerlink" title="b.预下载编译所需的软件包"></a><strong>b.预下载编译所需的软件包</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make download -j8 V=s</span><br></pre></td></tr></table></figure>

<h5 id="c-检查文件完整性"><a href="#c-检查文件完整性" class="headerlink" title="c.检查文件完整性"></a><strong>c.检查文件完整性</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find dl -size -1024c -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h4 id="5-开始编译"><a href="#5-开始编译" class="headerlink" title="5.开始编译"></a><strong>5.开始编译</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j$(nproc) || make -j1 || make -j1 V=s</span><br></pre></td></tr></table></figure>

<p>多线程编译失败后自动进入单线程编译，失败则输出详细日志</p>
<p>Tips：首次编译中步骤6（1）和6（2），两者选其一，且步骤7是和步骤6（2）搭配使用，步骤6（1）可跳过.</p>
]]></content>
      <categories>
        <category>router</category>
      </categories>
  </entry>
  <entry>
    <title>25岁的无知与无畏</title>
    <url>/2020/06/26/25%E5%B2%81%E7%9A%84%E6%97%A0%E7%9F%A5%E4%B8%8E%E6%97%A0%E7%95%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-HtvWdglb" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1407590883" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p>凌晨两点，磕碜的不敢睡</p>
<p>端午节，从上海高铁到无锡，注定这场奔波可能会付出上百万的代价，下午去看了房，总体户型评估下来还挺满意，三室两厅一卫一厨，主卧和客厅阳台向阳，第一栋楼，采光不受任何影响很不错，楼层在中间偏上，两梯四户，公摊面积稍微小一点，得房率按照无锡目前的标准来讲75%，周边配备幼儿园，小学，中学要在往西走的个大概几公里，商场经济圈也都有，房子就是这么个大概情况。按照目前无锡的整个房子的均价1.5W来讲，这套精装修的房子，绝对是可以下手的。具体细节还需要再过几个小时，当面再进行一次沟通，作为一个即将成为房奴的人来讲，肯定是希望杀价杀的越低越好，诈空里面的套路和水分。</p>
<p>预算了一下总价，差不多一百大多万，首款个人商品住宅房4成首付，自己到现在也没摸过这么多钱，从来没有，买个房子一下子，emm，真的从来没想过，在脑子里没这样的一个概念，一切来得有点太突然，从得知楼盘消息，到即将敲定房子，差不多也就两个星期左右，买这个房子，其实我心里一点都感觉不到开心，或者说半喜半忧吧。</p>
<p>因为买套房，搭上父母算是一辈子的心血，外加上自己未来几十年的部分收入，我总是开心不起来或者说是半喜半忧，喜是因为有了属于自己的房子，过段时间终于不用再租别人的房子，不用再受房租的变化而经常搬家；忧是因为家里搬出所有的资金去买房，所有的生活质量都会下降很大的层次。我不是担心房贷还不上，而是担心未来几十年的日子里，我的身体包括父母的身体不允许大的健康问题，即便说我给他们上了保险，医院不是个什么好地方。</p>
<p>对于即将26岁的我来讲，来上海的第一个3年，自己活得很迷茫，不知道自己要干什么，赚钱就只养活自己一个人在上海的开销，交一交父母的保险，带着团队出去，吃一吃，喝一喝，玩一玩，感觉真的没什么压力，而且很满足。但自从今年疫情爆发，感觉形势不太对，逐渐认识到今年是个风口，站在风口，猪都能飞起来，所有在今年年初的时候，给到自己预计的计划就实现3个——第一：房子和车子在今年年底前，敲定其中一样；第二：提升自己专科学历至本科；第三：今年想花光所有的运气，追到一个合适的对象。上半年，敲定了房子，本科学历也报了名；下半年，找对象啦，说句实在话，自己在外面飘了3年，房子买了，也想组建家庭了。</p>
<p>总而言之，买了房，整个人的目标更加明确，满眼的欲望更加被放大化，之前是人无远虑，也无近忧，现在是远虑近忧全砸手里，累是绝对的，但它也是美好充实的，我爱生活，也更加珍惜当下所有一切可以抓住的机会，因为我骨子里依旧享受生活所创造的一切。</p>
<p>26岁，依旧年轻，依旧可以目标重定向，再出发。</p>
<p>6月28日的26岁生日小愿望：不奢求什么美好，就希望家人平安健康，追到对的人。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS 7服务器搭建实战（一）</title>
    <url>/2020/06/13/CentOS%207%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-GRnNjtMu" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="355992" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p>搭建在实战开始前，首先要理清一些理论性的网络基础知识和实用工具，对于服务器涉及的网络知识有很多，自己掌握的也并不是很全面也在不断学习充电当中，但针对本次Linux服务器项目的搭建，所需要的网络基础知识，在本文做一个覆盖，说清，理解，明白。</p>
<h2 id="一、基础知识：TCP-IP协议栈"><a href="#一、基础知识：TCP-IP协议栈" class="headerlink" title="一、基础知识：TCP&#x2F;IP协议栈"></a><strong>一、基础知识：TCP&#x2F;IP协议栈</strong></h2><h3 id="1-详细七层模型和缩略四层模型映射对应关系"><a href="#1-详细七层模型和缩略四层模型映射对应关系" class="headerlink" title="1.详细七层模型和缩略四层模型映射对应关系"></a><strong>1.详细七层模型和缩略四层模型映射对应关系</strong></h3><p>七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<p>四层模型：网络访问层（数据链路层或网络接口层）、网络层、传输层、应用层</p>
<p><img src="https://s1.ax1x.com/2020/06/15/NSxKyj.png"></p>
<p>有些地方叫法不一样，实则表达含义是一样的，在TCP&#x2F;IP 参考模型中，各项通信协议各有归属，像我们在浏览器中常用的：HTTP（超文本传输协议）、DNS（域名系统）、FTP（文件传输协议）、SMTP（简单邮件传输协议等）都是属于应用层协议，而 TCP、UDP 则属于传输层协议，IP 则属于网络层协议</p>
<p><img src="https://s1.ax1x.com/2020/06/15/NSxvBn.png"></p>
<h3 id="2-完整的一次网络通信过程模拟"><a href="#2-完整的一次网络通信过程模拟" class="headerlink" title="2.完整的一次网络通信过程模拟"></a><strong>2.完整的一次网络通信过程模拟</strong></h3><p>为了对HTTP请求的通信过程有一个更好的理解，从TCP&#x2F;IP四个层次出发，对应各个层次的通信实体，或者媒介（例如浏览器，路由器以及网线等），看各个协议是如何在这些通信实体中发生作用，将一个请求发送到服务器，服务器的响应又是如何赶回来的。</p>
<p>整体来讲，一次完整的通信，很像快递邮递包裹，物品被加上包装，写上地址信息和联系方式，经过一个又一个的快递中转站，到达收货人的位置。在网络请求中，请求的数据就是需要快递的物品，IP地址和MAC地址就是通信的地址，网线和路由器、交换机和集线器等就是运输道路和快递中转站，网络协议则可以看做快递员和快递政策，而和快递类似的是网络通信也会出现丢包（包裹损坏）等情况。所以说，一个简单的HTTP请求，要完整地拿到请求信息，中间有若干操作系统组件、通信协议、通信实体参与，才能保证通信的顺利进行。</p>
<p>那么，这个快递过程，其基本原则是通过分层的顺序，发送端由上往下发送，接收端则由下向上接收。为了保证数据顺利发送到下一个层次，会在发送在其头部加上一些必要的信息，这些信息是为了保证数据的完整和符合需求的约束信息。发送HTTP请求时，经常会设置Request Header，例如 ：Content-Type：text&#x2F;html 是向服务器说明，需要的是 HTML 页面，返回其他东西是不行的。</p>
<p>这些头部信息还可能包含协议信息，请求路径、请求方法等，但这仅仅是发生在应用层，整个通信过程，经过四个层次，会被依次加上 HTTP 请求头，TCP头部、IP头部以及以太网头部。数据加上这些头部信息之后，才会被发往下一层，数据经过重重包装，从电脑网卡出发，穿过若干路由器，网线，交换机，到达目标服务器所在的子网，服务器要做的则是相反的过程，它会根据前面加上的头部信息，层层解析，最后到达服务器被处理（处理就是服务端程序代码的责任），之后再将响应数据返回。整体过程如下图：</p>
<p><img src="https://s1.ax1x.com/2020/06/15/NpS6Qe.jpg"></p>
<p>数据在各个层次间依次传递，其传递的数据单位可以统一理解为数据包，数据包在不同的层次有不同的称呼，平时熟悉的是其从应用层出发时，将之称为HTTP请求消息（message）或者报文；为其加上消息头之后，发送至传输层，加上TCP头部，叫它报文段（segment）；到网络层，加上 IP 头部，成为 IP 数据包；到了最后的网络访问层，其已经套上层层包装，在这里在为其加上以太网首部的同时，还会加上一些尾部信息，摇身变为帧（framing），这个过程叫做封装过程。不管怎么叫，数据在各个层次间，是以数据包的形式传递，当数据量大时，还会出现分包传递的情况。</p>
<h3 id="3-通信过程中每一协议参与流程"><a href="#3-通信过程中每一协议参与流程" class="headerlink" title="3.通信过程中每一协议参与流程"></a><strong>3.通信过程中每一协议参与流程</strong></h3><p>假设现对：<a href="https://www.google.com/">https://www.google.com/</a> 进行访问</p>
<h4 id="①-DNS查询解析"><a href="#①-DNS查询解析" class="headerlink" title="①.DNS查询解析"></a><strong>①.DNS查询解析</strong></h4><p>URL只是为了更友好识别网络程序而设置的互联网资源的定位标识，浏览器首先会对URL进行解析，获取到请求的协议（https），域名（google.com），路径（&#x2F;），由于没有其他子域名，也就是查询 google 的默认主页，解析完毕后，DNS开始工作。</p>
<p>DNS，也就是域名查询系统，负责URL对应的IP地址的查询，每个操作系统会内置Socket协议库，协议库中有解析器（resolver）专门负责这个过程，经过 DNS 查询，浏览器拿到了请求资源的IP地址。IP地址，又叫网际协议地址，是分配给网络上设备的数字标识，也就是说，只要联网的设备，例如电脑、手机以及路由器等都是有IP地址的，其是我们的请求数据识别服务器在网络中的位置的必须标识。</p>
<h4 id="②-MAC地址查询"><a href="#②-MAC地址查询" class="headerlink" title="②.MAC地址查询"></a><strong>②.MAC地址查询</strong></h4><p>IP地址在网络层使用，但在实际的数据链路上传递数据时，在同一个链路中不同的计算机，其必须要使用另一个地址来识别——Mac地址，又叫做物理地址。通常提到三个地址：IP地址、Mac地址以及端口号，三者分别代表的是：</p>
<p><strong>IP地址</strong>：网络中互联的主机和路由器的标识。</p>
<p><strong>Mac 地址</strong>：每个网卡硬件的物理地址。</p>
<p><strong>端口号</strong>：识别同一个主机上不同的应用程序，也可以理解为程序地址。</p>
<p>所以，在一个网络通信中，需要用到五大识别符：源IP地址、目标IP地址、协议、源端口号和目标端口号。Mac地址是每一个网卡被生产的时候就写死在其中的，所以其是不变且唯一的，紧接着就是要得到服务器的Mac地址，引入一个新的协议——ARP。</p>
<p>ARP，英文全称叫做 Address Resolution Protocol，也就是地址解析协议，其作用是：根据IP地址获取通信设备的物理地址，其工作原理类似于以前我们常见的广播，它会将包发送给同一以太网的所有主机，若目标主机的Mac地址与对应的IP地址吻合，则找到了目标，但是若每次查询都要给所有的主机发送ARP请求，网络中则会出现很多ARP包，因此每个主机都会有一个ARP缓存，里面存放着常用的 MAC地址，主机会优先从缓存中查询是否有需要的信息，如果有就不再发送广播。Mac地址会在网络层加入IP头部发往网络访问层。其实仔细观察会发现，为了提高效率和性能，网络通信中随处可见缓存，HTTP 缓存、DNS缓存以及ARP缓存等。值得了解的是在IPv6中，有一个 NDP（邻居发现协议）替代 ARP 来完成这个工作。</p>
<h4 id="③-套接字数据传输"><a href="#③-套接字数据传输" class="headerlink" title="③.套接字数据传输"></a><strong>③.套接字数据传输</strong></h4><p>之前提到操作系统中有一个协议库，负责本机中网络通信的很多功能，在DNS查询的时候，协议栈中的解析器就参与其中，当应用层获取到服务器的IP地址和MAC地址，已经拥有了数据传递的必要条件，接下来浏览器会向操作系统的协议库发出委托指令，调用其中Socket库中的程序组件，建立套接字（socket），套接字的本质可以理解为一个数据通道的出入口，其执行的是一个“打开，读&#x2F;写，关闭”的流程。</p>
<p>在进行数据传输时，客户端和服务器都会创建一个套接字，之后调用socket库中的connect组件，该组件会依据描述符（套接字的匹配令符，与服务端的套接字的接头暗号），服务器的IP地址和端口号，在浏览器和目标服务器之间建立一个传输通道（实际上并没有真实的通道，中间隔着N多网关、路由器和防火墙，这样讲是为了更好理解），而听的最多的TCP三次握手四次挥手，实际就是发生在这个阶段，稍后作一个详细的说明。</p>
<p>通道建立之后，接下来就是数据的读写操作，程序代码无法直接控制套接字，它依然会委托Socket库中的组件来完成数据的读写（write 和 read），数据传输完成后，服务器会主动执行断开操作，调用Socket库中的close组件断开连接，浏览器发现之后，也会执行断开操作，数据传输完成。可以看到，在应用程序代码的背后，操作系统中内置的组件库和互联网协议互为网络通信的左膀右臂，共同负责整个通信过程，缺一不可。</p>
<h3 id="4-三次握手和四次挥手"><a href="#4-三次握手和四次挥手" class="headerlink" title="4.三次握手和四次挥手"></a><strong>4.三次握手和四次挥手</strong></h3><p>TCP和UDP是传输层中的两个主要协议，两者的区别是：前者是面向连接的（实际就是套接字管道）、可靠的流协议；后者则并不可靠，它采取一种“尽最大努力”的传输策略，浏览器、邮件等应用程序一般使用 TCP 传递数据，而像DNS查询等较短的收发则使用UDP。整体来讲，之所以要在发送数据之前建立套接字，正是因为TCP是面向连接的传输协议，在传输协议面前，你发送的内容无关紧要，它们会将之看为一串具有一定长度的数据。为了保证数据传输的可靠，TCP在套接字建立连接时，采用“三次握手”策略传输数据。下面是一张三次握手流程图：</p>
<p><img src="https://s1.ax1x.com/2020/06/17/NZe21x.png"></p>
<p>说明：图中的syn是 Synchronize Sequence Numbers 的简写，也就是同步序列编号，拥有数据传输序列的标识；ack是acknowledgement，表示确认。</p>
<p>通俗来讲，是这样一个过程：</p>
<p>第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号），syn&#x3D;j，其进入SYN_SEND 状态等待服务器确认：我已准备好，随时出发！</p>
<p>第二次握手：服务器接收客户端 syn 包并确认（ack&#x3D;j+1），同时向客户端发送一个 syn 包（syn&#x3D;k），也即 syn + ack 包，此时服务器进入SYN_RECV 状态：收到请求，随时接收。</p>
<p>第三次握手：客户端收到服务器的 syn + ack 包，向服务器发送确认包 ack（ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED 状态，完成三次握手：OK，我知道了，那我们开始发送数据。</p>
<p>可能会觉得相当麻烦，确认一次就可以为什么需要三次握手呢？其实，为了保证数据传输的绝对可靠，三次确认是最少的次数，试想这样一种情况：在第一次得到确认后，客户端发送数据出去，但是这个数据由于中途网络等问题，迟迟到不了服务端，服务端选择关掉通道，但通道关闭后，刚刚的数据又跑过来了，这时候，服务端会将这个数据视为来自客户端的新的传输请求，同意建立连接，而建立一个新的连接，但是，客户端并没有发送数据，所以，它会忽视服务端的确认，也不会回应给服务端，服务端就在傻傻滴等待，但这种等待是没有结果的，这就造成了服务端资源的浪费。</p>
<p>知乎上有另外一种理解：之所以需要三次握手，本质的原因是：传输信道是不可靠的，你不知道网络会在什么时候出什么样的问题，所以，为了保证传输的确可靠，三次握手是理论上的最小值。</p>
<p>TCP传输数据时，并不是将所有数据一股脑全丢出去，而是会将数据存放在一个的发送缓冲区，并且会等待应用程序的下一段程序到达，之所以这样干，是因为一收到数据立马发送，很可能会造成信道的浪费与闲置，导致网络效率太低，就像明明很宽的马路，非要像过独木桥一样通过。</p>
<p>而TCP如何决定数据什么时候会发送，其拥有一套计算机制，整体来说，是按网络包的长度以及应用程序送包过来的时间，虽然你的数据很小，但你半天不发送，我也不会一直傻等着。</p>
<p>还有一种情况是，当发送过来的数据包很大时，会在缓冲区对包进行拆分发送，拆分的时候，TCP模块会计算好每一块数据的开头和结尾的字节数，并将之写在TCP头部信息中，以待对方确认，根据这些起始序号，接收方可以判断是否有数据遗漏的情况。</p>
<p>每发送一个包，就需要等待ack包的确认，这也是一种资源浪费，所以为了利用等待ack的空闲时间，数据可以不用等待ack直接发送，但是这会出现一种情况，一边一味地发送，但超过了接收方的处理能力，就会出现网络拥堵，得不偿失。为了解决这个问题，TCP 采取了一种滑动窗口的发送策略，它的原理是这样的：</p>
<p>滑动窗口实际上是数据流量控制策略，我们可以将所有的数据想象为一个序列，而窗口则是数据可处理的数据大小，接收方会将窗口的大小写入ack包的头部信息中，告知发送方，发送方会据此动态调整发送的速率，由于传输的持续进行，这个窗口大小会动态变化，因此达到了流量的控制，其本质的目的是，不要发的太快，让接收方处理不过来。</p>
<p><img src="https://s1.ax1x.com/2020/06/17/NZmXGR.jpg"></p>
<p>但是在浏览器和服务器之间，可能隔着极多的网关、路由器、交换机等，数据是如何在庞大无比的因特网上找到服务器的呢？这里就涉及到网络层协议了，实际上这一切在请求发送之前已经准备好了，我们使用DNS和ARP等方式，获取到了目标服务器的IP地址和Mac地址，这两个地址引导发送的数据包到达服务器，IP地址用于在网络中的所有主机中匹配通信的目标主机，IP地址包含网络标识和主机标识，前者用于区别不同的网段，后者找到同一网段的不同主机，数据到达路由器时，路由器会根据网络标识将数据转发到相应的网段，到达相应的网段之后，又会根据主机号，到达真正的主机。</p>
<p>记载到这里，可能会碰到一个疑惑，就是既然IP地址都能找到目标服务器，为什么还需要Mac地址？</p>
<p>其实是：在同一个网段内通信时，只用知道Mac地址，就可以精准找到目标，但是互联网上的网络数量无比庞大，网络被各大运营商分割为多个网段，每个网段又有多个子网，如果仅仅知道一个Mac地址，要在所有的网络设备进行匹配，就是相当大的工程了，这时候IP地址的妙用体现出来了，它可以用来找路，这就类似于快递中的省市地区等，而Mac地址可能是唯一的名字，你在全中国找一个小强的人那就太多了，但是你要具体到某一个村或小区，就很简单了。</p>
<p><img src="https://s1.ax1x.com/2020/06/17/NZn4FH.jpg"></p>
<p>另外一个原因是：交换机这个东西，只认Mac地址，就如同路由器根据IP地址决定网络请求的转发路线，交换机通过 Mac 地址来确定具体的网卡位置。</p>
<p>路由器、交换机、网线、光纤等正是TCP&#x2F;IP四层协议的最底层，网络访问层，也就是OSI模型中的数据链路层和物理层，在这一层，数据被加上以太网首部，封装成帧在各个路由器之间转发传送，经常来说，路由器之间的传送又有常用的点对点协议，也就是PPP（Point-To-Point Protocol），这是一个网络访问层协议，PPP会在帧的前后加上帧界定符进行发送。最后，到达服务器所在子网，会将消息转交网络层向上传递。向上传递的过程如前所述，乃是解析头部信息，最终到达服务器的相反过程，不再细述。</p>
<p>这个过程可以在前面的整体过程图清晰看到，请求数据到达服务器所在子网的路由器之后，又是一个由下而上的过程，这与客户端发送数据基本相反，每经过一个层次，都会解析前面添加到请求数据上的多层头部信息，交由上一层处理，在整个TCP&#x2F;IP协议栈的帮助下，请求数据终于到达了目标服务器，穿过服务器的网卡，服务器操作系统同样有协议栈来负责找到服务端程序对应的端口，将数据交由服务端应用程序处理。</p>
<p>服务器会根据我们的请求头信息，处理返回结果，之后请求响应信息重新出发，再次回到浏览器，浏览器收到请求后，经过解析、渲染过程，页面呈现在我们面前。</p>
<h2 id="二、实用工具：vmware、Xshell（Putty）"><a href="#二、实用工具：vmware、Xshell（Putty）" class="headerlink" title="二、实用工具：vmware、Xshell（Putty）"></a><strong>二、实用工具：vmware、Xshell（Putty）</strong></h2><h3 id="1-vmware"><a href="#1-vmware" class="headerlink" title="1.vmware"></a><strong>1.vmware</strong></h3><p>vmware虚拟机，用最简单的一句话讲就是一个装载工具（容器），一个壳，它类似于EXSI或者说最近玩的比较火的Docker，简单看一下，这是我本地的一个vmware里面装了一个Ubuntu系统，用于编译路由器的OpenWrt固件所使用的，界面是比较简洁，一般我还常用CentOS 7的系统，目前没有装。</p>
<p><img src="https://s1.ax1x.com/2020/06/18/NZBagx.png"></p>
<h3 id="2-Xshell（Putty）"><a href="#2-Xshell（Putty）" class="headerlink" title="2.Xshell（Putty）"></a><strong>2.Xshell（Putty）</strong></h3><p>Xshell（Putty）其实就是一个连接工具，目前个人用比较多的就是Xshell，可以连接以Linux操作系统的服务器，现在绝大多数的VPS都会装Linux的CentOS 7的这款发行版，一般的像科学上网的部署，流量的伪装…….，这里不多说，反正有一台Linux的服务器，你可以干很多的事，目前我自己也有很多Linux的小主机服务器，绑定公网IP的要实现穿透技术…..，还是建议自己去买个阿里云、华为云…..这些大厂的云服务器，也简单的看一下吧，这是我连接的自己家一台安装Armbian操作系统的服务器，Armbian系统也是Linux系统的一种，它一般运行在ARM架构处理器的机器上跑。</p>
<p><img src="https://s1.ax1x.com/2020/06/18/NZDBzq.jpg"></p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>别轻易安慰一个成年人，会痛</title>
    <url>/2020/06/01/%E5%88%AB%E8%BD%BB%E6%98%93%E5%AE%89%E6%85%B0%E4%B8%80%E4%B8%AA%E6%88%90%E5%B9%B4%E4%BA%BA%EF%BC%8C%E4%BC%9A%E7%97%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-tfXIKzNk" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="454035505" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p>最近一段时间有点忙，不管是在工作上还是在生活上都显得有点急促，从5月中旬开始，花了差不多一个多星期的时间给一个朋友做了一副手工钉子画，效果还是不错的，挺漂亮的！</p>
<p><img src="https://s1.ax1x.com/2020/06/01/tGqnDP.jpg"></p>
<p>另外就是家里开始计划看看房子，我自己想计划看看昆山的房子，但是现在这个落户购买资格，各方面卡的很厉害，本科和大专购房还有区别，搞得很纠结。于是萌生了接下来一段时间的计划——专升本，原本想在今年年底开始着手去升本的，但是现在的情况，再加上等到拿证至少还有2年半的时间，所以，在这样的情境下，直接提前启动本科计划，势在必行。对于软件测试这个行业来讲，也渐渐从开始要求的大专转至本科起步，更加推进本科计划的实行，所以可能自己在工作领域投入的时间相对较少。</p>
<p>原本计划7月份把ISTQB的初级证书给考掉，但现在由于时间问题，决定推迟证书的考取，做一个权衡。再者就是专升本的费用比考证的费用高的太多了，都是自己打工的血汗钱，打水漂心疼，说实话真的舍不得，所以好好抓紧时间投入转本，不太擅长的英语，政治，要投入的时间太多，2020年的考试差不多还有140天左右，所以权衡后选择了升本。</p>
<p>从17年毕业后，第一个3年的时间已经被浪费掉了，从第二个3年开始，抓紧时间去学更多的技能，使自身能力更上一层楼，让自己变得更加值钱，自我能力提升是我第一个3年里踏入这个社会教会我的认知。自从今年疫情开始，我自己搭建博客，记录自己所有的经历，其实目的主要的就是3个：第一，目前从事的软件测试工作，希望自己能在IT领域有所自己的作为，事业有一定的成功，所有的知识面做一个备份，方便后续回顾复习；第二，更加方便自己今后谈的对象能更好的完全去了解我，因为博客里不仅有我自己喜欢的IT领域知识，还包含我生活中的点滴，相册，厨艺，生活态度；第三，我想把我自己会的东西，我自己的思维以及我自己的生活态度和擅长发现探索的人一起去分享，共同成长，这也算是我搭建博客的初衷。</p>
<p>但是目前经过一段时间下来发现，自己每天的时间越来越不够用，我发现我自己很忙，所有的时间被塞的满满的，工作日白天上班，晚上回来开始接触新的软件测试技术，自动化，编程，项目管理，一般晚上都会很晚才休息，一方面是习惯了这样的生活节奏，晚上更静，更有利于思考问题，要是稀里哗啦的再下一场雨，那就更妙了。另方面，算是一种焦虑吧，因为我想拿更高的工资，也就意味着我自己的价值要更高，技术水平要求就更高，会的东西要比别人更多，而现状就是别人会的我有些不会，别人不会的我也不会。时间过的贼快，都是有加速度的在跑，以前在学校时间单位撑死论天算了，但现在工作，不是论周，不是论月，也不论季，以年为单位的一直在偷偷的跑，一晃一年，一晃自己都快到奔三的尾程了，然而自己还不知不觉。</p>
<p>时间过的越快，自己的压力越大，身上目前没房，没车，没存款。生活在上海，2020年开始，经过疫情，我就想搞两件事，一是赚钱，二是找对象，就这两件，没想太多。花钱的地方贼多，赚钱太难；茫茫人海，女生太多，找到一个适合自己的女孩子，得花多少运气，所以我很珍惜爱我的人和我爱的人。未来身负200万左右的债，后几十年的生活一直给银行打工，想想都可怕，至今还没见过这么多的钱，没开过眼界。</p>
<p>生活不易，自我提升是王道；不畏将来，天分不够勤来凑。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>ISTQB CTFL证书考试之测试管理笔记（五）</title>
    <url>/2020/05/25/ISTQB%20CTFL%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95%E4%B9%8B%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-MsQXJDms" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="456658875" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、测试策略及其与测试方法的关系"><a href="#一、测试策略及其与测试方法的关系" class="headerlink" title="一、测试策略及其与测试方法的关系"></a><strong>一、测试策略及其与测试方法的关系</strong></h3><p>测试策略提供测试过程的一般描述，通常是在产品或组织级别上的。常见的测试策略类型包括：</p>
<h4 id="1-分析型"><a href="#1-分析型" class="headerlink" title="1.分析型"></a><strong>1.分析型</strong></h4><p>此类测试策略基于对某些因素（例如，需求或风险）的分析。基于风险的测试是分析型方法的一个示例，这里是根据风险级别设计测试并确定测试的优先级。</p>
<h4 id="2-基于模型"><a href="#2-基于模型" class="headerlink" title="2.基于模型"></a><strong>2.基于模型</strong></h4><p>在这种类型的测试策略中，测试是基于产品的某些需求方面的模型设计的，例如功能、业务流程、内部结构、或非功能特性（例如，可靠性）。此类模型的示例包括业务过程模型、状态模型和可靠性增长模型。</p>
<h4 id="3-方法论型"><a href="#3-方法论型" class="headerlink" title="3.方法论型"></a><strong>3.方法论型</strong></h4><p>此类测试策略依赖于系统地使用一些预定义的测试集或测试条件，例如常见或可能缺陷类型的分类、重要质量特性列表或公司范围内的用于移动应用或网页的外观和感受标准。</p>
<h4 id="4-符合流程（或符合标准）"><a href="#4-符合流程（或符合标准）" class="headerlink" title="4.符合流程（或符合标准）"></a><strong>4.符合流程（或符合标准）</strong></h4><p>此类测试策略是基于外部规则和标准来开展测试，包括分析、设计和实施测试，例如行业特定标准、过程文档、严格标识和使用的测试依据，或由组织制定或针对组织制定的任何过程或标准。</p>
<h4 id="5-指导型（或咨询）"><a href="#5-指导型（或咨询）" class="headerlink" title="5.指导型（或咨询）"></a><strong>5.指导型（或咨询）</strong></h4><p>此类测试策略主要由利益相关方、业务领域专家或技术专家的建议、指导或指示驱动，这些利益相关方、业务领域专家或技术专家可能来自测试团队之外，甚至是在组织之外。 </p>
<h4 id="6-规避回归型"><a href="#6-规避回归型" class="headerlink" title="6.规避回归型"></a><strong>6.规避回归型</strong></h4><p>这种类型的测试策略的动机是希望避免现有功能的回归。此测试策略包括重用现有测试件（尤其是测试用例和测试数据）、回归测试的广泛自动化以及标准测试套件。</p>
<h4 id="7-应对型"><a href="#7-应对型" class="headerlink" title="7.应对型"></a><strong>7.应对型</strong></h4><p>在这种类型的测试策略中，测试被动应对被测组件或系统以及测试执行期间发生的事件，而不是预先计划（如前面的策略所示）。测试经过设计和实施，并可能立即执行以响应从先前测试结果中获得的知识，探索性测试是应对型策略中常用的技术。通常通过组合这些测试策略的类型来创建适当的测试策略。例如，基于风险的测试（分析型策略）可以与探索性测试（应对型策略）相结合；它们相互补充，并且在一起使用时可以实现更有效的测试。</p>
<p>虽然测试策略提供了测试过程的一般描述，而测试方法是为特定项目或版本定制的测试策略。测试方法是选择测试技术、测试级别和测试类型，以及定义入口准则和出口准则（或分别是就绪的定义和完成的定义）的起点。策略的定制是基于项目的复杂性和目标、正在开发的产品类型和产品风险分析相关的决策。所选方法取决于项目背景，并可能考虑诸如风险、安全、可用资源和技能、技术、系统性质（例如，定制与 COTS）、测试目标和法规等因素。</p>
<h3 id="二、两大常见的测试估算方法"><a href="#二、两大常见的测试估算方法" class="headerlink" title="二、两大常见的测试估算方法"></a><strong>二、两大常见的测试估算方法</strong></h3><p>在目前整个测试的过程中，有许多估算方法用于确定适当测试所需的工作量。两种最常用的方法是：</p>
<p><strong>1.基于度量的方法：根据先前类似项目的度量，或基于典型值来估算测试工作量</strong></p>
<p><strong>2.基于专家的方法：根据测试任务负责人或专家的经验来估算测试工作量</strong></p>
<p>例如，在敏捷开发中，燃尽图是基于度量的方法的示例，当获取和确定剩余工作量并报告，然后与团队速度（敏捷项目中生产力的度量）一起使用，以确定团队在下一次迭代中可以完成的工作量；而计划扑克是基于专家的方法的一个例子，团队成员根据他们的经验估算出交付一个特征的工作量。</p>
<p>在顺序开发模型的项目中，缺陷移除模型是基于度量方法的示例，其中获得和报告了缺陷的数量和移除它们所需的时间，然后为未来估算类似性质的项目提供了基础；而宽带德尔菲估算技术是基于专家的方法的一个例子，其中专家组根据他们的经验提供估算。</p>
<h3 id="三、常见的测试度量以及收集的目的"><a href="#三、常见的测试度量以及收集的目的" class="headerlink" title="三、常见的测试度量以及收集的目的"></a><strong>三、常见的测试度量以及收集的目的</strong></h3><p><strong>常见的测试度量包括：</strong></p>
<p>1.在测试用例准备中，计划工作已完成的百分比（或计划测试用例已实施的百分比）</p>
<p>2.在测试环境准备中，计划工作已完成的百分比</p>
<p>3.测试用例执行（例如，测试用例运行&#x2F;未运行、测试用例通过&#x2F;失败，和&#x2F;或测试条件通过&#x2F;失败的数量）</p>
<p>4.缺陷信息（例如：缺陷密度、发现和修复的缺陷、失效率和确认测试结果）</p>
<p>5.需求、用户故事、验收准则、风险，或代码的测试覆盖</p>
<p>6.任务完成、资源分配和使用以及工作量</p>
<p>7.测试成本，包括与发现下一个缺陷的成本与收益，或执行下一个测试的收益相比的成本</p>
<p><strong>收集测试度量的目的：</strong></p>
<p>最根本的目的就是为了评估，主要是评估一下几方面</p>
<p>1.与计划的时间表和预算对应的进展</p>
<p>2.测试对象的当前质量</p>
<p>3.测试方法的充分性</p>
<p>4.与目标相关的测试活动的有效性</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>ISTQB CTFL证书考试之测试技术笔记（四）</title>
    <url>/2020/05/24/ISTQB%20CTFL%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95%E4%B9%8B%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-RPpjBFxE" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="442837913" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p><strong>测试技术部分涉及的理论性知识，范围特别的广泛，大脑理解的过程中需要有一个很清晰的目录结构框架，便于记忆，建议使用思维导图拎清骨架。其次，它是整个软件测试理论过程中所需逻辑感最强的一部分，什么是测试类型，包含有哪些？什么是测试方法，包含有哪些？测试方法，在实际测试过程中有哪些运用的场景？</strong></p>
<p><img src="https://s1.ax1x.com/2020/05/24/tS6wZj.png"></p>
<h3 id="一、专业术语中英对照表"><a href="#一、专业术语中英对照表" class="headerlink" title="一、专业术语中英对照表"></a><strong>一、专业术语中英对照表</strong></h3><table>
<thead>
<tr>
<th>中文</th>
<th>英文</th>
</tr>
</thead>
<tbody><tr>
<td>黑盒测试技术</td>
<td>black-box test technique</td>
</tr>
<tr>
<td>边界值分析</td>
<td>boundary value analysis</td>
</tr>
<tr>
<td>基于检查表的测试</td>
<td>checklist-based testing</td>
</tr>
<tr>
<td>覆盖</td>
<td>coverage</td>
</tr>
<tr>
<td>判定覆盖</td>
<td>decision coverage</td>
</tr>
<tr>
<td>判定表测试</td>
<td>decision table testing</td>
</tr>
<tr>
<td>错误推测</td>
<td>error guessing</td>
</tr>
<tr>
<td>等价类划分</td>
<td>equivalence partitioning</td>
</tr>
<tr>
<td>基于经验的测试技术</td>
<td>experience-based test technique</td>
</tr>
<tr>
<td>探索性测试</td>
<td>exploratory testing</td>
</tr>
<tr>
<td>状态转换测试</td>
<td>state transition testing</td>
</tr>
<tr>
<td>语句覆盖</td>
<td>statement coverage</td>
</tr>
<tr>
<td>测试技术</td>
<td>test technique</td>
</tr>
<tr>
<td>用例测试</td>
<td>use case testing</td>
</tr>
<tr>
<td>白盒测试技术</td>
<td>white-box test technique</td>
</tr>
</tbody></table>
<h3 id="二、测试技术的分类及测试类型"><a href="#二、测试技术的分类及测试类型" class="headerlink" title="二、测试技术的分类及测试类型"></a><strong>二、测试技术的分类及测试类型</strong></h3><p>理论是理论，实操是实操，实操是基于理论基础之上而作的一系列的动作，唯有实践才是检验真理的标准。在实际测试过程中，会遇到形形色色的专业名词测试，其实质有很多的相仿，只不过是换个叫法，再者，测试实操有些部分是理论无法考虑到的。现有实操，目前主要对测试技术的划分有：黑盒测试、白盒测试及灰盒测试，老成一点的还有基于经验的测试。</p>
<h4 id="1-黑盒测试（测试技术分类）"><a href="#1-黑盒测试（测试技术分类）" class="headerlink" title="1.黑盒测试（测试技术分类）"></a><strong>1.黑盒测试（测试技术分类）</strong></h4><p>基于行为或者规格的测试，通过对适当测试依据的分析（例如：正式需求文档、需求规格说明、用例、用户故事或业务流程），这些技术适用于功能和非功能测试。黑盒测试技术关注在测试对象的输入和输出，而不考虑其内部结构。</p>
<p>其特点包含但不局限于以下几点：①.测试条件、测试用例和测试数据的获取源自测试依据，可能包括软件需求、规格说明、用例和用户故事；②.测试用例可用于检查需求和需求实现之间的差距，以及需求本身的错误；③.覆盖度量是根据在测试依据中已测试的项和应用到测试依据的技术</p>
<h5 id="A-功能测试（测试类型）"><a href="#A-功能测试（测试类型）" class="headerlink" title="A.功能测试（测试类型）"></a><strong>A.功能测试（测试类型）</strong></h5><p>只需考虑需要测试的各个功能，不需要考虑整个软件的内部结构及代码。一般从软件产品的界面、架构出发，按照需求编写出来的测试用例，输入数据在预期结果和实际结果之间进行评测，进而提出更加使产品达到用户使用的要求。</p>
<h5 id="B-性能测试（测试类型）"><a href="#B-性能测试（测试类型）" class="headerlink" title="B.性能测试（测试类型）"></a><strong>B.性能测试（测试类型）</strong></h5><p>通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。</p>
<h6 id="a-负载测试（测试类型）"><a href="#a-负载测试（测试类型）" class="headerlink" title="a.负载测试（测试类型）"></a><strong>a.负载测试（测试类型）</strong></h6><p>不限制软件的运行资源，测试软件的数据吞吐量上限，以发现设计上的错误或验证系统的负载能力。在这种测试中，将使测试对象承担不同的工作量，以评测和评估测试对象在不同工作量条件下的性能行为，以及持续正常运行的能力。</p>
<p>负载测试的目标是确定并确保系统在超出最大预期工作量的情况下仍能正常运行。此外，负载测试还要评估性能特征，例如：响应时间、事务处理速率和其他与时间相关的方面。</p>
<p>简而言之：通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。</p>
<h6 id="b-压力测试（测试类型）"><a href="#b-压力测试（测试类型）" class="headerlink" title="b.压力测试（测试类型）"></a><strong>b.压力测试（测试类型）</strong></h6><p>通过给软件不断加压，强制其在极限的情况下运行，观察它可以运行到何种程度，从而发现性能缺陷，通过搭建与实际环境相似的测试环境，通过测试程序在同一时间内或某一段时间内，向系统发送预期数量的交易请求、测试系统在不同压力情况下的效率状况，以及系统可以承受的压力情况。然后做针对性的测试与分析，找到影响系统性能的瓶颈，评估系统在实际使用环境下的效率情况，评价系统性能以及判断是否需要对应用系统进行优化处理或结构调整。并对系统资源进行优化。</p>
<p>软件系统的负载压力是指系统在某种指定软件、硬件及网络环境下承受的流量，例如并发用户数、持续运行时间、数据量等。其中并发用户数是负载压力的重要指标。</p>
<p>简而言之：压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。</p>
<h6 id="负载测试和压力测试的区别定义"><a href="#负载测试和压力测试的区别定义" class="headerlink" title="负载测试和压力测试的区别定义"></a>负载测试和压力测试的区别定义</h6><p><strong>详细说明：</strong></p>
<p>负载测试是模拟实际软件系统所承受的负载条件的系统负荷，通过不断加载（如逐渐增加模拟用户的数量）或其它加载方式来观察不同负载下系统的响应时间和数据吞吐量、系统占用的资源（如CPU、内存）等，以检验系统的行为和特性，以发现系统可能存在的性能瓶颈、内存泄漏、不能实时同步等问题。负载测试更多地体现了一种方法或一种技术。</p>
<p>压力测试是在强负载（大数据量、大量并发用户等）下的测试，查看应用系统在峰值使用情况下操作行为，从而有效地发现系统的某项功能隐患、系统是否具有良好的容错能力和可恢复能力。压力测试分为高负载下的长时间（如24小时以上）的稳定性压力测试和极限负载情况下导致系统崩溃的破坏性压力测试。</p>
<p>压力测试可以被看作是负载测试的一种，即高负载下的负载测试，或者说压力测试采用负载测试技术。通过压力测试，可以更快地发现内存泄漏问题，还可以更快地发现影响系统稳定性的问题。例如，在正常负载情况下，某些功能不能正常使用或系统出错的概率比较低，可能一个月只出现一次，但在高负载（压力测试）下，可能一天就出现，从而发现有缺陷的功能或其它系统问题。通过负载测试，可以证明这一点，某个电子商务网站的订单提交功能，在10个并发用户时错误率是零，在50个并发用户时错误率是1%，而在200个并发用户时错误率是20%。</p>
<p>负载测试是为了发现系统的性能问题，负载测试需要通过系统性能特性或行为来发现问题，从而为性能改进提供帮助，从这个意义看，负载测试可以看作性能测试的一部分。但它们两者的目的是不一样的，负载测试是为了发现缺陷，而性能测试是为了获取性能指标。因为性能测试过程中，也可以不调整负载，而是在同样负载情况下改变系统的结构、改变算法、改变硬件配置等等来得到性能指标数据，从这个意义看，负载测试可以看作是性能测试所用的一种技术，即性能测试使用负载测试的技术、使用负载测试的工具。性能测试要获得在不同的负载情况下的性能指标数据。</p>
<p>通过负载测试和压力测试都可以获得系统正常工作时的极限负载或最大容量。容量测试，自然也是采用负载测试技术来实现，而在破坏性的压力测试中，容量的确可以看作是一种副产品——间接结果。</p>
<p><strong>简而言之：</strong></p>
<p>负载测试是通过改变系统负载方式、增加负载等来发现系统中所存在的性能问题。负载测试是一种测试方法，可以为性能测试、压力测试所采用。负载测试的加载方式也有很多种，可以根据测试需要来选择。</p>
<p>性能测试是为获取或验证系统性能指标而进行测试。多数情况下，性能测试会在不同负载情况下进行。</p>
<p>压力测试通常是在高负载情况下来对系统的稳定性进行测试，更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等。</p>
<h5 id="C-可靠性测试（测试类型）"><a href="#C-可靠性测试（测试类型）" class="headerlink" title="C.可靠性测试（测试类型）"></a><strong>C.可靠性测试（测试类型）</strong></h5><p>为了评估产品在规定的寿命期间内，在预期的使用、运输或储存等所有环境下，保持功能可靠性而进行的活动。将软件暴露在自然的或人工的环境条件下经受其作用，以评价软件在实际使用、运输和储存的环境条件下的性能，并分析研究环境因素的影响程度及其作用机理。</p>
<h4 id="2-白盒测试（测试技术分类）"><a href="#2-白盒测试（测试技术分类）" class="headerlink" title="2.白盒测试（测试技术分类）"></a><strong>2.白盒测试（测试技术分类）</strong></h4><p>依据被测软件分析程序内部构造，并根据内部构造设计用例，来对内部控制流程进行测试，可完全不顾程序的整体功能实现情况，通常又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。</p>
<p>“白盒”法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。”白盒”法是穷举路径测试。在使用这一方案时，测试者必须检查程序的内部结构，从检查程序的逻辑着手，得出测试数据。</p>
<h4 id="3-灰盒测试（测试技术分类）"><a href="#3-灰盒测试（测试技术分类）" class="headerlink" title="3.灰盒测试（测试技术分类）"></a><strong>3.灰盒测试（测试技术分类）</strong></h4><p>介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。灰盒测试不像白盒测试那样详细、完整，但又比黑盒测试更关注程序的内部逻辑，常常是通过一些表征性的现象、事件、标志来判断内部的运行状态，通常与web服务应用一起使用。</p>
<p>灰盒测试相对白盒测试更加难以发现并解决潜在问题，尤其在一个单一的应用中，白盒测试的内部细节可以完全掌握。 灰盒测试结合了白盒测试和黑盒测试的要素。它考虑了用户端、特定的系统知识和操作环境。它在系统组件的协同性环境中评价应用软件的设计。</p>
<p>灰盒测试由方法和工具组成，这些方法和工具取材于应用程序的内部知识和与之交互的环境，能够用于黑盒测试以增强测试效率、错误发现和错误分析的效率。</p>
<h3 id="三、常见测试方法"><a href="#三、常见测试方法" class="headerlink" title="三、常见测试方法"></a><strong>三、常见测试方法</strong></h3><h4 id="1-黑盒测试（测试技术分类）-1"><a href="#1-黑盒测试（测试技术分类）-1" class="headerlink" title="1.黑盒测试（测试技术分类）"></a><strong>1.黑盒测试（测试技术分类）</strong></h4><h5 id="A-等价类划分（测试方法）"><a href="#A-等价类划分（测试方法）" class="headerlink" title="A.等价类划分（测试方法）"></a><strong>A.等价类划分（测试方法）</strong></h5><p>等价类划分法是将程序所有可能的输入数据（有效的和无效的）划分成若干个等价类。然后从每个部分中选取具有代表性的数据当做测试用例进行合理的分类，测试用例由有效等价类和无效等价类的代表组成，从而保证测试用例具有完整性和代表性。利用这一方法设计测试用例可以不考虑程序的内部结构，以需求规格说明书为依据，选择适当的典型子集，认真分析和推敲说明书的各项需求，特别是功能需求，尽可能多地发现错误。等价类划分法是一种系统性的确定要输入的测试条件的方法。</p>
<p>由于等价类是在需求规格说明书的基础上进行划分的，并且等价类划分不仅可以用来确定测试用例中的数据的输入输出的精确取值范围，也可以用来准备中间值、状态和与时间相关的数据以及接口参数等，所以等价类可以用在系统测试、集成测试和组件测试中，在有明确的条件和限制的情况下，利用等价类划分技术可以设计出完备的测试用例。</p>
<h6 id="a-有效等价类"><a href="#a-有效等价类" class="headerlink" title="a.有效等价类"></a><strong>a.有效等价类</strong></h6><p>有效等价类指对于程序规格说明来说，是合理的、有意义的输入数据构成的集合。利用有效等价类可以检验程序是否实现了规格说明预先规定的功能和性能。有效等价类可以是一个，也可以是多个，根据系统的输入域划分若干部分，然后从每个部分中选取少数有代表性数据当做数据测试的测试用例，等价类是输入域的集合。</p>
<h6 id="b-无效等价类"><a href="#b-无效等价类" class="headerlink" title="b.无效等价类"></a><strong>b.无效等价类</strong></h6><p>无效等价类是指对于软件规格说明而言，没有意义的、不合理的输入数据集合。利用无效等价类，可以找出程序异常说明情况，检查程序的功能和性能的实现是否有不符合规格说明要求的地方。</p>
<p><strong>Example</strong></p>
<p>x&gt;1<br>有效等价类：x&gt;1  x&#x3D;2<br>无效等价类：x&lt;&#x3D;1,空，空格，字母，特殊字符……</p>
<h5 id="B-边界值分析（测试方法）"><a href="#B-边界值分析（测试方法）" class="headerlink" title="B.边界值分析（测试方法）"></a><strong>B.边界值分析（测试方法）</strong></h5><p>边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法，通常是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。在长期的测试工作中会发现，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。于此同时在边界值分析的过程中还经常会听到<strong>上点、内点</strong>及<strong>离点</strong>。</p>
<h6 id="a-上点"><a href="#a-上点" class="headerlink" title="a.上点"></a><strong>a.上点</strong></h6><p>指边界上的点，无论此时的域是开区间还是闭区间。<strong>如果是开区间的话，上点就在域外，闭区间的话，上点就在域内。</strong></p>
<h6 id="b-内点"><a href="#b-内点" class="headerlink" title="b.内点"></a><strong>b.内点</strong></h6><p>域内的任意点都是内点</p>
<h6 id="c-离点"><a href="#c-离点" class="headerlink" title="c.离点"></a><strong>c.离点</strong></h6><p>指离上点最近的点，这里跟闭区间还是开区间有关系。<strong>如果是开区间的话，离点就在域内，闭区间的话，离点就在域外</strong>。</p>
<p><strong>Example</strong></p>
<p>正整数值域[66,88]</p>
<p>上点：66，88，都是在域内；内点：域内得任意点；离点：65，89</p>
<p>正整数值域(66,88]</p>
<p>上点：66，88，其中一个是域内，一个是域外；内点：域内的任意点；离点是：67，89</p>
<p>正整数值域(66,88)</p>
<p>上点:66，88，都是在域外，内点：域内的任意点；离点：67，87</p>
<h5 id="C-判定表（测试方法）"><a href="#C-判定表（测试方法）" class="headerlink" title="C.判定表（测试方法）"></a><strong>C.判定表（测试方法）</strong></h5><p>判定表是另一种表达逻辑判断的工具。与结构化语言和判断树相比，判断表的优点是能把所有条件组合充分地表达出来；其缺点是判定表的建立过程较烦杂，且表达方式不如前两种简便。判定表在用于知识表达中，有许多其他方式所达不到的作用，能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用判定表能够设计出完整的测试用例集合。</p>
<p>所涉及的4个概念性名词：<strong>条件桩，条件项，动作桩，动作项</strong>（结合Example作说明）</p>
<h6 id="a-条件桩"><a href="#a-条件桩" class="headerlink" title="a.条件桩"></a><strong>a.条件桩</strong></h6><p>在左上部，列出了问题的所有条件，通常认为列出的条件的次序无关紧要。</p>
<h6 id="b-动作桩"><a href="#b-动作桩" class="headerlink" title="b.动作桩"></a><strong>b.动作桩</strong></h6><p>在左下部，列出了问题规定可能采取的操作，这些操作的排列顺序没有约束。</p>
<h6 id="c-条件项"><a href="#c-条件项" class="headerlink" title="c.条件项"></a><strong>c.条件项</strong></h6><p>在右上部，列出针对它左列条件的取值，在所有可能情况下的真假值。</p>
<h6 id="d-动作项"><a href="#d-动作项" class="headerlink" title="d.动作项"></a><strong>d.动作项</strong></h6><p>在右下部，列出在条件项的各种取值情况下应该采取的动作。</p>
<p><strong>Example</strong></p>
<p><img src="https://s1.ax1x.com/2020/05/24/YzAQdU.png"></p>
<p>规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。显然，判定表中列出多少组条件取值，也就有多少条规则，既条件项和动作项有多少列。<br>化简：就是规则合并有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系。</p>
<p><strong>化简示范</strong></p>
<p>如下图左端，两规则动作项一样，条件项类似，在1、2条件项分别取Y、N时，无论条件3取何值，都执行同一操作。即要执行的动作与条件3无关，于是可合并。“－”表示与取值无关。</p>
<p><img src="https://s1.ax1x.com/2020/05/24/YzyrSU.png"></p>
<h5 id="D-因果图（测试方法）"><a href="#D-因果图（测试方法）" class="headerlink" title="D.因果图（测试方法）"></a><strong>D.因果图（测试方法）</strong></h5><p>因果图法是一种适合于描述对于多种输入条件组合的测试方法，根据输入条件的组合、约束关系和输出条件的因果关系，分析输入条件的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件涉及的各种组合情况。因果图法一般和判定表结合使用，通过映射同时发生相互影响的多个输入来确定判定条件。因果图法最终生成的就是判定表，它适合于检查程序输入条件的各种组合情况。采用因果图法能帮助我们按照一定的步骤选择一组高效的测试用例，同时还能指出程序规范中存在什么问题，鉴别和制作因果图。<br>因果图法着重分析输入条件的各种组合，每种组合条件就是“因”，它必然有一个输出的结果，这就是“果”。</p>
<p><strong>基本符号</strong></p>
<p><img src="https://s1.ax1x.com/2020/05/24/YzcEbd.png"></p>
<p><strong>约束符号</strong></p>
<p><img src="https://s1.ax1x.com/2020/05/24/YzcLJP.png"></p>
<p><strong>Example</strong></p>
<p>有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：若投入5角钱或1元钱的硬币，押下【橙汁】或【啤酒】的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示【零钱找完】的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示【零钱找完】的红灯灭，在送出饮料的同时退还5角硬币。</p>
<p>列出原因和结果<br>原因：<br>1.售货机有零钱找</p>
<p>2.投入1元硬币</p>
<p>3.投入5角硬币</p>
<p>4.押下橙汁按钮</p>
<p>5.押下啤酒按钮</p>
<p>结果：<br>21.售货机【零钱找完】灯亮  </p>
<p>22.退还1元硬币</p>
<p>23.退还5角硬币  </p>
<p>24.送出橙汁饮料</p>
<p>25.送出啤酒饮料</p>
<p>画出因果图，如图所示。所有原因结点列在左边，所有结果结点列在右边。建立中间结点，表示处理的中间状态。</p>
<p>中间结点：</p>
<p>11.投入1元硬币且押下饮料按钮</p>
<p>12.押下〖橙汁〗或〖啤酒〗的按钮</p>
<p>13.应当找5角零钱并且售货机有零钱找</p>
<p>14.钱已付清</p>
<p><img src="https://s1.ax1x.com/2020/05/24/Yzgjt1.png"></p>
<h5 id="E-场景分析（测试方法）"><a href="#E-场景分析（测试方法）" class="headerlink" title="E.场景分析（测试方法）"></a><strong>E.场景分析（测试方法）</strong></h5><p>通过运用场景来对系统的功能点或业务流程的描述，从而提高测试效果的一种方法。用例场景来测试需求是指模拟特定场景边界发生的事情，通过事件来触发某个动作的发生，观察事件的最终结果，从而用来发现需求中存在的问题。我们通常以正常的用例场景分析开始，然后再着手其他的场景分析。场景法一般包含基本流和备用流，从一个流程开始，通过描述经过的路径来确定的过程，经过遍历所有的基本流和备用流来完成整个场景。场景主要包括4种主要的类型：<strong>正常的用例场景，备选的用例场景，异常的用例场景，假定推测的场景</strong>。</p>
<p><img src="https://s1.ax1x.com/2020/05/24/YzRzLD.png"></p>
<p><strong>Example</strong></p>
<p>以ATM机取款为例</p>
<p><img src="https://s1.ax1x.com/2020/05/24/YzWjts.png"></p>
<p><img src="https://s1.ax1x.com/2020/05/24/Yzh1MV.png"></p>
<h5 id="F-正交试验（测试方法）"><a href="#F-正交试验（测试方法）" class="headerlink" title="F.正交试验（测试方法）"></a><strong>F.正交试验（测试方法）</strong></h5><p>正交试验设计是研究多因素多水平的又一种设计方法，它是根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了“均匀分散，齐整可比”的特点，正交试验设计是分式析因设计的主要方法，是一种高效率、快速、经济的实验设计方法。</p>
<p>1.提取功能说明，构造因子–状态表</p>
<p>把影响实验指标的条件称为因子，而影响实验因子的条件叫因子的状态。利用正交实验设计方法来设计测试用例时，首先要根据被测试软件的规格说明书找出影响其功能实现的操作对象和外部因素，把他们当作因子（动作项），而把各个因子的取值（条件项）当作状态。对软件需求规格说明中的功能要求进行划分，把整体的概要性的功能要求进行层层分解与展开，分解成具体的有相对独立性的基本的功能要求。这样就可以把被测试软件中所有的因子都确定下来，并为确定个因子的权值提供参考的依据。确定因子与状态是设计测试用例的关键，因此要求尽可能全面的正确的确定取值，以确保测试用例的设计作到完整与有效。</p>
<p>2.加权筛选，生成因素分析表</p>
<p>对因子与状态的选择可按其重要程度分别加权，可根据各个因子及状态的作用大小，出现频率的大小以及测试的需要，确定权值的大小。</p>
<p>3.利用正交表构造测试数据集</p>
<p>正交表的推导依据Galois理论，利用正交实验设计方法设计测试用例，比使用等价类划分，边界值分析，因果图等方法有以下优点：①.节省测试工作工时；②.可控制生成的测试用例数量；③.测试用例具有一定的覆盖率。</p>
<p><img src="https://s1.ax1x.com/2020/05/24/YzHhtO.jpg"></p>
<h5 id="G-功能图分析（测试方法）"><a href="#G-功能图分析（测试方法）" class="headerlink" title="G.功能图分析（测试方法）"></a><strong>G.功能图分析（测试方法）</strong></h5><p>一个程序的功能说明通常由动态说明和静态说明组成，动态说明描述了输入数据的次序或转移的次序。静态说明描述了输入条件与输出条件之间的对应关系，对于较复杂的程序，由于存在大量的组合情况。因此仅用静态说明组成的规格说明对于测试来说往往是不够的，必须用动态说明来补充功能说明。功能图方法是用功能图FD形式化地表示程序的功能说明，并机械地生成功能图的测试用例。功能图模型由状态迁移图和逻辑功能模型构成，状态迁移图用于表示输入数据序列以及相应的输出数据。在状态迁移图中，由输入数据和当前状态决定输出数据和后续状态。逻辑功能模型用于表示在状态中输入条件和输出条件之间的对应关系。逻辑功能模型只适合于描述静态说明，输出数据仅由输入数据决定。测试用例则是由测试中经过的一系列状态和在每个状态中必须依靠输入&#x2F;输出数据满足的一对条件组成。功能图方法其实是是一种黑盒白盒混合用例设计方法。</p>
<p>功能图由状态迁移图和布尔函数组成，状态迁移图用状态和迁移来描述。一个状态指出数据输入的位置（或时间），而迁移则指明状态的改变，同时要依靠判定表或因果图表示的逻辑功能，由于在实操过程中更多接触的状态迁移图，故布尔函数渐渐被淡忘，功能图分析久而久之被渐渐直接说成状态迁移图。</p>
<h4 id="2-白盒测试（测试技术分类）-1"><a href="#2-白盒测试（测试技术分类）-1" class="headerlink" title="2.白盒测试（测试技术分类）"></a><strong>2.白盒测试（测试技术分类）</strong></h4><h5 id="A-静态分析（测试方法）"><a href="#A-静态分析（测试方法）" class="headerlink" title="A.静态分析（测试方法）"></a><strong>A.静态分析（测试方法）</strong></h5><h6 id="a-控制流分析"><a href="#a-控制流分析" class="headerlink" title="a.控制流分析"></a><strong>a.控制流分析</strong></h6><p>控制流分析，是一种确认程序控制流程的静态代码分析技术，控制流程会以控制流图来表示。对于函数编程语言及面向对象程式设计，控制流分析都是指计算控制流程的算法。</p>
<h6 id="b-数据流分析"><a href="#b-数据流分析" class="headerlink" title="b.数据流分析"></a><strong>b.数据流分析</strong></h6><p>数据流分析是一项编译时使用的技术，它能从程序代码中收集程序的语义信息，并通过代数的方法在编译时确定变量的定义和使用。通过数据流分析，可以不必实际运行程序就能够发现程序运行时的行为，这样可以帮助大家理解程序。数据流分析被用于解决编译优化、程序验证、调试、测试、并行、向量化和片行编程环境等问题。</p>
<h6 id="c-信息流分析"><a href="#c-信息流分析" class="headerlink" title="c.信息流分析"></a><strong>c.信息流分析</strong></h6><p>信息流分析主要用在验证程序变量间信息的传输遵循保密要求，其主要分析输出值跟输入值之间的影响关系。</p>
<h5 id="B-动态分析（测试方法）"><a href="#B-动态分析（测试方法）" class="headerlink" title="B.动态分析（测试方法）"></a><strong>B.动态分析（测试方法）</strong></h5><p><strong>Example</strong></p>
<p>先理解一下名词各自的示范样本</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tS3SGq.png"></p>
<p><img src="https://s1.ax1x.com/2020/05/24/tS3EdJ.png"></p>
<h6 id="a-语句覆盖"><a href="#a-语句覆盖" class="headerlink" title="a.语句覆盖"></a><strong>a.语句覆盖</strong></h6><p>设计一套测试让被测对象中每条语句至少执行一次 </p>
<p><img src="https://s1.ax1x.com/2020/05/24/tSU09H.jpg"></p>
<p>使用此准则测试程序，只需要遍历路径ace，便将程序中的所有语句便都执行了一次。生成的用例及其遍历路径如下：</p>
<blockquote>
<p>A&#x3D;2，B&#x3D;0，X&#x3D;4               <em><code>ace</code></em></p>
</blockquote>
<p><strong>缺点：语句覆盖是“最弱的覆盖”，它难以发现程序中的错误。</strong></p>
<p><strong>①程序中存在一条x的值未发生改变的路径abd没有测试。</strong></p>
<p><strong>②它无法发现判定的错误，比如第一个判定条件也许应该是“或”，而不是“与”。</strong></p>
<p><strong>③无法发现条件的错误，比如第二个判断中的条件X&gt;1，也许事实上应该是X&gt;0。</strong></p>
<h6 id="b-判定覆盖（分支覆盖）"><a href="#b-判定覆盖（分支覆盖）" class="headerlink" title="b.判定覆盖（分支覆盖）"></a><strong>b.判定覆盖（分支覆盖）</strong></h6><p>设计一套测试让被测对象中每个判定的所有可能结果至少出现一次</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tSU09H.jpg"></p>
<p>使用此准则测试程序，只需要涵盖路径ace和abd，或涵盖路径acd和abe，就可以使得两个判定为“真”和为“假”的分支都执行一次。如果选择后一种情况，生成的用例及其遍历的路径如下：</p>
<blockquote>
<p>A&#x3D;3，B&#x3D;0，X&#x3D;3                <em><code>acd</code></em><br>A&#x3D;2，B&#x3D;1，X&#x3D;1                <em><code>abe</code></em></p>
</blockquote>
<p>我们仅有50%的可能性遍历到X值未发生改变的路径，即，只有我们选择涵盖路径ace和abd的情况，而不是涵盖路径acd和abe时。对应的测试用例如下：</p>
<blockquote>
<p>A&#x3D;2，B&#x3D;0，X&#x3D;2                <em><code>ace</code></em><br>A&#x3D;3，B&#x3D;1，X&#x3D;1                <em><code>abd</code></em></p>
</blockquote>
<p><strong>缺点：这两组测试用例都存在同一个问题：当判定由多个条件组合构成时，它未必能发现每个条件的错误。如果第二个判定把条件X&gt;1错误的写成了X&lt;1，我们设计的测试用例仍然无法找出这个错误。</strong></p>
<h6 id="c-条件覆盖"><a href="#c-条件覆盖" class="headerlink" title="c.条件覆盖"></a><strong>c.条件覆盖</strong></h6><p>设计一套测试让被测对象中每个条件的所有可能结果至少执行一次</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tSU09H.jpg"></p>
<p>第一个判断的所有条件的可能取值情况是A&gt;1或A≤1，B&#x3D;0或B≠0。</p>
<p>第二个判断的所有条件可能的取值情况为A&#x3D;2或A≠2，X&gt;1或X≤1。</p>
<p>生成的用例及其遍历的路径如下所示：</p>
<blockquote>
<p>A&#x3D;1，B&#x3D;0，X&#x3D;3                <em><code>abe</code></em><br>A&#x3D;2，B&#x3D;1，X&#x3D;1                <em><code>abe</code></em></p>
</blockquote>
<p><strong>缺点：条件覆盖并不一定总能覆盖全部分支。测试用例虽然满足了条件覆盖准则，但是只涵盖了程序的路径abe。但是，条件覆盖还是要比判定覆盖强一些，因为条件覆盖可能会使判断中各个条件的结果都取“真”或着取“假”，而判定覆盖却做不到这一点。</strong></p>
<h6 id="d-判定-条件覆盖"><a href="#d-判定-条件覆盖" class="headerlink" title="d.判定&#x2F;条件覆盖"></a><strong>d.判定&#x2F;条件覆盖</strong></h6><p>设计一套测试让被测对象一个判定中的每个条件的所有可能结果至少执行一次，并且每个判断本身的所有可能结果至少执行一次</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tSU09H.jpg"></p>
<p>判定&#x2F;条件覆盖，既要考虑到单个判定中每个条件的可能情况（A&gt;1或A≤1，B&#x3D;0或B≠0，A&#x3D;2或A≠2，X&gt;1或X≤1），也要考虑到每个判定的可能情况（路径ace和abd，或路径acd和abe）。用例及其遍历的路径如下所示：</p>
<blockquote>
<p>A&#x3D;2，B&#x3D;0，X&#x3D;4                <em><code>ace</code></em><br>A&#x3D;1，B&#x3D;1，X&#x3D;1                <em><code>abd</code></em></p>
</blockquote>
<p><strong>缺点：条件覆盖和判定&#x2F;条件覆盖不一定会发现逻辑表达式中的错误。尽管看上去所有条件的所有结果似乎都执行到了，但由于有些条件会屏蔽掉后面的条件，并不一定能全部执行得到，例如上述</strong></p>
<p><strong>测试用例①满足了条件A&#x3D;2后，就不再执行对条件X&gt;1的判断；</strong></p>
<p><strong>测试用例②中不满足条件A&gt;1后，就不再执行对条件B&#x3D;0的判断。</strong></p>
<h6 id="e-多重条件覆盖（组合覆盖）"><a href="#e-多重条件覆盖（组合覆盖）" class="headerlink" title="e.多重条件覆盖（组合覆盖）"></a><strong>e.多重条件覆盖（组合覆盖）</strong></h6><p>设计一套测试让被测对象中每个判定中的所有可能的条件结果的组合，以及所有的入口点都至少执行一次。（注意“可能”二字，因为有些组合的情况难以生成，根据实际情况而定）</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tSU09H.jpg"></p>
<p>满足多重条件覆盖准则的测试用例，必须覆盖以下8种组合：</p>
<table>
<thead>
<tr>
<th>第一个判定的取值情况</th>
<th>第二个判定的取值情况</th>
</tr>
</thead>
<tbody><tr>
<td>1. A&gt;1，B&#x3D;0</td>
<td>5. A&#x3D;2，X&gt;1</td>
</tr>
<tr>
<td>2. A&gt;1，B≠0</td>
<td>6. A&#x3D;2，X≤1</td>
</tr>
<tr>
<td>3. A≤1，B&#x3D;0</td>
<td>7. A≠2，X&gt;1</td>
</tr>
<tr>
<td>4. A≤1，B≠0</td>
<td>8. A≠2，X≤1</td>
</tr>
</tbody></table>
<p>生成的测试用例，以及它们遍历的路径和覆盖的组合如下：</p>
<blockquote>
<p>A&#x3D;2，B&#x3D;0，X&#x3D;4            <em><code>ace</code></em>    覆盖组合1，5<br>A&#x3D;2，B&#x3D;1，X&#x3D;1            <em><code>abe</code></em>    覆盖组合2，6<br>A&#x3D;1，B&#x3D;0，X&#x3D;2            <em><code>abe</code></em>    覆盖组合3，7<br>A&#x3D;1，B&#x3D;1，X&#x3D;1            <em><code>abd</code></em>    覆盖组合4，8</p>
</blockquote>
<p><strong>缺点：多重条件覆盖不一定能覆盖到每条路径，路径acd就被遗漏掉了。</strong></p>
<h6 id="f-路径覆盖"><a href="#f-路径覆盖" class="headerlink" title="f.路径覆盖"></a><strong>f.路径覆盖</strong></h6><p><img src="https://s1.ax1x.com/2020/05/24/tSdVoT.jpg"></p>
<p><strong>方法一</strong>：我们通常采用控制流图的边（弧）序列和节点序列表示某一条具体路径。<br>             （1）弧a和弧b相乘，表示为ab，它表明路径是先经历弧a，接着再经历弧b。<br>             （2）弧a和弧b相加，表示为a+b，它表明两条弧是“或”的关系，是并行的路段。<br>在路径表达式中，将所有弧均以数值1来代替，再进行表达式的相乘和相加运算，最后得到的数值即为该程序的 独立路径数 &#x3D; （1+1×1）×（1+1×1）&#x3D; 2×2 &#x3D; 4。</p>
<p><strong>方法二</strong>：与弧的计算方式类似，还可以通过必经节点个数 i，再找出必经节点下的路径数 w(i) ，计算路径数。流程图中共有2个必经节点②⑥，且先经历②再经历⑥，没有并行的独立节点，独立路径数 &#x3D; w(1)*…<em>w(i) &#x3D; 2</em>2 &#x3D; 4。</p>
<p>两种方法计算得到的路径数均为4条，它们分别覆盖了abd、abe、acd、ace：</p>
<blockquote>
<p>A&#x3D;1，B&#x3D;0，X&#x3D;1            <em><code>abd</code></em><br>A&#x3D;1，B&#x3D;0，X&#x3D;2            <em><code>abe</code></em><br>A&#x3D;3，B&#x3D;0，X&#x3D;1            <em><code>acd</code></em><br>A&#x3D;2，B&#x3D;0，X&#x3D;3            <em><code>ace</code></em></p>
</blockquote>
<p><strong>缺点：（1）路径覆盖无法发现程序不符合设计规范的错误（需要借助于黑盒测试的外部规格说明书）</strong></p>
<p><strong>比如：①.不一定发现路径本身的错误（缺一条或多一条路径）；②.可能不会暴露数据敏感的错误（比如计算两数之差小于某个值，如果程序实现的是a-b&lt;c，而不是|a-b|&lt;c，那么当b-a&gt;c时则无法发现程序的逻辑错误）,所以建议先使用黑盒方法设计测试用例，再使用白盒方法对用例进行补充。</strong></p>
<p><strong>（2）路径覆盖不一定把所有的条件组合情况都覆盖。以上测试用例尽管从表面上看已经满足路径覆盖，可是却无法发现程序当条件语句中的B&#x3D;0误写为B&gt;&#x3D;0时的错误，即没有对B≠0的情况进行测试。另外，第4个用例中由于A&#x3D;2，第二个判定中的X&gt;1条件被忽略，虽然覆盖了路径abd，却无法发现X&gt;1误写为X&gt;2时的错误，即没有对覆盖ace路径时X&gt;1的情况进行测试。</strong></p>
<p><strong>（3）复杂程序的用例数呈指数级上升。假设一段程序有10条判断语句，则i&#x3D;10， w(i)&#x3D;2，独立路径数为2的10次方，即1024，则要为它设计1024个测试用例。</strong></p>
<h6 id="g-完整路径覆盖"><a href="#g-完整路径覆盖" class="headerlink" title="g.完整路径覆盖"></a><strong>g.完整路径覆盖</strong></h6><p>设计一套测试让被测对象中每条路径至少执行一次</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tS0FaV.png"></p>
<p>完全路径即所有独立路径的集合；非完全路径，即所有独立路径集合的真子集。前面列出的独立路径集合并非完全路径，因为前面的流程图中含有隐含路径。</p>
<p>因此，如果判断中的条件表达式是由一个或多个逻辑运算符 (OR, AND, NAND, NOR)连接的复合条件表达式，则需要改为一系列只有单条件的嵌套的判断。细化后不含隐含路径的控制流图和流程图如上。</p>
<p>独立路径数 &#x3D; (1+1×1+1×1)×(1×1+1×1×1+1×1) &#x3D; 3×3 &#x3D; 9.或者必经节点有两个（节点2.1和节点6.1），独立路径数 &#x3D; w(1)×w(2) &#x3D; 3×3 &#x3D; 9。</p>
<blockquote>
<p> 路径一：2.1→6.1→6.2→8<br> 路径二：2.1→6.1→6.2→7→8<br> 路径三：2.1→6.1→7→8<br> 路径四：2.1→2.2→6.1→6.2→8<br> 路径五：2.1→2.2→6.1→6.2→7→8<br> 路径六：2.1→2.2→6.1→7→8<br> 路径七：2.1→2.2→3→6.1→6.2→8<br> 路径八：2.1→2.2→3→6.1→6.2→7→8<br> 路径九：2.1→2.2→3→6.1→7→8</p>
</blockquote>
<p>由此，要达到完全路径覆盖就需要设计9个测试用例，去掉不可能的情况路径三（因为A不可能同时满足A≤1，A&#x3D;2两个条件），仍然有8个用例。尽管在消除隐藏条件后解决了路径覆盖中的问题（2），但是完全路径覆盖的测试量比之前更加庞大。</p>
<h6 id="h-基本路径覆盖"><a href="#h-基本路径覆盖" class="headerlink" title="h.基本路径覆盖"></a><strong>h.基本路径覆盖</strong></h6><p>设计一套测试根据流图计算环复杂度，得到基本路径覆盖的用例数</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tSD48U.jpg"></p>
<table>
<thead>
<tr>
<th>计算圈复杂度的三种公式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V(G) &#x3D; e - n + 2</td>
<td>e为边数，n为节点个数</td>
</tr>
<tr>
<td>V(G)&#x3D;P+1</td>
<td>P为判定节点的个数</td>
</tr>
<tr>
<td>V(G)&#x3D;区域数</td>
<td>闭合区域+开放区域</td>
</tr>
</tbody></table>
<p>V(G) &#x3D; 6-5+2 &#x3D; 3<br>V(G) &#x3D; 2+1 &#x3D; 3<br>V(G) &#x3D; 2个闭合区域+1个开放区域 &#x3D; 3<br>无论使用哪种方法计算，都可确定3条独立的路径，即基本路径覆盖的用例数。</p>
<blockquote>
<p> 路径一：②⑥⑧，测试数据A&#x3D;1，B&#x3D;0，X&#x3D;1      <code>abd</code><br> 路径二：②③⑥⑧，测试数据A&#x3D;3，B&#x3D;0，X&#x3D;1  <code>acd</code><br> 路径三：②⑥⑦⑧，测试数据A&#x3D;1，B&#x3D;0，X&#x3D;2  <code>abe</code></p>
</blockquote>
<p><strong>思考</strong>：为什么②⑥⑧，②③⑥⑦⑧两个用例就可以将从②到⑧的路径全部覆盖，基本路径覆盖计算的结果还需要三个用例？我个人理解的原因是基本路径覆盖的一个测试用例一次只有一个变量因子。比如路径二相对路径一只有节点③发生了改变，路径三相对路径一只有节点⑦发生了改变。而如果只有②⑥⑧，②③⑥⑦⑧两个用例，虽然覆盖到了全部路径，但一次有两个因子③和⑦都发生了变化，无法对单个条件变化的测试结果进行比对。消除隐藏路径后的流程图如下：</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tSrEPf.png"></p>
<p>V(G) &#x3D; 10-7+2 &#x3D; 5<br>V(G) &#x3D; 4+1 &#x3D; 5<br>V(G) &#x3D; 4个闭合区域+1个开放区域 &#x3D; 5<br>无论使用哪种方法计算，都可确定5条独立的路径，即基本路径覆盖的用例数。</p>
<blockquote>
<p> 路径一：2.1→6.1→6.2→8，测试数据A&#x3D;1，B&#x3D;0，X&#x3D;1  <code>abid</code><br> 路径二：2.1→2.2→6.1→6.2→8，测试数据A&#x3D;3，B&#x3D;1，X&#x3D;1  <code>afgid</code><br> 路径三：2.1→2.2→3→6.1→6.2→8，测试数据A&#x3D;3，B&#x3D;0，X&#x3D;1  <code>afchid</code><br> 路径四：2.1→6.1→7→8，测试数据*<strong>A&#x3D;？，B&#x3D;？，X&#x3D;？*</strong>  <code>abek</code><br> 路径五：2.1→6.1→6.2→7→8，测试数据A&#x3D;1，B&#x3D;0，X&#x3D;2  <code>abijk</code></p>
</blockquote>
<p>设计测试数据时发现“路径四”<code>abek</code>不可能存在（因为A不可能同时满足A≤1，A&#x3D;2两个条件），根据实际情况调整路径为<code>afgek</code>，对应的测试数据为A&#x3D;2，B&#x3D;1，X&#x3D;1。</p>
<p><strong>缺点：尽管基本路径覆盖用例已经比完全路径覆盖的用例少了许多，但是当语句中有很多线性判定条件时，仍然无法解决测试量指数上升的问题。</strong></p>
<h6 id="i-分割后的完全路径覆盖"><a href="#i-分割后的完全路径覆盖" class="headerlink" title="i.分割后的完全路径覆盖"></a><strong>i.分割后的完全路径覆盖</strong></h6><p>设计一套测试让被测对象中每条路径至少执行一次，每个条件的所有可能结果至少执行一次</p>
<p>如果消除隐藏路径后，将程序在必经节点处割断，分别对每一段程序进行完全路径覆盖的充分测试，则即达到了完全路径覆盖的目的，又能对必经节点中的每个条件都进行考量，还大大减少了测试用例量。分割后的控制流图和流程图如下：</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tSrXes.png"></p>
<table>
<thead>
<tr>
<th>第一段程序的取值情况</th>
<th>第二段程序的取值情况</th>
</tr>
</thead>
<tbody><tr>
<td>A≤1，B&#x3D;任意值，X&#x3D;任意值            <em><code>ab</code></em></td>
<td>A≠2，X≤1            <em><code>oid</code></em></td>
</tr>
<tr>
<td>A&gt;1，B≠0，X&#x3D;任意值            <em><code>afg</code></em></td>
<td>A&#x3D;2，X&#x3D;任意值            <em><code>oek</code></em></td>
</tr>
<tr>
<td>A&gt;1，B&#x3D;0，X&#x3D;任意值            <em><code>afch</code></em></td>
<td>A≠2，X&gt;1            <em><code>oijk</code></em></td>
</tr>
</tbody></table>
<p>综合以上条件，得到测试用例如下：</p>
<blockquote>
<p> A&#x3D;1，B&#x3D;0，X&#x3D;1            <em><code>aboid</code></em>            输出：A&#x3D;1，B&#x3D;0，X&#x3D;1<br> A&#x3D;2，B&#x3D;1，X&#x3D;1            <em><code>afgoek</code></em>            输出：A&#x3D;1，B&#x3D;0，X&#x3D;2<br> A&#x3D;3，B&#x3D;0，X&#x3D;6            <em><code>afchoijk</code></em>            输出：A&#x3D;1，B&#x3D;0，X&#x3D;2</p>
</blockquote>
<p>最终得到的用例数为3，比程序被分割之前的所需用例数少了很多，缓解了测试量过大的问题；另一方面，针对两个程序片段实现了完全路径覆盖，解决了测试不足的问题。前面所提到的不一定覆盖所有条件组合情况下的BUG（未测试到的B≠0，X&gt;1的情况，即将B&#x3D;0误写为B&gt;&#x3D;0，X&gt;1误写为X&gt;2的错误），将会被测试用例2和测试用例3发现。</p>
<p><strong>优点：分割后的完全路径覆盖方法，解决了前面所说的第（2)、(3）问题，不仅对条件语句的每种情况都进行了考量，还防止了测试用例呈指数级上升的可能，解决了测试不足和测试量过大之间的矛盾。</strong></p>
<p><strong>基本路径覆盖和分割后的完全路径覆盖用例对比</strong></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>A</th>
<th>B</th>
<th>X</th>
<th>路径</th>
<th>编号</th>
<th>A</th>
<th>B</th>
<th>X</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>(1)</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td><code>abid</code></td>
<td>(1)</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td><code>abid</code></td>
</tr>
<tr>
<td>(2)</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td><code>afgid</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(3)</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td><code>afchid</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(4)</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td><code>afgek</code></td>
<td>(2)</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td><code>afgek</code></td>
</tr>
<tr>
<td>(5)</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td><code>abijk</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>(3)</td>
<td>3</td>
<td>0</td>
<td>6</td>
<td><code>afchijk</code></td>
</tr>
</tbody></table>
<ul>
<li>基本路径用例(2)测试的是A&gt;1，B≠0，X≤1的情况，在分割后的完全路径覆盖用例(2)中覆盖了A&gt;1，B≠0的情况，在分割后的完全路径覆盖用例(1)中覆盖了X≤1的情况。</li>
<li>基本路径用例(3)测试的是A&gt;1，B&#x3D;0，X≤1的情况，在分割后的完全路径覆盖用例(3)中覆盖了A&gt;1，B&#x3D;0的情况，在分割后的完全路径覆盖用例(1)中覆盖了X≤1的情况。</li>
<li>基本路径用例(5)测试的是A≤1，B值忽略，X&gt;1的情况，在分割后的完全路径覆盖用例(1)中覆盖了A≤1，B值忽略，在分割后的完全路径覆盖用例(3)中覆盖了X&gt;1的情况。</li>
</ul>
<p><strong>结论</strong>：基本路径覆盖对比起分割后的完全路径覆盖方法，后者不但实现了路径覆盖，还考虑到了条件语句的每种情况，并且用例数比基本路径覆盖更为精简，解决了完全路径覆盖和基本路径覆盖中复杂程序用例呈指数级上升的问题。</p>
<p><strong>说明：</strong></p>
<p><strong>1.覆盖程度由高到低依次是：路径覆盖 &gt; 多重条件覆盖 &gt; 判定&#x2F;条件覆盖 &gt; 条件覆盖 &gt; 判定覆盖 &gt; 语句覆盖</strong></p>
<p><strong>2.满足多重条件覆盖准则的测试用例集，同样满足判定覆盖准则、条件覆盖准则和判定&#x2F;条件覆盖准则</strong></p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>ISTQB CTFL证书考试之静态测试基础笔记（三）</title>
    <url>/2020/05/21/ISTQB%20CTFL%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95%E4%B9%8B%E9%9D%99%E6%80%81%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-TwZcDaLz" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1449782659" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、什么是静态测试？"><a href="#一、什么是静态测试？" class="headerlink" title="一、什么是静态测试？"></a><strong>一、什么是静态测试？</strong></h3><p>静态测试是指无须执行被测代码，而是借助专用的软件测试工具评审软件文档或程序，度量程序静态复杂度，检查软件是否符合编程标准，借以发现编写的程序的不足之处，减少错误出现的概率。一般来讲，涉及的最主要的就是通过评审，阅读文档，代码……，尽早的将问题暴露出来，减少时间和经济损失，提升软件质量。与之相对应就是动态测试，两者之间是平等关系，而不是对立。</p>
<h3 id="二、评审类型的划分"><a href="#二、评审类型的划分" class="headerlink" title="二、评审类型的划分"></a><strong>二、评审类型的划分</strong></h3><h4 id="1-非正式评审"><a href="#1-非正式评审" class="headerlink" title="1.非正式评审"></a><strong>1.非正式评审</strong></h4><p>主要目的就是：检测潜在的缺陷，与之同时可能会伴有附加目的，比如说：在测试过程中提出新的测试想法或者解决方法，快而有效的解决一些实际问题</p>
<h4 id="2-走查"><a href="#2-走查" class="headerlink" title="2.走查"></a><strong>2.走查</strong></h4><p>主要目的就是：发现缺陷并改进软件产品，考虑替代实施，评估与之前制定的标准和规范的符合程度</p>
<h4 id="3-技术评审"><a href="#3-技术评审" class="headerlink" title="3.技术评审"></a><strong>3.技术评审</strong></h4><p>主要目的就是：对涉及到的文档中使用的测试技术进行有效探讨，使用的是否合理，能否进行有效的替换方案，实现时间的节约，提高测试效率</p>
<h4 id="4-审查"><a href="#4-审查" class="headerlink" title="4.审查"></a><strong>4.审查</strong></h4><p>主要目的就是：对之前整个评审过程的再一次审视，通过学习和根本原因的分析防止未来出来类似的缺陷</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>数据库复习笔记（一）</title>
    <url>/2020/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-iEIUJWXx" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="40257852" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、什么是数据库？"><a href="#一、什么是数据库？" class="headerlink" title="一、什么是数据库？"></a><strong>一、什么是数据库？</strong></h3><p>数据库是存放数据的仓库，它的存储空间很大，可以存放百万条、千万条、上亿条数据。但是数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。当今世界是一个充满着数据的互联网世界，充斥着大量的数据，即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等，除了文本类型的数据，图像、音乐、声音都是数据。</p>
<p>数据库是一个按数据结构来存储和管理数据的计算机软件系统，数据库的概念实际包括两层意思：</p>
<p>1.数据库是一个实体，它是能够合理保管数据的“仓库”，用户在该“仓库”中存放要管理数据，“数据”和“库”两个概念结合成为数据库</p>
<p>2.数据库是数据管理的新方法和技术，它能更合适的组织数据、更方便的维护数据、更严密的控制数据和更有效的利用数据</p>
<h3 id="二、数据库的分类"><a href="#二、数据库的分类" class="headerlink" title="二、数据库的分类"></a><strong>二、数据库的分类</strong></h3><p>数据库的分类个人理解分为两大类：关系型数据库和非关系型数据库</p>
<p>关系型数据库：是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组织。</p>
<p>主流的关系型数据库有Oracle、DB2、MySQL、Microsoft SQL Server、Microsoft Access等多个种类，每种数据库的语法、功能和特性也有所不同，有所相同。</p>
<p>非关系型的数据库（NoSQL)：随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>
<p>主流的非关系型数据库有：NoSql、Cloudant、MongoDb、redis、HBase</p>
<h3 id="三、两大数据库的区别"><a href="#三、两大数据库的区别" class="headerlink" title="三、两大数据库的区别"></a><strong>三、两大数据库的区别</strong></h3><h4 id="1-关系型数据库"><a href="#1-关系型数据库" class="headerlink" title="1.关系型数据库"></a><strong>1.关系型数据库</strong></h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h5><p>①.容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更						容易理解</p>
<p>②.使用方便：通用的SQL语言使得操作关系型数据库非常方便</p>
<p>③.易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据						不一致的概率</p>
<p>④.支持SQL，可用于复杂的查询</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点：</strong></h5><p>①.为了维护一致性所付出的巨大代价就是其读写性能比较差<br>②.固定的表结构<br>③.高并发读写需求<br>④.海量数据的高效率读写</p>
<h4 id="2-非关系型数据库"><a href="#2-非关系型数据库" class="headerlink" title="2.非关系型数据库"></a><strong>2.非关系型数据库</strong></h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a><strong>优点：</strong></h5><p>①.无需经过SQL层的解析，读写性能很高<br>②.基于键值对，数据没有耦合性，容易扩展<br>③.存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型</p>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a><strong>缺点：</strong></h5><p>①.不提供SQL支持，学习和使用成本较高<br>②.无事务处理，附加功能bi和报表等支持也不好</p>
<h3 id="四、数据库常见语言分类"><a href="#四、数据库常见语言分类" class="headerlink" title="四、数据库常见语言分类"></a><strong>四、数据库常见语言分类</strong></h3><p>SQL：标准语言，全拼：Structure Query Language，专门针对数据库进行操作的一门语言</p>
<h4 id="1-DQL"><a href="#1-DQL" class="headerlink" title="1.DQL"></a><strong>1.DQL</strong></h4><p>DQL：数据库查询语言，全拼：Data Query Language</p>
<p>包含关键字：Select……From……</p>
<h4 id="2-DDL"><a href="#2-DDL" class="headerlink" title="2.DDL"></a><strong>2.DDL</strong></h4><p>DDL：数据库定义语言，全拼：Data Definition Language，专门针对数据库中对象进行操作</p>
<p>包含关键字：Create（创建）、Alter（修改）、Drop（删除）、Truncate（删数据）、Rename（更改名）</p>
<p>这里说的对象一般是指：表（Table）、视图（View）、索引（Index）、序列（Sequence）、同义词（Synonym）</p>
<h4 id="3-DML"><a href="#3-DML" class="headerlink" title="3.DML"></a><strong>3.DML</strong></h4><p>DML：数据库操作语言，全拼：Data Manipulation Language，专门针对数据库中数据进行操作</p>
<p>包含关键字：Insert（插入）、update（更新）、delete（删除）</p>
<h4 id="4-DCL"><a href="#4-DCL" class="headerlink" title="4.DCL"></a><strong>4.DCL</strong></h4><p>DCL：数据库控制语言，全拼：Data Control Language，专门针对数据库中权限进行操作</p>
<p>包含关键字：Grant（赋权）、Revoke（回收）</p>
<h4 id="5-TCL"><a href="#5-TCL" class="headerlink" title="5.TCL"></a><strong>5.TCL</strong></h4><p>TCL：事务控制语言，全拼：Transaction Control Language</p>
<p>包含关键字：Commit（提交）、Rollback（回滚）、Savepoint（保存点）</p>
<p>但是在网上查阅相关文档发现，TCL和DCL进行了Merge，归并到DCL里了</p>
<h3 id="五、三大删除的区分"><a href="#五、三大删除的区分" class="headerlink" title="五、三大删除的区分"></a><strong>五、三大删除的区分</strong></h3><p>Drop：删除表内容和结构，没有备份表之前要慎用，Drop将表所占用的空间全释放掉</p>
<p>Truncate：删除表的内容，表的结构存在，可以释放空间,没有备份表之前要慎用，Truncate table则是一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器，执行速度快。当表被Truncate 后，这个表和索引所占用的空间会恢复到初始大小。</p>
<p>Delete：删除表的内容，表的结构还存在，不释放空间，可以回滚恢复，Delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作，Delete操作不会减少表或索引所占用的空间</p>
<p>速度优先级别：Drop&gt;Truncate&gt;Delete；Truncate 和Delete只删除数据， Drop则删除整个表（结构和数据）；如果想删除部分数据用Delete，注意带上where子句，回滚段要足够大； 如果想删除表，当然用Drop； 如果想保留表而将所有数据删除，如果和事务无关，用truncate即可； 如果和事务有关，或者想触发trigger，还是用Delete；</p>
<p><strong>Example：</strong></p>
<p>现有一张数据表，名为：test</p>
<p>Drop：Drop test， 删除表test，并释放空间，将test删除的一干二净<br>Truncate：Truncate test， 删除表test里的内容，并释放空间，但不删除表的定义，表的结构还在<br>Delete：（1）删除制定数据：删除表test中年龄等于30且国家为US的数据：delete from test where 													age&#x3D;30 and country &#x3D;‘US’<br>               （2）删除整个表：仅删除表test内的所有内容，保留表的定义，不释放空间：delete from 												test 或delete * from test</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>ISTQB CTFL证书考试之软件开发生命周期中的测试笔记（二）</title>
    <url>/2020/05/08/ISTQB%20CTFL%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95%E4%B9%8B%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-FuamzddP" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1294568001" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、专业术语中英对照表"><a href="#一、专业术语中英对照表" class="headerlink" title="一、专业术语中英对照表"></a><strong>一、专业术语中英对照表</strong></h3><table>
<thead>
<tr>
<th>中文</th>
<th>英文</th>
</tr>
</thead>
<tbody><tr>
<td>验收测试</td>
<td>acceptance testing</td>
</tr>
<tr>
<td>alpha测试</td>
<td>alpha testing</td>
</tr>
<tr>
<td>beta测试</td>
<td>beta testing</td>
</tr>
<tr>
<td>变更相关的测试</td>
<td>change-related testing</td>
</tr>
<tr>
<td>商业现货软件（COTS）</td>
<td>commercial off-the-shelf</td>
</tr>
<tr>
<td>组件集成测试</td>
<td>component integration testing</td>
</tr>
<tr>
<td>组件测试</td>
<td>component testing</td>
</tr>
<tr>
<td>确认测试</td>
<td>confirmation testing</td>
</tr>
<tr>
<td>合同验收测试</td>
<td>contractual acceptance testing</td>
</tr>
<tr>
<td>功能测试</td>
<td>functional testing</td>
</tr>
<tr>
<td>影响分析</td>
<td>impact analysis</td>
</tr>
<tr>
<td>集成测试</td>
<td>integration testing</td>
</tr>
<tr>
<td>维护测试</td>
<td>maintenance testing</td>
</tr>
<tr>
<td>非功能测试</td>
<td>non-functional testing</td>
</tr>
<tr>
<td>运行验收测试</td>
<td>operational acceptance testing</td>
</tr>
<tr>
<td>回归测试</td>
<td>regression testing</td>
</tr>
<tr>
<td>法规验收测试</td>
<td>regulatory acceptance testing</td>
</tr>
<tr>
<td>顺序开发模型</td>
<td>sequential development model</td>
</tr>
<tr>
<td>系统集成测试</td>
<td>system integration testing</td>
</tr>
<tr>
<td>系统测试</td>
<td>system testing</td>
</tr>
<tr>
<td>测试依据</td>
<td>test basis</td>
</tr>
<tr>
<td>测试用例</td>
<td>test case</td>
</tr>
<tr>
<td>测试环境</td>
<td>test environment</td>
</tr>
<tr>
<td>测试级别</td>
<td>test level</td>
</tr>
<tr>
<td>测试对象</td>
<td>test object</td>
</tr>
<tr>
<td>测试目标</td>
<td>test objective</td>
</tr>
<tr>
<td>测试类型</td>
<td>test type</td>
</tr>
<tr>
<td>用户验收测试</td>
<td>user acceptance testing</td>
</tr>
<tr>
<td>白盒测试</td>
<td>white-box testing</td>
</tr>
</tbody></table>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </p>
<h3 id="二、软件开发生存周期模型及测试级别"><a href="#二、软件开发生存周期模型及测试级别" class="headerlink" title="二、软件开发生存周期模型及测试级别"></a><strong>二、软件开发生存周期模型及测试级别</strong></h3><p>1.瀑布模型开发活动包括：软件计划、需求分析、软件设计、程序编码、软件测试、运行维护</p>
<p>2.测试级别的划分：组件测试（单元测试）、集成测试、系统测试、验收测试</p>
<p>3.测试级别的属性：具体目标、测试依据、测试对象、典型的缺陷和失效、特定的方法和职责</p>
<p>4.对于验收测试主要还是会细分为：用户验证测试（UAT）、运行验收测试（OAT）、合同和法规验收测试以及Alpha测试和Beta测试。</p>
<p>a.用户验收测试（UAT）：通常侧重于验证系统是否适合在真实用户的环境或模拟运行环境中运行。其主要目标是建立信心，让用户能够以最低的难度、成本和风险使用这个系统去满足他们的要求、满足需求和开展业务流程。</p>
<p>b.运行验收测试（OAT）：通常是在（模拟的）生产环境中进行的，测试侧重于运行方面，可能包括：测试备份和恢复，安装、卸载和升级，灾难恢复，用户管理，维护任务，数据加载和移植任务，检查安全漏洞，性能测试。其主要目标是建立信心，操作员或系统管理员能确保用户在运行环境中正常操作<br>系统，即使在异常或困难的条件下也要确保系统可以正常工作。</p>
<p>c.合同验收测试：根据合同中生产定制软件的验收标准开展的，验收标准应在双方合同达成一致时确定，通常由用户或独立的测试员进行合同验收测试。法规验收测试：根据必须遵守的法规开展，通常由用户或独立的测试员进行法规验收测试，有时监管机构也会参与见证或审计。其主要目标是建立信心，证明合同或法规要求已得到满足。</p>
<p>d.Alpha 测试是在开发组织所在场地进行的测试，由潜在或现有客户、和&#x2F;或操作人员或独立测试团队执行。Beta 测试是由潜在或现有的客户、和&#x2F;或操作人员在他们本地执行。在完成 alpha 测试后，可以执行 Beta 测试，或之前没有执行过任何 alpha 测试的情况下执行 Beta 测试。</p>
<h3 id="三、测试类型及维护测试"><a href="#三、测试类型及维护测试" class="headerlink" title="三、测试类型及维护测试"></a><strong>三、测试类型及维护测试</strong></h3><p>测试类型是一组基于特定测试目标的测试活动，旨在测试软件系统或系统的一部分特定特性。这些目标可能包括：评估功能质量特性，例如完整性、正确性和适当性；评估非功能质量特性，例如可靠性、性能效率、安全性、兼容性和易用性；评估组件或系统的结构或架构是否正确、完整并符合规定；评估变更的影响，例如确认缺陷已得到修复（确认测试）以及寻找因软件或环境变化而导致的不可预料的行为变化（回归测试）</p>
<p>测试类型主要包括：功能测试、非功能测试、黑白盒测试和与变更相关测试。其中大纲中未将黑盒测试包括在内，但个人认为黑盒测试是一个必不可缺的一种测试类型，因为其涉及到软件内部代码，极易引起缺陷，导致失效，所以笔记中加入黑盒测试。与变更相关性测试，主要也是涉及到内部代码块，在修复或变更某个模块的代码时，不经意间可能会影响其曾经涉及相关联的其它部分，这也是为什么要经常在各级别测试中，不断加入回归性测试的原因，回归性测试其实更多的是用自动化去跑。</p>
<p><strong>Example：以银行应用程序为例，介绍功能测试、非功能测试、白盒测试以及与变更相关的测试在所有测试级别中的应用</strong></p>
<p><strong>1.功能测试</strong></p>
<p>a.对于组件测试，根据组件是如何计算利息来进行测试设计</p>
<p>b.对于组件集成测试，测试设计是基于如何将在用户界面捕获的账户信息传递到业务逻辑中</p>
<p>c.对于系统测试，测试设计是基于帐户持有人如何在他们的支票帐户上申请信用额度</p>
<p>d.对于系统集成测试，测试设计是基于系统如何使用外部微服务来检查帐户持有者的信用评分</p>
<p>e.对于验收测试，测试设计是基于银行是如何处理批准或拒绝信贷申请。</p>
<p><strong>2.非功能测试</strong></p>
<p>a.对于组件测试，性能测试的设计是为了评估开展复杂的总利息计算所需的 CPU 周期数</p>
<p>b.对于组件集成测试，安全性测试的设计是针对从用户界面传到业务逻辑的数据所产生的缓冲区溢出漏洞。</p>
<p>c.对于系统测试，可移植性测试的设计是为了检查表示层是否在所有支持的浏览器和移动设备上工作</p>
<p>d.对于系统集成测试，可靠性测试的设计是为了在信用评分微服务无法响应时，评估系统的健壮性</p>
<p>e.对于验收测试，易用性测试的设计是为了评估银行信贷处理界面对残疾人的无障碍性</p>
<p><strong>3.黑白盒测试</strong></p>
<p>a.对于组件测试，测试的设计是为了对所有进行财务设计的组件实现完全的语句和判定覆盖</p>
<p>b.对于组件集成测试，测试的设计是为了测试浏览器界面中的每个屏幕如何将数据传递到下一个屏幕和业务逻辑</p>
<p>c.对于系统测试，测试的设计是为了覆盖信用额度应用期间可能发生的网页序列</p>
<p>d.对于系统集成测试，测试的设计是为了检查所有可能发送到信用评分微服务的查询类型</p>
<p>e.对于验收测试，测试的设计是为了覆盖所有支持的财务数据文件结构和银行间转账的价值<br>范围</p>
<p><strong>4.与变更相关测试</strong></p>
<p>a.对于组件测试，为每个组件构建自动回归测试，并将其归入在持续集成框架内</p>
<p>b.对于组件集成测试，测试的设计是为了确认当修复的代码已经集成到代码库时，与接口相关的缺陷已得到修复</p>
<p>c.对于系统测试，如果工作流上的任何屏幕发生更改，则会重新执行指定的工作流的所有测<br>试</p>
<p>d.对于系统集成测试，每天重新执行与信用评分微服务交互的应用程序的测试，作为该微服<br>务的持续部署的一部分</p>
<p>e.对于验收测试，在验收测试中修复发现的缺陷后，将重新执行所有先前失败的测试</p>
<p>维护性测试：多运用在已经投产的软件后期，触发的规则也是因各软件所运用的场景决定，重点是在软件进行版本的更新，或者软件加入新的功能，相对来说它的风险性是比较低的。</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>ISTQB CTFL证书考试之软件测试基础笔记（一）</title>
    <url>/2020/05/06/ISTQB%20CTFL%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95%E4%B9%8B%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-yJavUTet" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="447925342" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一、专业术语中英对照表"><a href="#一、专业术语中英对照表" class="headerlink" title="一、专业术语中英对照表"></a><strong>一、专业术语中英对照表</strong></h3><table>
<thead>
<tr>
<th align="center">中文</th>
<th align="center">英文</th>
</tr>
</thead>
<tbody><tr>
<td align="center">覆盖</td>
<td align="center">coverage</td>
</tr>
<tr>
<td align="center">调试</td>
<td align="center">debugging</td>
</tr>
<tr>
<td align="center">缺陷</td>
<td align="center">defect</td>
</tr>
<tr>
<td align="center">错误</td>
<td align="center">error</td>
</tr>
<tr>
<td align="center">失效</td>
<td align="center">failure</td>
</tr>
<tr>
<td align="center">质量</td>
<td align="center">quality</td>
</tr>
<tr>
<td align="center">质量保证</td>
<td align="center">quality assurance</td>
</tr>
<tr>
<td align="center">根本原因</td>
<td align="center">root cause</td>
</tr>
<tr>
<td align="center">测试分析</td>
<td align="center">test analysis</td>
</tr>
<tr>
<td align="center">测试依据</td>
<td align="center">test basis</td>
</tr>
<tr>
<td align="center">测试用例</td>
<td align="center">test case</td>
</tr>
<tr>
<td align="center">测试结束</td>
<td align="center">test completion</td>
</tr>
<tr>
<td align="center">测试条件</td>
<td align="center">test condition</td>
</tr>
<tr>
<td align="center">测试控制</td>
<td align="center">test control</td>
</tr>
<tr>
<td align="center">测试数据</td>
<td align="center">test data</td>
</tr>
<tr>
<td align="center">测试设计</td>
<td align="center">test design</td>
</tr>
<tr>
<td align="center">测试执行</td>
<td align="center">test execution</td>
</tr>
<tr>
<td align="center">测试实施</td>
<td align="center">test implementation</td>
</tr>
<tr>
<td align="center">测试监督</td>
<td align="center">test monitoring</td>
</tr>
<tr>
<td align="center">测试对象</td>
<td align="center">test object</td>
</tr>
<tr>
<td align="center">测试目标</td>
<td align="center">test objective</td>
</tr>
<tr>
<td align="center">测试结果参照物</td>
<td align="center">test oracle</td>
</tr>
<tr>
<td align="center">测试计划</td>
<td align="center">test planning</td>
</tr>
<tr>
<td align="center">测试规程</td>
<td align="center">test procedure</td>
</tr>
<tr>
<td align="center">测试过程</td>
<td align="center">test process</td>
</tr>
<tr>
<td align="center">测试套件</td>
<td align="center">test suite</td>
</tr>
<tr>
<td align="center">测试</td>
<td align="center">testing</td>
</tr>
<tr>
<td align="center">测试件</td>
<td align="center">testware</td>
</tr>
<tr>
<td align="center">确认</td>
<td align="center">validation</td>
</tr>
<tr>
<td align="center">验证</td>
<td align="center">verification</td>
</tr>
<tr>
<td align="center">可追溯性</td>
<td align="center">traceability</td>
</tr>
</tbody></table>
<h3 id="二、软件测试的七项基本原则"><a href="#二、软件测试的七项基本原则" class="headerlink" title="二、软件测试的七项基本原则"></a><strong>二、软件测试的七项基本原则</strong></h3><p><strong>1.测试说明缺陷的存在，而不能说明缺陷不存在</strong><br><strong>2.穷尽测试是不可能的</strong><br><strong>3.测试的尽早介入可以节省时间和成本</strong><br><strong>4.缺陷的群集效应</strong>：也就是在某一个特定的区域发现的缺陷比较多，那么这一区域发生缺陷的概率就越									大，俗称“重灾区”<br><strong>5.杀虫剂悖论</strong>：通俗一点讲，当类似该场景下，多次执行相同的case，是无法发现更多的有效新问题，							要实时进行case的调整，但对于自动化回归测试，这一做法是很高效的<br><strong>6.测试活动依赖于测试周境</strong><br><strong>7.不存在缺陷的谬论</strong></p>
<h3 id="三、软件测试过程及输出产物"><a href="#三、软件测试过程及输出产物" class="headerlink" title="三、软件测试过程及输出产物"></a><strong>三、软件测试过程及输出产物</strong></h3><p>在实际的工作场景中，软件测试被分为三个主要阶段：系统测试、集成测试、单元测试，每个阶段又被分为四个部分：计划、设计、实现以及执行。但是对于大纲细腻划分为以下七个部分，不同阶段所处理的问题分布更加集中化。具体的框架结构，以XMind的以下部分截屏说明。</p>
<p><img src="https://s1.ax1x.com/2020/05/06/YVZwpF.png"></p>
<p>1.<strong>测试计划</strong>：阐明整个项目所需的周期，人力，环境……一些必要的测试条件<br>2.<strong>测试监督与控制</strong><br>3.<strong>测试分析</strong>：阐明测试什么的问题，剖析需求点，<br>4.<strong>测试设计</strong>：阐明怎样测试的问题<br>5.<strong>测试实施</strong>：阐明是否已经具备所需测试的所有条件<br>6.<strong>测试执行</strong><br>7.<strong>测试结束</strong></p>
<p><strong>然后晚上就饿了，加个餐，酸辣粉</strong></p>
<p><img src="https://s1.ax1x.com/2020/05/06/YVefU0.jpg"></p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>一花一世界，一叶一菩提</title>
    <url>/2020/05/03/%E4%B8%80%E8%8A%B1%E4%B8%80%E4%B8%96%E7%95%8C%EF%BC%8C%E4%B8%80%E5%8F%B6%E4%B8%80%E8%8F%A9%E6%8F%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-hmTBCuvT" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1315568574" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p><img src="https://s1.ax1x.com/2020/05/04/Yphc7t.jpg"></p>
<p>我发现我自己真的对于爱情方面不喜欢太张扬，我不会整天的把什么我爱你，我喜欢你放在嘴上去说，相反更多的是去做，当然有些时候还很霸道。</p>
<p>两个人其实在一起更多的是共同去承担或者面临一些自己无法独立完成的事，什么狗屁一个人活得很潇洒，你问问他们自己，夜深人静的时候，自己是否会有那么一丝丝的被冷落，孤单，不管你是男孩子，还是女孩子，尤其是那些独自一人，背井离乡，出去打拼的。</p>
<p>自从来到上海，每年都会回家三次：春节一次；五一节一次；国庆节一次。因为在我看来，当父母开始逐渐年迈时，更多的是希望自己的子女在身边多去陪伴，我能感受到我妈对我担忧，而我爸虽然不说，但父子之间的那种微妙的讯号，不需要用言语过多的去表达。但是从19年五一节之后，我真的就不怎么太想回来，每次回来都被逼着谈一些婚姻的事，真的很烦。</p>
<p>从19年五一节开始，到20年的五一节，整整一年，中途认识了差不多有五六个女孩子。其实，我理解我妈老一辈的想法，希望早点结婚，成个家，抱个孙子孙女，因为毕竟同龄家的小孩都会打酱油，上学了，所以我一直没反对过她去安排相亲。我对相亲所持有的态度很简单，不盲目排斥，也不随意接受，合适就谈，不合适就当朋友处着，拓展社交了，由于从事的IT相关软件测试这份工作的原因，我也很少有时间去专门跟女孩子去沟通谈情感这些东西。但就目前这种情况而言，我发现我也渐渐快要麻木了，每次我妈说一个，我就要像完成任务一样，最后还要向她报告情况，真的很讨厌。</p>
<p>的确也遇到过一两个长相、性格合适的，也很主动的去聊过好几次，我妈每次说一个女孩子，我都会根据跟这话女孩子的沟通，给这个女孩画一个人物画像，虽然不见面，我也能够大致了解到一些非常细节的东西。我不喜欢整天粘着，跟个口香糖一样天天聊，而且两个人从事的工作也没什么交集，顶多就聊一聊生活，但时间一长，我也发现自己越主动越被别人觉得越廉价，感觉就是个备胎，所以就渐渐失去想要主动的这种热情，都说太认真就真的输了，这话没毛病。用我们的专业术语来讲：我作为客户端，主动的向你这个服务器发送请求，你长时间的不响应或者响应时间timeout，报个404的error，那你觉得我还会持久的继续等待你的响应么？也不现实啊。</p>
<p>退一万步来讲，哪怕是男孩子真的想谈对象，一直在付出，但至少女孩子给点反馈，人心都是肉长的，将心比心，男孩子想谈对象，反过来，你女孩子就不要谈对象了？换个身份，换个角度，既然大家都有好感的话，就给个真实的表达嘛，给彼此对方一个信号，毕竟人家又不是你肚子里的蛔虫，又不知道你自己的想法，男孩子不要鲁莽，女孩子也不要太矜持，不要把简单的事情复杂化。一个人，不管是男孩子或者女孩子，放弃原本属于自己的生活，弯下腰放低姿态，让你看见Ta的卑微，陪你一起携手成长，我觉得就应当好好去珍惜。如果同样两个人让我去选择：一个是我爱的人，另一个是爱我的人，我毫不犹豫的会去选后者。得不到的永远在骚动，被偏爱的永远都有恃无恐。</p>
<p>缘分这个东西，你说不出来是什么样的感受。你眼缘好，相中的女孩子，人家嫌弃你；有些女孩子，人家相中你，你却又挑三拣四，所以当你在人群中徘徊的时候，真的有一种感觉，找到合适的对象真的好难啊。</p>
<p>今年的这个国庆节，我在考虑到底要不要再回来！！！</p>
]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title>不一样的思维曲线</title>
    <url>/2020/04/29/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%80%9D%E7%BB%B4%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-RFXjakom" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="488958365" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p>晚上11点多吃完饭才回来，这顿饭吃出了不一样的“味道”，有点涩中带咸，我感觉这是他俩刻意串通好的。老王是原先我做销售的时候认识的，一直玩到现在；峰子是老王朋友，一直在做的是IT开发，我转行到IT测试之前也是受他的一部分影响，没正式做测试时，那时候自己也想做开发，自己买了很多关于开发的书，自己也学了很多关于程序开发的部分，以至于现在对代码也是情有独钟的，Java，Python，C……，唯一遗憾的是从来没有正式的去参加过开发的项目。</p>
<p><img src="https://s1.ax1x.com/2020/04/30/JHcU9e.jpg"></p>
<p>吃的也不算豪华，我一般都喜欢自己在家做饭，享受做饭的过程，吃不吃的无所谓。但是今晚吃的很饱，因为吃的时间有点长，一直到店铺关门，吃着吃着，三个眼快到三的老男孩，不自禁的聊到对象。他们两个都比我大两三岁，也都谈过对象，我吧，自从来到上海，前期的大部分时间都在玩，也没去碰这个东西，因为这个东西就用他们这些过来人话说：有毒。但是渐渐的每年回家过年，家里办饭，亲戚团在一起，长辈们都会提，聚一次提一次。</p>
<p>我是整个家族中最小的一个，不管是在我爸这方还是在我妈这方，都最小。从19年开始，这个目光就开始转移到我身上，虽然我上面还有3个堂表哥没结婚，然而这也不能成为他们不关注我的重点，19年过年回家，被我妈开始逼着去相亲，借回上海为由，躲过了一次。今年回家，20年的疫情又帮了我一次，24号过年，27号回上海，又躲过了一次。但是每次跟我妈视频，依旧对这件事涛涛不绝，然后今年20年，整个人脑子里就想着两件事，第一件事：赚老婆本；第二件事：找对象。</p>
<p>但今晚吃饭，老王跟峰子说的一些话，让我真的是……</p>
<p>我做事不喜欢拐弯抹角，直来直往，做很多事的时候，思维很清晰，目标很明确，我知道自己要什么，一切简洁化，也因为这样，被他们两个称为“钢铁直男”，他们也清楚我目前也在碰情这个东西。我的性格其实我自己也清楚，我特别讨厌吵架，可能是我受家的文化影响，我爸妈就不吵架，所以这一点是我对男女朋友相处的基准线：不要动不动就生气，吵架，然后双方开始冷战，最后闹崩。其次，我平时都不会发脾气，我爱笑，一笑一双眼睛就会眯成一条线，但是有一点，把我惹毛了，脾气上来了，十头牛都拉不住。我感恩每一个帮助过我的人，我都会记在心上，我不擅长用语言去表达，但是都会在平时实际行动中去证明和反赠。</p>
<p>我不想我自己谈个对象，跟谈个祖宗一样，天天供着，好吃好喝，天天宠溺着。我的独立生存性很强，自从来到上海，我就没向家里要过一份钱，我每个月都会把自己工资分成五份：给自己买黄金，一份；给我爸买保险，一份；给自己用餐及生活用品，一份；跟朋友同事出去吃饭，一份；给自己定期存款，一份。所以，我希望我可以通过自己目前的努力，延迟满足自己的欲望，去寻找一个可以一起携手并进的女孩子，一起去分享这种欲望被满足实现后的喜悦。</p>
<p>但是这一切都被他俩说的很缥缈，也说了一些过来人的看法。首先，真心想跟你交往的女孩子，不会刻意的去注重你的身材外表以及你的Money，在乎的是你是否真的将她说的话，当做一件事去做过，是否去考虑过她的感受，给她该有的安全感？；其次，你的人品是否值得她愿意将自己的心交付于你，你的求生欲一定要强，凭什么原先人家自己好好的生活被你这个陌生人莫名闯入打断，发生运转轨迹的重新偏移？；紧接着，你有没有想过那些工作没你好，薪资没你高，长相还没你的好看的凭什么都能有对象一起吃饭，逛街，旅游…….真的是，好白菜让猪拱了，难道自己就不找找问题？最后，说了一句，谈对象自己要胆大心细脸皮厚。</p>
<p>其实他俩说的话，也并不无道理，有时候真的是我以为怎样就怎样，一般男孩子想的跟自己的想法差不多，不需要刻意的去琢磨，但是这个世界除了男人就是女人，这是个不一样的思维的存在，很难用正常的逻辑去推敲，要好好探究里面的小心思，想想也对。天天腻歪着你，你是他对象，她不腻歪黏着你黏谁？但我真的不想把谈对象这件事，当做一件负担，它该有的模样原本是生活中锦上添花的一件事，而不是最终的备胎和撒气桶。爱情它不该是单方面的卑微，而是双方共同磨合经营后常青藤。</p>
<p>但我还是记住一句话：不管谈对象到最后，结婚的还是不结婚的，反正都会后悔的。</p>
]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title>Hey，Shanghai  |  Here I am</title>
    <url>/2020/04/24/Hey%EF%BC%8CShanghai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-SQtDuFbO" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="521597063" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p>从18年到19年，再从19年到20年，一直坚持做下来的就是跑步，疫情解禁后的第一次肆无忌惮的开跑，拉了一个朋友一起完成4公里的短距离小跑。很显然朋友有点坚持不住，边跑边聊了一些，人生最低谷的时候，自己的状态，怎样去让自己化被动为主动。4公里的量，其实对于一个正常人来讲还算好，但对于我这个热爱跑步的人来讲，没什么。<br>最终完成10.2公里的运动量，感觉真的是专治各种不爽，然后跑完之后，休息一下，冲个温水澡，简直舒爽死。其实跑步跑的真的不是步，跑的是一种心态，跑的是一种坚持，跑的是一种泄压。</p>
<p><img src="https://s1.ax1x.com/2020/04/28/JhfsBT.jpg"></p>
<p>我一般跑步都喜欢戴一个头戴式的耳机，也建议大家去买一个稍微好一点的耳机，因为好的耳机，可以让你一人一世界，不被外界打扰，好的外文DJ音乐可以让你分泌更多的多巴胺和肾上腺激素，多巴胺一多，你整个人就会越兴奋，肾上腺激素一多，越亢奋，跑步就会越轻松。我用的还是老款的Beats solo2 wireless，自从去年的“百日重塑”干坏一个耳机之后，自己也不敢买太好的，但心里一直总是惦记着Beats的录音师Pro，煲机音乐我都在私人云盘里放了好久，就差一个好耳机了。<br>跑步时，给些建议给大家，首先就是一定要穿跑鞋去跑，要不然你就脚一定遭殃；其次就是开跑前一定要做好热身运动，非常非常有必要，主要是你的膝盖，脚踝，下腿的小肌肉，脚肌腱和腰力量的拉伸；紧接着就是最好自己带一块运动手表或者手环，开启心率监测，跑的过程中，心率不要超过188，高强度的跑步，对心脏是一个挑战，深呼吸，拉伸自己的肺活量，前期1公里一般都建议小跑，逐渐拉伸肺活量，2公里时提升步频；最后就是跑步过程中，腰一定要直起来，全脚掌着地，身体前倾一定的角度，避免身体上下来回颠动，心脏受不了这样的罪。跑步结束后，不要立即就停下来走，当要结束自己跑步时，放慢步频，降心率到120上下，目前上海的气压还算可以。男孩子长跑时，如果穿T恤，请给自己的乳头贴上创口贴，因为跑步时，T恤会来回摩擦会很疼。结束之后，自己一定记住多补Na<sup>+</sup>和VC，多喝一些柠檬水，多啃两根黄瓜，多吃点胡萝卜。</p>
<p><img src="https://s1.ax1x.com/2020/04/28/Jhfhg1.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/28/JhfTHO.jpg"></p>
<p><strong>最后记住一点：跑步的最终目的是能够让自己的身体更健康，千万不要盲目的一下子跑个十几公里，第二天腿废了，我始终坚信一点就是：只有你自己爱护好自己，才有资格去爱别人。</strong></p>
<p>跑完步回来，一定要好好的犒劳一下自己，跑步前已经把晚饭做好，下班回来路上，骑上我心爱的小哈啰，路经菜场买了点菜。</p>
<p><img src="https://s1.ax1x.com/2020/04/28/Jhfq4H.jpg"></p>
<h5 id="第一道：番茄炒鸡蛋"><a href="#第一道：番茄炒鸡蛋" class="headerlink" title="第一道：番茄炒鸡蛋"></a><strong>第一道：番茄炒鸡蛋</strong></h5><p><img src="https://s1.ax1x.com/2020/04/28/JhfX8A.jpg"></p>
<h5 id="第二道：鸡丁"><a href="#第二道：鸡丁" class="headerlink" title="第二道：鸡丁"></a><strong>第二道：鸡丁</strong></h5><p><img src="https://s1.ax1x.com/2020/04/28/Jhhpb8.jpg"></p>
<h5 id="第三道：红烧肉炖百叶"><a href="#第三道：红烧肉炖百叶" class="headerlink" title="第三道：红烧肉炖百叶"></a><strong>第三道：红烧肉炖百叶</strong></h5><p><img src="https://s1.ax1x.com/2020/04/28/JhhE2n.jpg"></p>
<p>这最后一道菜，真的是人间美味，甜中带咸，咸中带鲜，鲜中带香。精选上乘五花肉，料酒腌制半小时，切块后热锅少量冷油，炒出五花肉自带的猪油，加入花椒，葱段，生姜，待香味入肉，捞出佐料剔除，肉装盘。老冰糖炒成糖色，五花肉回锅，干煸，待糖色颜色变黑，加入适量水没过五花肉，老抽，蚝油，盐，炖个一刻钟，汤汁出现粘稠状，倒入百叶，加入少许水，再炖个一刻钟到半个小时，然后起锅前，开盖，撒入葱花，滴几滴灵魂番茄酱。wow，厨艺一绝，香，哈喇子，做个精致的猪猪男孩，吆豁~</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>《可复制的领导力》Writing Before Reading</title>
    <url>/2020/04/23/%E3%80%8A%E5%8F%AF%E5%A4%8D%E5%88%B6%E7%9A%84%E9%A2%86%E5%AF%BC%E5%8A%9B%E3%80%8BWriting%20Before%20Reading/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-EpoyOcfn" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1314085802" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="Writing-Before-Reading"><a href="#Writing-Before-Reading" class="headerlink" title="Writing Before Reading"></a><strong>Writing Before Reading</strong></h3><p><strong>其实我并不喜欢看书，从小读书那会起，看书就发困，但是当渐渐一个人单枪匹马行走社会时，逐渐意识到个人能力为自己带来的财富。都说读书是投入成本最低，收益最高的买卖，与其一直处于被动被社会选择，不如自己主动选择换种方式去提升自己，所以目前一直以听书的方式去努力提升。对于书籍，我的观点是：尽量不要完全依赖别人咀嚼过的“食物”，因为每个人的认知水平，个人素养，个人三观都不在一个纬度，会造成不同的感知。每个人对同一件事的看法，没有对错之分，只有一致不一致之说。</strong></p>
<h3 id="简介和目录"><a href="#简介和目录" class="headerlink" title="简介和目录"></a><strong>简介和目录</strong></h3><p><strong>原书一共分为9个章节，这本书的原名是叫《樊登的9堂商业课》，17年出版的书。整本书是一个管理理念和管理工具的集合，书中间接引用了众多最新的管理学思想和方法，比如《联盟》、《刻意练习》、《指数型公司》、《哈佛商学院最受欢迎的领导课》、《商业的本质》、《让创意更有粘性》、《高绩效教练》、《金钱不能买什么》、《一分钟经理人》等商业名著，书的大致结构是这样。</strong></p>
<p><img src="https://s1.ax1x.com/2020/04/28/JIIk1e.gif"></p>
<h4 id="第1章：80-的管理者能达到80分"><a href="#第1章：80-的管理者能达到80分" class="headerlink" title="第1章：80% 的管理者能达到80分"></a><strong>第1章：80% 的管理者能达到80分</strong></h4><p>过去企业管理员工，靠的是严格约束；现在企业管理员工，靠的是相互吸引。一个有野心的管理者，需要将每名员工变成团队的战略合作者。</p>
<h5 id="1-1-人人都能学会领导力"><a href="#1-1-人人都能学会领导力" class="headerlink" title="1.1  人人都能学会领导力"></a><strong>1.1  人人都能学会领导力</strong></h5><h5 id="1-2-领导力是可以标准化的"><a href="#1-2-领导力是可以标准化的" class="headerlink" title="1.2  领导力是可以标准化的"></a><strong>1.2  领导力是可以标准化的</strong></h5><h5 id="1-3-提升领导力的四重修炼"><a href="#1-3-提升领导力的四重修炼" class="headerlink" title="1.3  提升领导力的四重修炼"></a><strong>1.3  提升领导力的四重修炼</strong></h5><h4 id="第2章：明确角色定位，避免亲力亲为"><a href="#第2章：明确角色定位，避免亲力亲为" class="headerlink" title="第2章：明确角色定位，避免亲力亲为"></a><strong>第2章：明确角色定位，避免亲力亲为</strong></h4><p>管理者的使命是培养员工，打造有战斗力的团队，而不是将员工的工作都加在自己身上，越俎代庖，事事参与。衡量一个管理者能力的高低，就是看他能培养多少能干的人才。</p>
<h5 id="2-1-管理就是通过别人完成任务"><a href="#2-1-管理就是通过别人完成任务" class="headerlink" title="2.1  管理就是通过别人完成任务"></a><strong>2.1  管理就是通过别人完成任务</strong></h5><h5 id="2-2-学会授权，别怕员工犯错"><a href="#2-2-学会授权，别怕员工犯错" class="headerlink" title="2.2  学会授权，别怕员工犯错"></a><strong>2.2  学会授权，别怕员工犯错</strong></h5><h5 id="2-3-管理者的三大角色"><a href="#2-3-管理者的三大角色" class="headerlink" title="2.3  管理者的三大角色"></a><strong>2.3  管理者的三大角色</strong></h5><h5 id="2-4-优秀管理者都是营造氛围的高手"><a href="#2-4-优秀管理者都是营造氛围的高手" class="headerlink" title="2.4  优秀管理者都是营造氛围的高手"></a><strong>2.4  优秀管理者都是营造氛围的高手</strong></h5><h4 id="第3章：构建游戏化组织，让工作变得更有趣"><a href="#第3章：构建游戏化组织，让工作变得更有趣" class="headerlink" title="第3章：构建游戏化组织，让工作变得更有趣"></a><strong>第3章：构建游戏化组织，让工作变得更有趣</strong></h4><p>伴随着互联网成长起来的新一代员工，金钱和梦想 已经不是吸引他们工作的最重要的理由，让工作变得有趣或许是一个不错的方式。</p>
<h5 id="3-1-设定明确的团队愿景"><a href="#3-1-设定明确的团队愿景" class="headerlink" title="3.1  设定明确的团队愿景"></a><strong>3.1  设定明确的团队愿景</strong></h5><h5 id="3-2-制定清晰的游戏规则"><a href="#3-2-制定清晰的游戏规则" class="headerlink" title="3.2  制定清晰的游戏规则"></a><strong>3.2  制定清晰的游戏规则</strong></h5><h5 id="3-3-建立及时的反馈系统"><a href="#3-3-建立及时的反馈系统" class="headerlink" title="3.3  建立及时的反馈系统"></a><strong>3.3  建立及时的反馈系统</strong></h5><h5 id="3-4-自愿参与的游戏机制"><a href="#3-4-自愿参与的游戏机制" class="headerlink" title="3.4  自愿参与的游戏机制"></a><strong>3.4  自愿参与的游戏机制</strong></h5><h4 id="第4章：理清关系，打造团队一致性"><a href="#第4章：理清关系，打造团队一致性" class="headerlink" title="第4章：理清关系，打造团队一致性"></a><strong>第4章：理清关系，打造团队一致性</strong></h4><p>团队不应被称为“ 家”，而应是一支球队，大家聚在一起是为了进步，为了赢得最终胜利。唯有如此，才能将团队打造成激烈商战中无坚不摧的铁军。</p>
<h5 id="4-1-团队就是“球队”，目标就是“赢球”"><a href="#4-1-团队就是“球队”，目标就是“赢球”" class="headerlink" title="4.1  团队就是“球队”，目标就是“赢球”"></a><strong>4.1  团队就是“球队”，目标就是“赢球”</strong></h5><h5 id="4-2-把你要员工做的事，变成他自己要做的事"><a href="#4-2-把你要员工做的事，变成他自己要做的事" class="headerlink" title="4.2  把你要员工做的事，变成他自己要做的事"></a><strong>4.2  把你要员工做的事，变成他自己要做的事</strong></h5><h5 id="4-3-前员工是熟人，而非路人"><a href="#4-3-前员工是熟人，而非路人" class="headerlink" title="4.3  前员工是熟人，而非路人"></a><strong>4.3  前员工是熟人，而非路人</strong></h5><h4 id="第5章：用目标管人，而不是人管人"><a href="#第5章：用目标管人，而不是人管人" class="headerlink" title="第5章：用目标管人，而不是人管人"></a><strong>第5章：用目标管人，而不是人管人</strong></h4><p>目标是一切管理的基础和开始。对于个人来说，目标是内心坚不可摧的精神支柱；对于企业来说，目标是推动企业发展的最大驱动力。</p>
<h5 id="5-1-企业管理，说到底就是目标管理"><a href="#5-1-企业管理，说到底就是目标管理" class="headerlink" title="5.1  企业管理，说到底就是目标管理"></a><strong>5.1  企业管理，说到底就是目标管理</strong></h5><h5 id="5-2-目标管理的四大难题"><a href="#5-2-目标管理的四大难题" class="headerlink" title="5.2  目标管理的四大难题"></a><strong>5.2  目标管理的四大难题</strong></h5><h5 id="5-3-明确量化的目标才是好目标"><a href="#5-3-明确量化的目标才是好目标" class="headerlink" title="5.3  明确量化的目标才是好目标"></a><strong>5.3  明确量化的目标才是好目标</strong></h5><h5 id="5-4-套用公式制定团队目标"><a href="#5-4-套用公式制定团队目标" class="headerlink" title="5.4  套用公式制定团队目标"></a><strong>5.4  套用公式制定团队目标</strong></h5><h5 id="5-5-目标管理的标准化"><a href="#5-5-目标管理的标准化" class="headerlink" title="5.5  目标管理的标准化"></a><strong>5.5  目标管理的标准化</strong></h5><h4 id="第6章：利用沟通视窗，改善人际沟通"><a href="#第6章：利用沟通视窗，改善人际沟通" class="headerlink" title="第6章：利用沟通视窗，改善人际沟通"></a><strong>第6章：利用沟通视窗，改善人际沟通</strong></h4><p>人际沟通的信息就像一面窗，分为四个象限，有效沟通就是这四个象限的有机融合。</p>
<h5 id="6-1-隐私象限：正面沟通，避免误解"><a href="#6-1-隐私象限：正面沟通，避免误解" class="headerlink" title="6.1  隐私象限：正面沟通，避免误解"></a><strong>6.1  隐私象限：正面沟通，避免误解</strong></h5><h5 id="6-2-盲点象限：利用反馈看到自身局限"><a href="#6-2-盲点象限：利用反馈看到自身局限" class="headerlink" title="6.2  盲点象限：利用反馈看到自身局限"></a><strong>6.2  盲点象限：利用反馈看到自身局限</strong></h5><h5 id="6-3-潜能象限：不要轻视每一名员工的潜能"><a href="#6-3-潜能象限：不要轻视每一名员工的潜能" class="headerlink" title="6.3  潜能象限：不要轻视每一名员工的潜能"></a><strong>6.3  潜能象限：不要轻视每一名员工的潜能</strong></h5><h5 id="6-4-公开象限：让员工尊重你，而不是怕你"><a href="#6-4-公开象限：让员工尊重你，而不是怕你" class="headerlink" title="6.4  公开象限：让员工尊重你，而不是怕你"></a><strong>6.4  公开象限：让员工尊重你，而不是怕你</strong></h5><h4 id="第7章：学会倾听，创建良性的交流通道"><a href="#第7章：学会倾听，创建良性的交流通道" class="headerlink" title="第7章：学会倾听，创建良性的交流通道"></a><strong>第7章：学会倾听，创建良性的交流通道</strong></h4><p>倾听是沟通的基础，善于倾听的人才能当个好领导。倾听不能止于听，在听的过程中要对信息进行解析，并给出积极的回应。</p>
<h5 id="7-1-用心倾听，建立员工的情感账户"><a href="#7-1-用心倾听，建立员工的情感账户" class="headerlink" title="7.1  用心倾听，建立员工的情感账户"></a><strong>7.1  用心倾听，建立员工的情感账户</strong></h5><h5 id="7-2-倾听的要点是吸收对方的信息"><a href="#7-2-倾听的要点是吸收对方的信息" class="headerlink" title="7.2  倾听的要点是吸收对方的信息"></a><strong>7.2  倾听的要点是吸收对方的信息</strong></h5><h5 id="7-3-肢体语言比语言更重要"><a href="#7-3-肢体语言比语言更重要" class="headerlink" title="7.3  肢体语言比语言更重要"></a><strong>7.3  肢体语言比语言更重要</strong></h5><h5 id="7-4用认同化解对方的失控情绪"><a href="#7-4用认同化解对方的失控情绪" class="headerlink" title="7.4用认同化解对方的失控情绪"></a><strong>7.4用认同化解对方的失控情绪</strong></h5><h4 id="第8章：及时反馈，让员工尊重你、信任你"><a href="#第8章：及时反馈，让员工尊重你、信任你" class="headerlink" title="第8章：及时反馈，让员工尊重你、信任你"></a><strong>第8章：及时反馈，让员工尊重你、信任你</strong></h4><p>激励可以让员工业绩翻倍，训斥会让员工陷于低迷，不同的反馈技巧结果千差万别。能够接受和给予反馈，是管理者保持竞争优势的关键能力。</p>
<h5 id="8-1-别用绩效考核代替反馈"><a href="#8-1-别用绩效考核代替反馈" class="headerlink" title="8.1  别用绩效考核代替反馈"></a><strong>8.1  别用绩效考核代替反馈</strong></h5><h5 id="8-2-警惕“推理阶梯”，避免误解和伤害"><a href="#8-2-警惕“推理阶梯”，避免误解和伤害" class="headerlink" title="8.2  警惕“推理阶梯”，避免误解和伤害"></a><strong>8.2  警惕“推理阶梯”，避免误解和伤害</strong></h5><h5 id="8-3-通过正面反馈，引爆你的团队"><a href="#8-3-通过正面反馈，引爆你的团队" class="headerlink" title="8.3  通过正面反馈，引爆你的团队"></a><strong>8.3  通过正面反馈，引爆你的团队</strong></h5><h5 id="8-4-负面反馈时，对事莫对人"><a href="#8-4-负面反馈时，对事莫对人" class="headerlink" title="8.4  负面反馈时，对事莫对人"></a><strong>8.4  负面反馈时，对事莫对人</strong></h5><h4 id="第9章：有效利用时间，拒绝无效努力"><a href="#第9章：有效利用时间，拒绝无效努力" class="headerlink" title="第9章：有效利用时间，拒绝无效努力"></a><strong>第9章：有效利用时间，拒绝无效努力</strong></h4><p>管理者只有科学地安排好事务的处理顺序，才能使工作效率的提高成为可能。涉及团队协作时，管理者要有激发成员的热情和创意的能力，以提高整体决策的效率和质量。</p>
<h5 id="9-1-把时间用在关键要务上"><a href="#9-1-把时间用在关键要务上" class="headerlink" title="9.1  把时间用在关键要务上"></a><strong>9.1  把时间用在关键要务上</strong></h5><h5 id="9-2-告别气氛沉闷、效率低下的会议"><a href="#9-2-告别气氛沉闷、效率低下的会议" class="headerlink" title="9.2  告别气氛沉闷、效率低下的会议"></a><strong>9.2  告别气氛沉闷、效率低下的会议</strong></h5><h5 id="9-3-如何正确又高效地做决策"><a href="#9-3-如何正确又高效地做决策" class="headerlink" title="9.3  如何正确又高效地做决策"></a><strong>9.3  如何正确又高效地做决策</strong></h5>]]></content>
      <categories>
        <category>management</category>
      </categories>
  </entry>
  <entry>
    <title>保姆级教你搭建V2RAY Airport</title>
    <url>/2020/04/22/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAV2RAY-Airport/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-CcMgtCUw" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="528423473" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="一-什么是V2RAY-Airport？"><a href="#一-什么是V2RAY-Airport？" class="headerlink" title="一.什么是V2RAY Airport？"></a><strong>一.什么是V2RAY Airport？</strong></h3><p>V2RAY Airport是一个网络转发程序，支持 TCP、mKCP、WebSocket 这3种底层传输协议，支持HTTP、Socks、Shadowsocks、VMess这4种内容传输协议（HTTP只支持传入），并且有完整的TLS实现，是一个非常强大的平台，借助V2RAY你可以透过防火墙，自由穿梭于网络。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhRw5j.jpg"></p>
<h3 id="二-玩转V2RAY-Airport需要会什么？"><a href="#二-玩转V2RAY-Airport需要会什么？" class="headerlink" title="二.玩转V2RAY Airport需要会什么？"></a><strong>二.玩转V2RAY Airport需要会什么？</strong></h3><p>其实对于普通玩家来讲，直接依葫芦画瓢，网上有很多教程，也可以实现功能。但是既然爱倒腾，肯定是希望能够明白里面的一些原理，毕竟好奇心害死猫，也是一个学习的过程。个人认为需要懂的两大核心是：第一个Linux操作系统，因为目前现在很多的核心服务器，都是基于UNIX或者Linux为内核的发行版而开展服务的，所以这一点必须要懂。稍后演示时，由于目前比较穷，没有去购买服务器而是利用矿渣自行改的一个基于ARM架构，安装的是Armbian系统（也是Linux操作系统）；第二个Java编程的基础，因为在某些情况下，你需要自行去写一些脚本在服务器上跑任务。其次还有一些概念啥的，自己也需要明白一些，比方说：端口，config文件配置，白名单……</p>
<h3 id="三-前期准备"><a href="#三-前期准备" class="headerlink" title="三.前期准备"></a><strong>三.前期准备</strong></h3><p>1.自行购买的境外VPS服务器，推荐买美国、日本、新加坡……，具体的度娘</p>
<p>2.服务器终端连接工具FinalShell(XShell、Putty)</p>
<h3 id="四-搭建过程"><a href="#四-搭建过程" class="headerlink" title="四.搭建过程"></a><strong>四.搭建过程</strong></h3><h4 id="a-VPS安装操作系统"><a href="#a-VPS安装操作系统" class="headerlink" title="a.VPS安装操作系统"></a><strong>a.VPS安装操作系统</strong></h4><p>在这里个人强烈推荐安装CentOS 7发行版的Linux操作系统，因为如果自己在安装过程中出现error，可以在网上搜索到很多成熟的解决方案，当然也有像Ubuntu、Windows……由于虚拟机安装的是Ubuntu的系统，所以这里就以Ubuntu示范，实则都一样。安装操作系统，可以在VPS服务商提供给你的个人管理里面操作，安装完成之后服务器会有快照，并显示目前运行状况。</p>
<h4 id="b-给Linux服务器安装宝塔面板"><a href="#b-给Linux服务器安装宝塔面板" class="headerlink" title="b.给Linux服务器安装宝塔面板"></a><strong>b.给Linux服务器安装宝塔面板</strong></h4><p>在这里个人推荐安装<a href="https://www.bt.cn/">宝塔面板</a>，它是一个可视化面板管理工具，提供友好的界面交互，我家里所有的Linux服务器都会去安装此面板方便管理。安装时请使用root用户执行，详细操作如下：</p>
<p>1.username：root，password：服务器密码，登录XShell</p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhRIR1.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhRHsK.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhWCsf.png"></p>
<p>2.命令行执行宝塔面板安装脚本命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/04/27/JhWPL8.png"></p>
<p>3.稍作等待，安装好后的界面如图，一个是XShell的，一个是web端的</p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhWMLT.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhWJY9.png"></p>
<h4 id="c-安装V2RAY-Airport-Server端"><a href="#c-安装V2RAY-Airport-Server端" class="headerlink" title="c.安装V2RAY Airport Server端"></a><strong>c.安装V2RAY Airport Server端</strong></h4><p>1.命令行执行一键安装脚本命令，这里使用的是非官方提供的脚本，但它是目前网上最好用的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/04/27/JhWYWR.png"></p>
<p>2.安装过程中，不用急，等待服务器响应，以下是In progress中，一些截图，反映一些情况</p>
<p><img src="https://s1.ax1x.com/2020/04/28/JhWay6.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/28/JhW0eO.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/28/JhWsFH.png"></p>
<p>3.最终安装结果如下图所示，根据提示分别执行一下代码，得到最终Client端需要的配置信息</p>
<p><img src="https://s1.ax1x.com/2020/04/28/JhWgSI.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/28/JhWv0U.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/28/JhWx7F.png"></p>
<p>这里注意一下：CentOS 7的系统，在使用前，关闭一下防火墙或者设置一下端口白名单，我是直接关闭防火墙的，执行下面这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service				</span><br><span class="line">#停止防火墙服务</span><br><span class="line">disable firewalld.service			</span><br><span class="line">#禁止防火墙开机启动</span><br></pre></td></tr></table></figure>



<h4 id="d-配置Client端"><a href="#d-配置Client端" class="headerlink" title="d.配置Client端"></a><strong>d.配置Client端</strong></h4><p>Client端iOS和MacOS的配置，这里省去配置过程，因为能用得起苹果的老板，不差这两个钱，自己买现成的就行，不要这么折腾。主要配置一下，手机Android端App和电脑Windows端</p>
<p>1.首先下载好<a href="https://github.com/2dust/v2rayNG/releases">Android端</a>和<a href="https://github.com/2dust/v2rayN/releases">Windows端</a>，直接链接到Github下载</p>
<p>2.以下图示分别是各自的操作，将之前的vmess粘贴，然后各自导入就好</p>
<p><img src="https://s1.ax1x.com/2020/04/28/Jhfi11.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/28/JhfF6x.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/28/Jhfuhd.jpg"></p>
<h3 id="五-V2RAY脚本命令和相关配置文件路径"><a href="#五-V2RAY脚本命令和相关配置文件路径" class="headerlink" title="五.V2RAY脚本命令和相关配置文件路径"></a><strong>五.V2RAY脚本命令和相关配置文件路径</strong></h3><h4 id="a-脚本命令"><a href="#a-脚本命令" class="headerlink" title="a.脚本命令"></a><strong>a.脚本命令</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2ray</span><br><span class="line">#进入脚本菜单</span><br><span class="line">v2ray info 					</span><br><span class="line">#查看 V2Ray 配置信息</span><br><span class="line">v2ray config 						</span><br><span class="line">#修改 V2Ray 配置</span><br><span class="line">v2ray link 					</span><br><span class="line">#生成 V2Ray 配置文件链接</span><br><span class="line">v2ray infolink 						</span><br><span class="line">#生成 V2Ray 配置信息链接</span><br><span class="line">v2ray qr 					</span><br><span class="line">#生成 V2Ray 配置二维码链接</span><br><span class="line">v2ray ss 					</span><br><span class="line">#修改 Shadowsocks 配置</span><br><span class="line">v2ray ssinfo 						</span><br><span class="line">#查看 Shadowsocks 配置信息</span><br><span class="line">v2ray ssqr 					</span><br><span class="line">#生成 Shadowsocks 配置二维码链接</span><br><span class="line">v2ray status 						</span><br><span class="line">#查看 V2Ray 运行状态</span><br><span class="line">v2ray start 						</span><br><span class="line">#启动 V2Ray</span><br><span class="line">v2ray stop 					</span><br><span class="line">#停止 V2Ray</span><br><span class="line">v2ray restart 						</span><br><span class="line">#重启 V2Ray</span><br><span class="line">v2ray log 					</span><br><span class="line">#查看 V2Ray 运行日志</span><br><span class="line">v2ray update 						</span><br><span class="line">#更新 V2Ray</span><br><span class="line">v2ray update.sh 					</span><br><span class="line">#更新 V2Ray 管理脚本</span><br><span class="line">v2ray uninstall 					</span><br><span class="line">#卸载 V2Ray</span><br></pre></td></tr></table></figure>

<h4 id="b-文件路径"><a href="#b-文件路径" class="headerlink" title="b.文件路径"></a><strong>b.文件路径</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">V2Ray 配置文件路径：/etc/v2ray/config.json</span><br><span class="line">Caddy 配置文件路径：/etc/caddy/Caddyfile</span><br><span class="line">脚本配置文件路径: /etc/v2ray/233blog_v2ray_backup.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>router</category>
      </categories>
  </entry>
  <entry>
    <title>Git的详细使用教程（三）</title>
    <url>/2020/04/20/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-KGGwxZWo" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1404906595" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="7-Git的冲突解决"><a href="#7-Git的冲突解决" class="headerlink" title="7.Git的冲突解决"></a><strong>7.Git的冲突解决</strong></h3><p>这种情况多产生于，多个开发者同步进行开发同一文件，远程文件被其中某一个开发者进行了push，导致其他开发者后续无法提交同步。遇到这种情况，一般处理很简单，直接在其他开发者本地执行<code>git pull</code>，同步一下远程已更改的文件，同步结束后，可以cat一下，查看文件有哪些修改，哪怕是说更改了文件名，文件内容，都可这样去进行操作。但是有一点需要自行注意一下，就是当修改了相同文件的相同区域（离的很近的几行）的话，需要人为手动处理一下。个人认为还是比较繁琐的，一个人提交同步一次，当若干人时，还要同步若干次。</p>
<h3 id="8-Git的分支合并"><a href="#8-Git的分支合并" class="headerlink" title="8.Git的分支合并"></a><strong>8.Git的分支合并</strong></h3><p>分支的合并，个人认为它是整个Git架构重最为敏感的部分，因为在实际的合并过程中会遇到各种各样的问题，原因参差不齐。那么首先对于正常情况才分支的合并，无任何问题的，直接执行<code>git merge branch</code>，注意：这里的merge是基于目前在哪一个branch上，将现有的branch进行merge，merge后保留的是原branch。其次就是对于非正常merge，现实往往就是这种情况，一般来说都会首先执行<code>git pull</code>，拉取远程最新版本，然后再进行push，此时根据报错信息的提示，修改相对应的文件内容，再次push。我一直就是这样玩的，麻烦虽然麻烦，但是文件多逐个修改，还是比较有针对性的，后期再push。还有一点，就是在看资料文档是会看到这个命令<code>git fetch</code>，其实这一步在我实际使用过程中用的很少，<code>git pull=git fetch + git merge</code>.</p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhRNqS.png"></p>
<h3 id="9-Git在Eclipse和IDEA中的具体使用"><a href="#9-Git在Eclipse和IDEA中的具体使用" class="headerlink" title="9.Git在Eclipse和IDEA中的具体使用"></a><strong>9.Git在Eclipse和IDEA中的具体使用</strong></h3><p>由于目前手头并没有In progress的Project，后期在遇到时再做详细更新，填补项目空缺。</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>Git的详细使用教程（二）</title>
    <url>/2020/04/19/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-glPhPnhu" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="399552614" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<h3 id="3-Git的内部构造"><a href="#3-Git的内部构造" class="headerlink" title="3.Git的内部构造"></a><strong>3.Git的内部构造</strong></h3><h4 id="3-1-HEAD"><a href="#3-1-HEAD" class="headerlink" title="3.1  HEAD"></a><strong>3.1  HEAD</strong></h4><p>它可以理解为是我们暂存区里最为重要的东西，其实质是引用的一个文件，这个文件引用的是：refs&#x2F;heads&#x2F;下的文件，打开发现有像master的字样，很熟悉的第一反应是跟branch相关。如果之前自己有新建过branch，那么此时也可以看到自己新建过的branch名。当进入以branch名的文件夹下时，利用cat去查看时，实则得到的是一段当前版本的哈希值。由此可以得知，HEAD下存放的是目前工作的是哪个branch。</p>
<h4 id="3-2-config"><a href="#3-2-config" class="headerlink" title="3.2  config"></a><strong>3.2  config</strong></h4><p>一般来说，对于所有的config文件，不管是什么里面的，第一反应是某些配置文件。之前在上面也说过，当Git Bash安装后，自己配置一下全局文件，就是对这个文件进行配置，执行的命令是：<code>git config --global user.name</code>和<code>git config --global user.email</code>，当需要对本地文件进行配置时，只需要把global改成local即可。特别注意的是，这里配置本地时，仅对当前文件实施本地配置，其余的还是运用的是全局配置，这一点值得关注一下。</p>
<h4 id="3-3-objects"><a href="#3-3-objects" class="headerlink" title="3.3  objects"></a><strong>3.3  objects</strong></h4><p>这是专门存放文件的一个独立文件夹，那么对于objects&#x2F;pack&#x2F;这个文件夹，它不是一个版本文件夹而是对于当前目录下有的版本文件夹进行打包处理，节约空间。假设此时需要就某个版本的文件夹查看里面文件到底是什么类型，可以执行<code>git cat-file -t 版本号（哈希值）</code>，查询结果包含三种：commit、tree和blob。假设目前获取的类型是tree，此时再去查看一下这个文件夹下的文件，可以执行<code>git cat-file -p 版本号（哈希值）</code>，反馈里面有什么文件，假设此时再去查看该文件是什么类型，执行<code>git cat-file -t 版本号（哈希值）</code>，那么反馈的blob。所以在这种框架结构下遵循这样的一层逻辑关系：每一个commit，都对应着一个tree和一个blob，其次每一个tree又对应着一个blob。其实这里的tree是一个内存的地址。</p>
<h3 id="4-Git的版本回退（回滚）"><a href="#4-Git的版本回退（回滚）" class="headerlink" title="4.Git的版本回退（回滚）"></a><strong>4.Git的版本回退（回滚）</strong></h3><p>个人比较喜欢叫回滚，一个意思，对于Git的版本回滚，从理论的角度上讲，分为以下三种</p>
<h4 id="4-1-暂存区恢复和HEAD一致"><a href="#4-1-暂存区恢复和HEAD一致" class="headerlink" title="4.1  暂存区恢复和HEAD一致"></a><strong>4.1  暂存区恢复和HEAD一致</strong></h4><p>个人对于这一层的理解是：在不涉及到工作区的情况下，保持add操作和commit操作两个区域之间的一致性。前期在使用的过程中，分两步走，先add，后commit，当去执行<code>git reset HEAD --文件名</code>，相当于做了一个add的撤销动作，让它恢复原始没有commit的那种环境下，这样就保证了文件和HEAD的文件一致了。但是这里要注意的是，它是撤销add的操作，工作区该文件，修改了就修改了，不会有任何变动的，并且这个操作是不会修改文件内部的信息，不像执行<code>git reset</code>，尤其注意。</p>
<h4 id="4-2-工作区恢复和暂存区一致"><a href="#4-2-工作区恢复和暂存区一致" class="headerlink" title="4.2  工作区恢复和暂存区一致"></a><strong>4.2  工作区恢复和暂存区一致</strong></h4><p>这样的回滚类似第一种回滚，当对第二种回滚方式理解完发现，其实就是将顺序倒过来，保持一致性的，这就是回滚的实质。之前我们提交文件是的流程是：编辑文件（工作区）→add→本地同步（暂存区）→commit→推送远程（版本库<HEAD>），那么现在回滚，就是倒着玩，没有技术含量。执行<code>git checkout --文件名</code>，那么这样就会把本地的文件cover掉，实现工作区和暂存区文件一致，顺理成章的事。</p>
<h4 id="4-3-回滚到历史的任意版本"><a href="#4-3-回滚到历史的任意版本" class="headerlink" title="4.3  回滚到历史的任意版本"></a><strong>4.3  回滚到历史的任意版本</strong></h4><p>此操作一般来说是在深思熟虑之后，谨慎操作的，因为当去执行<code>git reset --hard 版本号（哈希值）</code>，也就是回滚到指定的版本号操作，那么从指定版本号开始往后所有的版本信息将全部被clean且无法恢复。假设指定回滚到开始的第一个版本号，那么你中间commit的所有版本信息将全部置空，所以一般在实际中，很少这么干。</p>
<h3 id="5-Git的忽略文件"><a href="#5-Git的忽略文件" class="headerlink" title="5.Git的忽略文件"></a><strong>5.Git的忽略文件</strong></h3><p>简而言之，就是当创建的文件或者文件夹，不想被Git管理时所采取的操作，会有一个专门的名为.gitignore的txt文件，在这里面，可以任意add想被ignore的文件，支持文件，文件夹，通配符。到那时在这里的话也得注意一下，就是在必须先事先想好哪些文件不被管理，如果在被Git管理后，再去add ignore，它将会是无效的，这里是一个盲区，很多人不会去注意。</p>
<h3 id="6-Sync-to-Github"><a href="#6-Sync-to-Github" class="headerlink" title="6.Sync to Github"></a><strong>6.Sync to Github</strong></h3><h4 id="6-1-GitHub的公私钥配置及创建仓库"><a href="#6-1-GitHub的公私钥配置及创建仓库" class="headerlink" title="6.1  GitHub的公私钥配置及创建仓库"></a><strong>6.1  GitHub的公私钥配置及创建仓库</strong></h4><p>这里不多记载，详细参考<a href="https://www.carrol.xyz/2020/03/28/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E4%BD%A0%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">这里</a></p>
<h4 id="6-2-同步推送至远程仓库"><a href="#6-2-同步推送至远程仓库" class="headerlink" title="6.2  同步推送至远程仓库"></a><strong>6.2  同步推送至远程仓库</strong></h4><p>其实这里在上面的Blog文章里也有讲过，首先将本地和远程进行连接，执行<code>ssh -T git@github.com</code>，之后再执行<code>git push -u origin 分支名</code>，成功结束后给到相对应的回馈。</p>
<h4 id="6-3-删除本地和远程仓库的关联"><a href="#6-3-删除本地和远程仓库的关联" class="headerlink" title="6.3  删除本地和远程仓库的关联"></a><strong>6.3  删除本地和远程仓库的关联</strong></h4><p>此操作适用于更换远程仓库地址，比方说想从Github远程仓库切换至Gitee远程仓库，执行<code>git remote remove 名字</code>，名字默认是origin.可以验证一下，取消关联是否成功，执行<code>git remote -v</code>，如果没有任何信息反馈，说明已经取消成功，反之失败。当想重新关联新的远程仓库地址时，直接执行<code>git remote add origin URL</code>，就可以关联成功了，也可以自行验证一下。</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>Git的详细使用教程（一）</title>
    <url>/2020/04/15/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-STpntFJX" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="208902" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>



<h3 id="1-Github的注册和Git的简述及安装"><a href="#1-Github的注册和Git的简述及安装" class="headerlink" title="1.Github的注册和Git的简述及安装"></a><strong>1.Github的注册和Git的简述及安装</strong></h3><p>这里跳过前期的准备工作，可以参考<a href="https://www.carrol.xyz/2020/03/28/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E4%BD%A0%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">这里</a>自行操作完成，安装后别忘记做一个全局配置，里面也有提到。另外在进行Demo时，请建立一个空的文件夹。</p>
<h3 id="2-Git的基本命令"><a href="#2-Git的基本命令" class="headerlink" title="2.Git的基本命令"></a><strong>2.Git的基本命令</strong></h3><p>记载前，放几张关于git的流程图，方便后续理解</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh2X3q.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhRCE4.png"></p>
<h4 id="2-1-git-init"><a href="#2-1-git-init" class="headerlink" title="2.1  git init"></a><strong>2.1  git init</strong></h4><p>此命令是指初始化一个文件夹，执行完毕后，会在目录里看到一个隐藏文件“.git”，当然我这里说的隐藏文件是基于Linux操作系统里的，因为Git的命令行，如果学过Linux操作系统的，不难发现，两者很相似，只不过有些Linux操作系统的命令行在Git里不能简写或者说是缩写。在这个隐藏文件里还有很多的文件，此时的目录结构是Demo&#x2F;.git，我们把除了隐藏文件之外的所有Demo空间称之为工作区，“.git”我们称之为版本库。当我们进入Demo&#x2F;.git，如果我们往里面添加心得文件，稍后会看到有一个文件是“index”，我们把它称之为暂存区。</p>
<h4 id="2-2-git-add"><a href="#2-2-git-add" class="headerlink" title="2.2  git add"></a><strong>2.2  git add</strong></h4><p> 此命令是指将一个已经编辑好的文件添加到暂存区，一般来说我们会在其后面添加上相对应的文件名。这里留意一下，就是当同一个文件被修改后，如果想再次提交到版本库时，一定还要进行一次，<code>git add</code></p>
<h4 id="2-3-git-status"><a href="#2-3-git-status" class="headerlink" title="2.3  git status"></a><strong>2.3  git status</strong></h4><p>此命令是指查看目前暂存区的状态，一般基于上面的添加完文件，暂存区状态发生改变，会给到一个状态的反馈。</p>
<h4 id="2-4-git-commit"><a href="#2-4-git-commit" class="headerlink" title="2.4  git commit"></a><strong>2.4  git commit</strong></h4><p>此命令是指将暂存区的文件，正式提交到版本库里，留意一下，这里的提交文件是指将暂存区的文件进行提交，没有放进暂存区的文件，是不会被提交到版本库里的。一般来说，常见的命令行是：<code>git commit -m &#39;需要备注的信息&#39;</code>，后面的参数<code>-m</code>是指提交时进行备注，可以理解为是message的缩写首字母，单引号里面是备注的信息，我在正常使用的过程中，会把重要的修改信息，提交在这个备注里，方面后续版本回退时，一眼知道，该回退到哪个版本。有时候在看资料也会看到这样的两条命令行：<code>git commit -am &#39; &#39;</code>、<code>git commit -amend</code>和<code>git commit -a</code>，前者的参数<code>-am</code>，是将之前已经commit进版本库的文件，如果发生修改，直接再次提交到版本库，而不需要再像之前一样，再次add后再commit，即跳过了一个上面刚说的再次<code>git add</code>的步骤；中者的参数<code>-amend</code>，是指修改最近一次commit时message的信息，一般多用于commit时少写了某些信息或信息commit错误；后者是指强制性的将工作区改变的文件直接commit到版本库。</p>
<h4 id="2-5-git-diff"><a href="#2-5-git-diff" class="headerlink" title="2.5  git diff"></a><strong>2.5  git diff</strong></h4><p>此命令是指将变动修改的文件，进行对比，看一下发生了怎样的修改，但是前提是你修改后的文件已经add进暂存区，然后再去执行<code>git diff --cached</code>，最后一行如果有“+”或者“-”的字样，代表添加或者删除了什么。注意：在执行<code>git diff --cached</code>，后面没有去添加参数<code>--cached</code>，那么此时它所代表的意义就发生了改变，此时看的是工作区和暂存区的区别，加了的话，看的是版本库和暂存区的区别。这里一定要特别的留意，很多人会经常在这里被绕死。执行<code>git diff --cached</code>，默认会把所有文件的修改变动全部列出来，如果想单独对一个文件的变动修改，再加一个文件名即可。</p>
<h4 id="2-6-git-reset"><a href="#2-6-git-reset" class="headerlink" title="2.6  git reset"></a><strong>2.6  git reset</strong></h4><p>此命令是指将之前修改变动文件里面变动的信息取消掉，通常称叫回滚。</p>
<h4 id="2-7-git-mv"><a href="#2-7-git-mv" class="headerlink" title="2.7  git mv"></a><strong>2.7  git mv</strong></h4><p>此命令是指将文件进行重命名操作，具体格式是：<code>git mv 原文件 目标文件</code>，这个命令很Linux操作系统里的cp命令很相像。但是这里注意一下，此命令会同时修改本地文件名和版本库里的。</p>
<h4 id="2-8-git-log"><a href="#2-8-git-log" class="headerlink" title="2.8  git log"></a><strong>2.8  git log</strong></h4><p>此命令是指将之前一系列的操作，干了些什么，全部以日志的形式展现出来，非常的详细，里面会包含每次提交的唯一版本更新迭代号（实则里面是一段哈希码），执行人是谁，账户是什么，执行日期是什么时间，commit什么信息，都可以看到。很类似Linux里的ls -la。同样的，在查阅资料时，也会看到其他命令行：<code>git log --oneline</code>、<code>git log -n数字</code>、<code>git log --all</code>和<code>git log --graph</code>.一一说明，第一个命令行是指以简洁的一行式查看历史；第二个命令是指查看最近的多少次；第三个命令是指查看所有branch的所有记录；最后一个是指以图形化的方式去查看。</p>
<h4 id="2-9-git-branch和git-checkout"><a href="#2-9-git-branch和git-checkout" class="headerlink" title="2.9  git branch和git checkout"></a><strong>2.9  git branch和git checkout</strong></h4><p>这两个命令，我是放在一起去进行学习的，因为涉及到新建分支，查看分支，切换分支以及删除分支，也是Git中最为繁琐复杂，让人难以理解，很大程度上会自行绕死自己，走不出死胡同。</p>
<p>git branch这个命令行是用于操作git分支，因为在开发过程中，为了不影响其他人员的工作进度，会不断的建立新的分支，后期开发完毕后，再进行合并。常见的命令行有：<code>git branch -v</code>和<code>git branch -d 分支名</code>.前者是看本地有多少分支，后者是删除叫什么名字的分支。</p>
<p>git checkout这个命令行是用于创建和切换分支，常见的命令行：<code>git checkout -b 新分支名 原分支名</code>和<code>git checkout 分支名</code>.前者是创建一个新的branch，前面的参数<code>-b</code>要留意一下，后者是切换分支。特殊的是：git checkout 在去创建新分支时，可以就git log中查看到的哈希值，直接去指定版本号，只要保证其唯一性就行。</p>
<h4 id="2-10-分离头指针"><a href="#2-10-分离头指针" class="headerlink" title="2.10  分离头指针"></a><strong>2.10  分离头指针</strong></h4><h5 id="a-什么是分离头指针？"><a href="#a-什么是分离头指针？" class="headerlink" title="a.什么是分离头指针？"></a><strong>a.什么是分离头指针？</strong></h5><p>首先理解分离，就是在主干线以外的区域，进行派生出一个新的副干线。它是不属于分支的分支，可以理解为缓存区域，在这个区域里做的任何操作，不会影响其他区域。后期如果这个区域的修改不错，那么可以进行新建branch，键入：<code>git branch 新分支名 修改后临时版本的哈希值</code>，如果修改的不如意，随时可以进行丢弃，不影响。</p>
<h5 id="b-什么时候用到？"><a href="#b-什么时候用到？" class="headerlink" title="b.什么时候用到？"></a><strong>b.什么时候用到？</strong></h5><p>一般情况下，是在某个开发版本过程中，尝试添加新的功能，临时给的一种需求。那么如果在原来的基础上去改的话不太好，因为它会影响原来的branch，假设要回滚，还要回滚好多的东西，那么此时就可以进行分离头指针。</p>
<h4 id="2-11-gitk"><a href="#2-11-gitk" class="headerlink" title="2.11  gitk"></a><strong>2.11  gitk</strong></h4><p>此命令是直接打开一个图形化界面，直观清晰的展现出一个树状关系图，可以看到各个版本的信息，包含父子关系，提交时间，修改信息。这里提及一下，在gitk出现的图形化界面中，选择View&gt;New View&gt;All refs&gt;OK后，可以进行手动tags，于此同时可以关注一下版本之间的关系，其中Child是指当前版本的下一个版本，相当于子系；Parent是指当前版本的上一个版本，相当于父系。也可以查看到，当前一共有多少branch拥有此版本。</p>
<h4 id="2-12-git-rebase"><a href="#2-12-git-rebase" class="headerlink" title="2.12  git rebase"></a><strong>2.12  git rebase</strong></h4><p>此命令称为变基操作，说直白点就是，指定修改历史版本中的提交信息，一般来说会结合<code>git log</code>，去一起进行操作。执行<code>git rebase -i 版本号（哈希值）</code>，那么后续版本所执行的所有变动都会呈现出来，同时界面会把所有的命令展现给开发者，可以自行选择command。</p>
<h4 id="2-13-git-rm"><a href="#2-13-git-rm" class="headerlink" title="2.13  git rm"></a><strong>2.13  git rm</strong></h4><p>此命令执行的是删除操作，这里会分删除工作区的文件还是暂存区的文件。删除前者，直接执行<code>git rm 文件名</code>，删除后会把相关的变动放到暂存区里；删除后者，直接执行<code>git rm --cached 文件名</code>.</p>
<h4 id="2-14-git-stash"><a href="#2-14-git-stash" class="headerlink" title="2.14  git stash"></a><strong>2.14  git stash</strong></h4><p>此命令主要的运用场景是：临时任务的加塞。说直白点就是，当开发者在进行开发时，突然接到验证某个历史版本中的Bug，既不能放弃目前所开发的代码，也不能不去执行Bug的验证，那么此时就运用到此命令。假设目前所处的场景就是，我作为一个开发者，代码开发到一半，这个时候我执行<code>git stash</code>，系统紧接着会给到一个反馈并附有临时版本号（哈希值），如果还是不放心，可以进一步执行：<code>git stash list</code>，所有临时保存的版本号（哈希值）都会呈现在下面。这是选择要验证某个版本，切换过去，该是什么流程就是什么流程，验证改完Bug后，是要回到原先的开发环境，这时执行：<code>git stash apply</code>，就会回到原先的开发环境，如果出现文件内容有更改，影响到目前开发的版本，那么系统会用类似&lt;&lt;&lt;&lt;&lt;&lt;……………….&gt;&gt;&gt;&gt;&gt;&gt;这种样式去提醒你。当然有时查看资料时，也会看到：<code>git stash pop</code>，此命令是指将之前放在list下暂时保存的缓存移除掉，所以要小心执行此命令。</p>
<h4 id="2-15-git-clone"><a href="#2-15-git-clone" class="headerlink" title="2.15  git clone"></a><strong>2.15  git clone</strong></h4><p>此命令是指克隆某个仓库，它所支持的协议有很多，包含经常接触的http，https，ssh，git……，形式是：<code>git clone URL</code>，这里有一个简便的用法，如果访问Git URL进行clone，clone一般都是想要的是master分支，需要指定用户名去进行登录，执行：<code>git clone 用户名@URL</code>，后续输入密码即可。我经常使用的环境就是进行Router固件进行编译时，会经常clone OpenWrt的仓库进行操作，操作系统会去使用Ubuntu发行版。</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>版本控制工具的相关介绍</title>
    <url>/2020/04/13/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-cbcIgzPF" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1355394867" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p><strong>版本控制顾名思义就是对每一次发行的版本进行一个管理，方便后期的维护及查阅。随着项目时间的积累，版本的更新迭代，需要用一个工具去进行管理，前期老式的很多都会接触CVS，后来SVN的出现，替补掉了CVS，而现在其地位也逐渐被新的工具Git替补。</strong></p>
<h4 id="一-版本控制的基本分类"><a href="#一-版本控制的基本分类" class="headerlink" title="一.版本控制的基本分类"></a><strong>一.版本控制的基本分类</strong></h4><h5 id="1-本地版本控制"><a href="#1-本地版本控制" class="headerlink" title="1.本地版本控制"></a><strong>1.本地版本控制</strong></h5><p>记录文件的每次更新，可以对每个版本做一个快照或者是记录补丁文件，适合个人使用，比如说RCS。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh2gNd.jpg"></p>
<h5 id="2-集中版本控制"><a href="#2-集中版本控制" class="headerlink" title="2.集中版本控制"></a><strong>2.集中版本控制</strong></h5><p>所有的版本数据都保存在Server或者是一个集群上，协同开发者自行从Server上同步更新或者上传自行修改后数据。但是其最致命的是：假设Server暴毙，因为整个交互过程都是依赖于此，那么会影响整个项目的开展进度，所以一般来说，会进行定期的备份，防止意外情况的发生。比方说：SVN</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh24jf.jpg"></p>
<h5 id="3-分布式版本控制"><a href="#3-分布式版本控制" class="headerlink" title="3.分布式版本控制"></a><strong>3.分布式版本控制</strong></h5><p>所有版本信息仓库全部同步到本地的每个开发者，方便本地查看所有历史版本，可以不连接远程仓库，进行离线本地提交，后续联网后，直接push到远程仓库就行。由于是全程本地作为暂存区，第一会占用本地空间；第二因为覆盖全版本的相关文件，暴露性比较高或者说安全隐患比较大，也正因为如此，所以Git是不能完全取代SVN的。比方说：Git</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh2bNj.jpg"></p>
<h4 id="二-SVN和Git的主要区别"><a href="#二-SVN和Git的主要区别" class="headerlink" title="二.SVN和Git的主要区别"></a>二.SVN和Git的主要区别</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="left">SVN</th>
<th align="left">Git</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否需要Server</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="center">是否依赖网络</td>
<td align="left">完全依赖</td>
<td align="left">不完全依赖</td>
</tr>
<tr>
<td align="center">文件存储格式</td>
<td align="left">按原始文件储存</td>
<td align="left">按元数据储存</td>
</tr>
<tr>
<td align="center">有无版本号</td>
<td align="left">有</td>
<td align="left">无</td>
</tr>
<tr>
<td align="center">分支操作是否影响其他开发</td>
<td align="left">影响</td>
<td align="left">不影响</td>
</tr>
<tr>
<td align="center">提交操作</td>
<td align="left">commit直接在Server上</td>
<td align="left">commit在本地上，可后续push</td>
</tr>
</tbody></table>
<p>如果后续在笔试的过程中，刷到这样的question，这里提供一个answer</p>
<p>SVN是集中式版本控制系统，版本库是集中放在中央服务器上的。由于工作时，用的都是自己的电脑，所以需要先从服务器上得到最新的版本，然后去开展工作。完成后，还需要上传到服务器上，集中式版本控制系统必须进行联网才能工作，对网络带宽要求比较高。</p>
<p>Git是分布式版本控制系统，无需中央服务器，每台电脑就是一个完整的仓库，工作时可以不需要联网，毕竟仓库数据全部Sync在本地。具体的协同方式可以参考上图，Git可以之间看到更新了那些代码和文件，执行代码：<code>git log</code></p>
<p><strong><u><em>可以这样讲，<a href="https://git-scm.com/">Git</a>是目前最先进的分布式版本控制系统。</em></u></strong></p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>三月樱花盛开，与你不期而遇</title>
    <url>/2020/04/10/%E4%B8%89%E6%9C%88%E6%A8%B1%E8%8A%B1%E7%9B%9B%E5%BC%80%EF%BC%8C%E4%B8%8E%E4%BD%A0%E4%B8%8D%E6%9C%9F%E8%80%8C%E9%81%87/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0401b8720f0fceb3f910aca45ee04bde1c9ae03a1eb1b20e858654a2cdf9f3d9">942afdc5beeae7ce54d6c3b9e171a8c5e36f8b33287be542cad8fa0b3de59cc32c93165365faf78182a4aa613b16671aa799334218bb219527d071b9166bfd661d6f6a5e0e473f99f37298c156e1456a3b2a15bd6c4a8ec0f024138fae7a7bf59b13b0872e914cdef7cce5762f43dfa30bdc9bbde4768b61fa756984a448b61c6528d9b0c0396726db3eabaf559ec42a4ebd9a20ced33b0f1e53c104da9176493a3436430711310d365f31d3b75c823d036dfac2e31e529d47696731dbe7749c76fab9e4ebcf9757244333eead6bf7f98ddace462f48076e6a76ad8a50cbd045c74ad8f799d4b55b8b8c3e2e4c674ce0cb8a2c99ecb315c88a0a5d0aa2bc30e305815cecb20c5c1099418341e534adeaafdc7e9a526b0c6ce4d9beb5c01c780fa71b2e7f824df2f29b10c5ed94dcdf41d358b245731c4f46ce57a384f25cbe3850ba6bb821e2734618c7fbd172fdf53a52a16df5630e823a059a3b13350d3fb9b0a27754f0e3b71c5bcc2980d2833b84c2e6bc413ea9ab8bf259454510f707f8982d4b2d50372047b336e0fa2ef38ce28a4de0dda3af114df6d741dccbd6d16774cc726b07ecd5c5afd1e6908e96fe8ae178b6c6711b939daf0c4e1c06102403ade0f5481bfdd9d0fb90f596c0766084c2738b06520e31cfa7c65976e26fd600f810cde944dc8731d93c1ace3f30fab09f7aee15c8c534e7733491448a8606175ad594fbfadc7ce94ee84fc10b5d712db8dfa963a8a07f8b1c4f44647cbf6031f4fd152163f016bc11ecc4d39c1bcfc075937e10a3ea487732631295a16d75c17004185b73a8225ca339cb747aad18b3db844dff5c4fa03f7e6b69d75a78715201cbe9617be7cad8ba4d2fb7c02f9b969b50cf9e604c58af37745d428fe346a2d1291db25c67249c8616a39353578400dc224afbd603af1e4820a450c5e4cbccd966f3ee26aed40e6da1c7fe825e80d0969e2671a19e029e9abf93bc67cbfb463e4f8d0719d31366056132be8065ef0842212f7cdf5122d70d9c36f038d50c73b74141a3624d3356e5caa751ceb73f199b5dbdcd612387c04112db1e759c27fcdce768db10484797aba10a03e4576be33fe510a1a972c15291fee7b162fa1a82d2030690455dc972f4c4ec691eaa32184bc7f80d93e556d2c0156056b52fd58d68c8f9215f0154ca1a1c3b25e2d79c0f9d5870bc2c0ca0e662485214c78b0055e2554a615020a38052e80584b4fc33233dd5156c1e18319a087b476d21c119b21a12bdc718c73dfccde595bccf4d288f4fb14d5d2cae38b1d9676aafcf34cb5e3f33df0be31004bb28d88bab6cc6a0727588c970bfa0648cbe5a548f3a02a6f2c604c1034232487113acd1b792fa959627058950423459352bf376d82af88a98b47362ad9c2b7fba4bdaea86a30f1d8a0bf9276efcbef9174caab50db96f3b429e9df2ee76d3d9dd144ecdfe51fe5cb7c3edfe91d3c99b92fc35b2aa1d536b0cea1fd2b3c2c71707cb5ba01ac54d67db710889d8b4d416db2f6b6977bf90790ef03b1994a77156254be4883a083fe89d9b04a20b17d7fc9a037d5a4b77990bb8dd1ad49c09d232161d4de9688d4f093bc6f1e16b519b781dae5edecf630c33acf8d0ca9c260234df3220ffa5da3845a89068f55b92f6903e9c46c129b79e05cc5872d515de2a154ea8552284bba1c79a7c9e5f1319d5f883f5c4a6f91fdecec468db0a16326789a6e8a9b90a83c3ec978443a122e54a8cc24e2d4529134565c9f7d566bff3b01bc27d2c8c386c6780faf9a936956897271cb5b2b240f066eef0dd6bdc3ff52a3c1e90ca0b0ee2d385fe3fa32781430989b2ac0d5bbe70daa0cfa9863c5524910676d266a7746263d2dc35a89091ec88b7d5569e65160dcb6cb6c166c676e7eae8599cecdb8d708d9b6f5ec5b63d355fcfb56d586ce25bb011ed0bc04280a9e84b0356ebc533f13e5c4060be052105ad2c8bc62792f6e1601a74898851a17c4664c0a932a418fda3b5f4af0a97b2dc752b3e42f197ffd8235b0951a1a0c2464bc620427834abc5deaab7b534ea7434dd7fc8e776305ec0e295e1c727ef954cc3959ead0e91b0af9b11f16f5b016b599fae762057698b6e96ad762b0dd01e52acd04f56909a8c6d68f5601713c5e912702a3b911105f3d3d2ebef7ae93e147e7d960c71d188e2c96e3b6861f62fe15741b8fc1d7e778a7689786152700e4c84b330408896856179acf083dd74f591829c9c63fb72471dc86df9dc5baf700f3b03635e2d586137f60ff6cd554eeea3619709337136351d9c013df7e6d18f558694cf76157ac6dce0368b31866b0994f355cd452f3adba07c1262e4c49f1461c0282c7db2331a04240662a9996903bbd068554f6e6fde5765987e5a358a76b192562746c5882cf54f5a1a8b202dd73d4f7739974d5506f722227e9b08615ece80f3e6ffec4417a24eb6957191254d198da0f42b2512c7804b3d02fa2b25580bb973cab74c144e3500a49c89171b2d377b277de3ecb3b5d57a41d7dbb40e7792151878861d464c56898c05a668ebf3c11f6550259c0af7206b1947f3da0bc0142a00936f7957bd67215dc0cf55cdd37c19b9b09651e426f42be9ca7f647cda916ec255a5417ff2c041a49d3eca44372da1e6d03d90c684d8b324d5d150d2305506e7896b9d69398ef11426010eac7d025f5d75b5040b44f16bb31ba70f3f4c4b2e59ba7ad1b46f7423060d474639118b78611f9cf9a49ef1c91be5c8775116af7efe58d04ebec6cbc8f051838efe8f8159efa9abcc2cca371818b34acd903b2dbe9da3f8dce98ba712fd7333005efa8bf6c456cbfeb618a7ee650356121c1fc5df7bb8e5442ef51e53f6766adcd9409cf304104bbb9a8813f559167c9cf6adafb06f5b4ded7e971051f23d35e23005d3b0856eec50fb015c738a2a76d5646ef096f4ac72ee0cfa43cca5d19b625b037c3757d03d17e90fb74a567c89b52ddcb81fced48ac7e47bdc3e407476246b7e489fa2b6306628dcfe9b1d8926a03671bff20b7637fbb8f4d1d72b04583a7dfe828fe3497d87673ad2914c55a14f366c623c215fbc7d6deb95f2fec41235c940dde73e4ccb6f75d4d18ed8dd4ae76cacc27d1af2c7f555fbcd04bd88c678a9247446f61584239ac60430e16133a4db7a368c0ef9334521b7fe68be8431b66311d133d403b09170630ddeee26a7ecef6ccc0b52649969dd21cd5f4d5213394cc8d4094260d63cdd8de955cdb92b0bf83f6e9ab66d7470139109d16da4bde3c71b7cc81c3362ee3c81f2723148f6171c2f9acad1391a1ae22717c839511d8ed2263e96a1c12d16adfd2272cf9f59d67bac7e65023f9884146931366e44208a1abae1f2e9c037876ef06c84fe443c019f21a31bfa5cf22ebe41fb282885a0c950e7bb68884a90e43369b2c90c303b5117fafa3fcfc3cad95c9fa3b59957adb1f4d21a77e92ddb8a99e392076ab73682927fc8a5f6db593af98fcc219e79e1e1288d6e52b4c2588fc5e9b44886be97692ee2e23fdbd5a30855cb1c91d4c964056e951812eace5256fa1a5e3a14407893ed4586e7f1d7cfd05182d79fc8922c377a77838dd197cdd93a8f90821bcf86e4adbf0030dd4f269ebe4c04aead02022fa4f9a17365c0e85d3a46ad4727694cbeef6a4506ee9cfb67bdb195b8050619e5ebec0a29ea8672a48c82285fee52e93537e1fb1ed7d980e8b4a6331129cfe1bbb32acced0e816feb6fe64bcadc0e12e472036732ba3119ae8ce1dda7ea20175f8563f15d7ec9545c903c21574571107bd4a088ed105a1c2db481cff7b702dc9a1afc760f1392196682273c00c921dd9a2a616a4a9fa45d878879f9835649583457f9ead9f66b95049a850c41c70a3962a51aa623727102fe990420481dd1c5e21f40ee9bb7a11696f689bb0b1980c67fe01ebec149b18849eeb35fc4fe12e63351eb989b2f576f8ab1fb07863814ef8b09c9fcbce1dad5617876e99bb42650dbb70e4ee000bb034a4a23ab04c04be8cc529f96ef02f9fe3d23bfd7a7fb42faad724ab62ef1177497788ff5029e6141605996313fc0429d20242f3124a19be6f0669cfef90dadd6e1d52f62953576440e89ab747e17291f8178f04f081eac9c0c47f0213163d1baaa830377171096e586cdfd64a70e666318b13fae79b60f681809dad67dc0de6b693b183119eaa92176cfe97df3c21b2a0fc889895892a5b50f7a96f051231bee345d2d636450ed6a84e1fba010434d61c86a6534cc46a2dabcc2cf9587abc2bec7f7edc61c634097f42f0a47266ccec3e2558ee597bcdd131337180317d1a0dd81e46e9c4f49a1ff0bec07a07f43447f23bb44013b3618c7d1d0a0a089797daf31e74b2766aab7c2725147864848fcdbdfc7653ae51f2ba6e6d64afb42eb036b4479133db1cdcde2080517db1c6cd89635d19b619c1627435004948c70b939c1a455ddbe3c9aa35cad6d0f670b794e0442e5453d9a9b42cab6b53b6c07ac7f0b588f599fc071e57522d8a9f6f3edcb6c90ae039f66fb7cc7cc8aad9bbf91d585b139e405342dce00ed0a9d079f26c8c1328281cb58035275e560c607c035d91bd2327aa03ce95a954a9792dc7933f47aae38765b2bed3ee295c45581f333531823d11e1ff17664fa43dad00c7cb66d099dd19fe8693a5dee4621d57cb168908a6ede49a4ebe8d727049c99ab9bfd9cda12017f54f02606f7cb8e0ba137663041e7824057de0caa7e085592df3375c7f89dfec7d426421bff8750b1aec309f5e0028302e9f0ddfa0a0ecae8ca6cfd34890c5f5c0d92973af1c1459e60b9f8e763754b23946fc9ca08bb7e2882a659e3e8b48331a943ce5121f241e48a58ce3b582b7b1b29a9ba121e7b7e510f7a67a5ac9d144bcbaa915c2e1af0e93b25ea1705b738b26fc858d906503e637729a134ea8a4e7b8d262b75f97a56f585b66c617f2ad0fba1222fa69c6ccd726d0318b272565b8a92c090216097e1efbdca3b5c730e696713a487bc88572c8acaee61f00fee11003ca4fa5ccb0e7f325c17d312fd41f6184047136847e365fa42bf4efbf2ae0e605fc6525e5736f832615894f50687b011d435e56972f685e86ec9a6531309927f709331d26ce414424d33c7cc8929273214102a3fc7a374b9f708662c37336f90ee0e56723bb8c7c1e769f9e9c0b848cd880d695a625cb9a75eb780b693d64b25f012c521f12b12f8defed24d8938c5676ac1870d904b8f50f26f3e9b5ee9051e5a8149aaea72fc1ba9125d99dc1bceaa784c494a81395905adff8e72e0b9ec269a6cbb50d2b67dc48ad6ee3679642d34617de6fb5688ad523cf8966380a5d5a11efbe3375ec2b7d6f34481d0a733433ae700b388601865a998f46ff4d8067f3e2e464f8e7ae7be731584d91545782ccc26d474fe030faad75f319f23526bc8688ba1a0446530daee5102f7c2b37e238d4a1dde11dfe782a6d2281f21f8d4afd7382bdcffffe6b5f46863c4310f05bfd6a8259d1b2611da1f739b8c9357b3748edf0d13c6f810a54d3d0b1ef52e6f22f6b5b26674ad3903eaedc48253da0f42ba6f71be096a3a087b41e287019a55932f64e6cdaac37a3942b25e3e64e20d9bcd82dac8ac7cd625873cd8eeb7f931a631afdc051d7d85c81d1903ff901c84a8674b935d2661cedd8d7da24618430905b1ba69abf4725b3fa3c5bd1c583c2530846cd71c0e987bca64fb22de2868f2a83e1df2cb3495d43303ea354a30fea14daa4d8eebc9fdc199c85546f4c739ed3e35b48390deb5e5203fa15f0d2d17429c33223415d270745257b25dec1271321eb3ce4afefdd89b22d30dd9cd9218f19d00dd598aca57a5e0c4ff998e01a4e97254e420711a59ecb96c4450e36872c155af52599a548de6b1f78b263ecb8d254b8bb6240216c81fd4aeaedab7926aba7517c884c4df8ac51507b41a3dfffd58661feaf271507c8d75f56174ce43efcac39917258d430fd3b17a705548770faec72eae1796adcb42f48db7a64cb2c1e583dc3c47d90e734f93f970352687e921cc3c3e0a1f0f908676c9c30c1c04024c51de643bd0d5a9f1eadd77aa38998740b3bb99f61274775d2c2e3c2441302bf78e118db72d6ab9a89a0d8272e4daec836018d2089c8488bd9b1fbbedef735676e8510bd2d7c84e6b0f1781ca40abd1b750dd235e1c8fffe42ec36680100cd246a3bb67a6c9fd76f2fd592abf48239e6d8520201a379c5a33f0dc92d751a46b81d47dc431064502297c7836f32f3ec2998d1113bd0e0bca31d9d3da7a5fd40fcbf0ae4926965f96ee6b0f776366c9bebef16434b636891d32f30458a4d7aefc297c26536d600a0c648d005c0dd4656997983b16ad7c441e31b58e681400df69f26070d56deed6d0a6d9dd2817b98c922386da367cc44f47949f1ec44a48b4487937a2bda23ea668f96a0df8d9c690320f4c4c228fa30f825a04f6ac5f98b5dea47d08840802565b8697269764d3b119c858f6522a95489c62f3ad40b656dfa83de0f1c13a3ef481f558ed000bb8160f5cce828506fa024717c81fd78d4de166643ed1a27fc4e3d2f2ae4dc643805447b33a41e33b5b6722113ab698ad58d70002223fc098fddcb0d5b3515262dbe74a3fabb169753bfaca2b18f18f25ae4b2400a453d431266913949dadff8bb9c4b39969cf748e3661a08ea7f515cd481d6206c6d924e50879d60fa5956b14cc8d80343fc5014c5a8d35a6f08fdc006728905e7ef19bb137649c62c4f38e29d40ccf82afd426d8d84affa1aea2faa29743992039cfd03306d153a6a3d27cc97dc1dbe6f8917a13ea3005fe3b98ac537e674c35d3e6706774169c6133ca5e3903b352469d94e8610bc56d343c42a3406859f7060bf97fc9caaf631461c12c99ee0ee50287b3bb73474edfe8a691c288f565eedc9f77361c43c689ae01decb2c6f275e27776611667290c72a5bd922f8d8213c42e01a5a43956f1ae73cc1f55d3617b90f3ee8939260564f423cad0086f1922ceb8b5a480b1c8688692b861bb3ce47c7a8bfe9b0bc78c8819816fca8788e6a04de7549efab806078f98e23188e41514d46b07ed29110e32a69b72d5c92315f0ae4053794aa7c1c45b65eff1721783d8ccf66b1810cc81d775246f76bf12a28f5e176a6a6141d18b088a41bbcf1d3983c28737b06c4cd7e630bf36c2099b4c9ba79fd6468b9ca3d1797df9cb61da4fc9832f3bb879d6ade5af5c871fb0b563c3a4f80e99240a6cc4795e1b4fb7fb0dcbe71f90e154c46c325630f8a40454ea0bb00d2590b0bdfce6e5f7c44161557da6bf2aec2b0fefd5d6bf33ff307eca1664053cf8eb7186411db8052d129d70abee60d369e6ea8c690a257415a69da2dede3f473398777377710269d9c51dd8bffcab04e26f32a5592446e16bb4cc140337c78992a650635534fe725416559b1e4cc1892e210e1b686e1b2f2f463477cb8059530f9d66784bdcf75d247391a25d1b2107b09f1043ddc2e2bbe82d8332f91e47d46558886102a7568a8438703edb20a3f661ca19c3168e00ecc102384a64cc4a16ec0d48318830390b70da2f718b614735cf43d2ec3f7380949b406445ea991c7015ad891ffe8699d1f04fc4d7b97067511d4b1752562e3f85df8e52fcd0c3df1741933f06f06160ba2ed9dc51446b5675f10ec6a987a56c98b92381659a7263a8e769932b9ed50cea1093b415094478e5dcb053ad6d451aca50ac528b05b79c3a0bc6978bafcb6fa5ac361d321e53c820027e6aa02c28ad33c0065a236ac5f00f47f3420477a878410f93ba32d1f6ae7d81d02f3e0da9fd8e700a0da920e007d2f5be697e39fdcbb9e66898a3cdeea4a8f8e88bf039ee6b1663244c3749ece452881fe3df0f66b96b9eead26e7c25b43d3ea0ef27fb3db602c68ba312a7d8affa24c48d2f2e12d5ff19222a6549c9b40e775fb9fe48184a919d519c8780cb3f53a2667409848c022b52ef4a661397e0d87f2d2b04f25360e7132d7ae9034b343f1063e4869268b0914b29aef2f79adea2471e30a76ff3bb80bed3b4459e44a45bdf3a4699c96f86e0db0ee1d597ba6df30bce4af04665fa33813068277d4cd3a408226218a644f30e37aa9a967fc14068afb6e4f51940009696733a0020a25093cd4ac5c646a9b4da8f680bb6a4a7604a0151dcec01fe61a827a12a091c97c5902f0208c835eed419a0da66a2af98f7d973f092563f6a2c91c4f3eca4e2b377abace2d374a60865a3ad61d285b6d65eb499616556c40883026c7c82a911e2603d1cbf56dbb22808e60c0ad96ee03085759c8cb6a03d5d466e615480233d73efdd15dbcee45c778d962a77935f584833d03eb8ca22a248ebf08e09a9f6a82772d2487d95586cb22b8bf57804c6f93db71d4befcc1792f3e4e026f32b84cfd54216734f08416cd2855178ed9c8669662dbce58a1a815d4f775256365849bdac2c90f72a99663f574b4619899b965e102fff50a7a749c3d1155723781e38200413183dd72e76c6c6aa2bb66babe8bd505fd81bf4e5879451b9c29a7c53b450139af2f00ae3eff587c6b9f1cdc5cb68e8f78613ee1955efcb7e6d2a99a9e3b9ca9878db3c95a433645d01f5fa04997bbc08216781900c8fd3bc98ee64c2b563b3cb76e782c5f0f5848a9c63414e2b72fc1bdebd7426a29a51ffabf8f7d7a283ac4caa3c0167d22a12e3750d7e29bbaee5fc460b5f3f124f6be7e2e6c9ce34070d97bacd2685985bb4649babc142246ea9afb57ead446ddec44fce1e85a25c5a77de02e6339d0bf4644e7cbdc4b49be553378fb7b0dd66d86ccaad33a48fd91e79b7d0e0767adc7d8acbfbe983762ecfaede103cd5aa0a9016cf5a984549d1c5ca5f0543b8f1c44a4e95cc647293a673a038e346f6cae45e01cb1e45599e7c8d79655e28997bb664a7fc0139414a5e283a875c588ac4d98e741f42b3eb928d0b6ee943565463f4f9a8fc0b8706b4df019cf3dbbc100dd9c85d6c46168e0650a542a8689f12bcd4df9cc4328786e9e961650804698dab932854d57cbe1995a49b12113dc688341625b0e86006f8a821f8b5e638c9f693f8d3b8a4b8d2616e5a925ebe3ce286049bb05e1dacadcee9c5eca9288be7714a8c6e9cb22362b5df5ca468f5d0424c46d408790ff9bb13d1ac2857226a11c4a6c5fe2fa2fef92d7eb5b7c464e00588bb5664324e75c7e9bc3d07664b219a7fe662b0ac25b297358299b0ef4ae28d980ec1b84196e07b3e526fdaae282f1bf39a3d79ef1b742ee9b9f760761dea05da7a4cd1ed03ee75bb253c049b294d193137d30625dd7abc6508da878649483cf03c5cc4adf2ef7473214de63b83ef77cc654a83cb1b154efc0f3ef51efee66a4af0420547178b9ce39c58f75c3e280b6bdcc08c23d9146bd1d853a4ac81c2b17acb21c2ead202238c048336e4be2ecaa48e92016d885c2bebb08997746e2665d250d1d57d73ee161aaa0d32768b77c5f7145ad45c11c41aca048d646ddb18712895566dcd137711463e7608ca56036e01444a5469d25574019675769c14a5f221c499e40e0ba0f2ed2e12bcd2b47d00983a3b5e4aa670605872a3fc875bd2bbfd84c3bc3d425488a3441397550548accaad360265f44b3bc1857b4f9aa6a50673e35275d71bb063416945d7cf8f148ca620314b9255cded1a69c91bc416ac7aafa1b4a5450d93907df3d415035227b333affe857b9e764e6f7ed6fd4297e2330e0a4c9b71801c7d25ce807ce21a9231d6408c9d9a30f79caaf3085322ffd693c7fcf14d71b211096c6758be2b182bcffee98255652779ff2e96c8999d6ac558d99829f38133f169d614c632f35382a9aad699599286c2cff80c0c0098ef9d1d3f0ea4055a156ac865ebb1173cf0eaa8772da90ab20936134774c60e6e048a0341de0465c5e74f6c9f35063c42e8eca83da35c9393ac5197b7ef3fa757215e3435b377f82b2c885c1619def5ad946b864b57d337066f68b668191c357959aaae5d641a82c7fb9fc7d9804d0fd1a4c0c6e6728f82204be1feec8621b25b49a2826febe4c79e5c3c2cae1699214a7aaece4446143c3840cb03a03be426684e95b0ac13f1ce6b20372757141c9776f6fb1818211073117022d08e294dfc4dcb68206adca25636b6f0a2a9c5e1434cf8815aaa9d2dda78db60400694200603afd25f6534c34545eb2e2e140d0a628c41450af36f5247c88</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">Enter Password,Thank you!</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title>来给生活比个耶</title>
    <url>/2020/04/06/%E6%9D%A5%E7%BB%99%E7%94%9F%E6%B4%BB%E6%AF%94%E4%B8%AA%E8%80%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-GwxFeVzH" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="473739441" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p>原本今天是要去上海辰山公园拥抱春天的，单反都准备好了，可是可是可是，昨晚看代码看的太晚了，一觉睡到10点多，洗漱完都快11点了。放弃了，骑着心爱的小电驴，搞顿我自认为很丰盛的午餐。&lt;(<em>￣▽￣</em>)&#x2F;</p>
<p>首先登场的是每次假日做饭必不可少的“正餐”——浓情小火锅.个人不怎么喜欢吃辣，每次出去吃火锅，都会去点份清汤底锅。在家里的话，喜欢番茄味的底锅，酸酸的，鲜鲜的。料的话，除了小丸子，还会加点爱吃的百叶丝，豆腐菓，小香肠，肥牛卷，香菇……</p>
<p><img src="https://s1.ax1x.com/2020/04/28/JhIvFS.jpg"></p>
<p>其次呢，就是鸡丁。放的果蔬丁太少，额外自己又单独买了点。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh2Z7Q.jpg"></p>
<p>码盘，(#^.^#)</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh2J74.jpg"></p>
<p>最后呢是一道休闲下午茶，重新定义一下“下午茶”这个概念。我教你怎么吃？精选上成的薄百叶，跟一张纸一样，还很富有弹性，但是经不起风吹，一吹就干，变得很脆，一碰就会掉成渣；其次是各种果蔬，今天去菜场忘记买生菜，只搞了跟胡萝卜和黄瓜；最后是这道菜的馅，肉末加滑菇，鲜香，美滋滋。平铺百叶，勺许肉末和滑菇，外围嵌入果蔬，就这样一包，一圈，抹上灵魂蘸酱…….那味，世间一绝。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh2cAH.jpg"></p>
<p>最后的最后，来上一杯柠檬水。</p>
<p>男孩子，我觉得会做饭，挺好，至少能把对象养的白白胖胖的，自己动手，丰衣足食，反正我是挺享受做饭的这个过程。生活呢，反正越简单，越直接，自然而然也就越开心。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>《非暴力沟通》听书记</title>
    <url>/2020/04/05/%E3%80%8A%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E3%80%8B%E5%90%AC%E4%B9%A6%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-eoawIcUl" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="1334624319" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>



<h5 id="简介："><a href="#简介：" class="headerlink" title="简介："></a><strong>简介：</strong></h5><p>《非暴力沟通》是美国的马歇尔·卢森堡的一本书，它很深入的剖析了人与人沟通之间暴力的产生来源，并给出了一个解决方案，里面包含了一个标准化的流程。非暴力沟通的核心就是：当一个人觉得自己情绪受伤的时候，无论是你还是对方，都是因为某些需求没有得到满足，所以这时候所要做的事是去寻找这个需求，而不是发泄情绪。因为情绪是最要命的双刃剑，情绪这句话说出去时是很痛快，觉得很爽，但是它在伤害对方的同是也伤害了你自己。</p>
<p><img src="https://s1.ax1x.com/2020/04/27/JhgL6K.jpg"></p>
<h5 id="一-什么是非暴力沟通？"><a href="#一-什么是非暴力沟通？" class="headerlink" title="一.什么是非暴力沟通？"></a><strong>一.什么是非暴力沟通？</strong></h5><p>非暴力沟通第一步就是要讲出自己的感受，而不是一种评判。首先：说出一个事实；其次：说出自己的感受；接着：说出自己为什么会有这种感受的原因；最后：讲出一个清晰明确的具体要求。</p>
<p>非暴力沟通第二步就是看事实。首先：区分观察和评论，不带评论的观察是人类智力的最高形式（克里希拉姆提）；其次，要体会和表达感受；接着：找到感受的根源；最后：请求帮助，说出自己要什么，而不是不要什么，明确目标，请求对方给到反馈。</p>
<p>其实这两步从总体上看，都差不多，但更多的是在运用的细节，有不一样的地方。</p>
<h5 id="二-什么是暴力造成的因素？"><a href="#二-什么是暴力造成的因素？" class="headerlink" title="二.什么是暴力造成的因素？"></a><strong>二.什么是暴力造成的因素？</strong></h5><p>第一种：道德批判</p>
<p>第二种：比较</p>
<p>第三种：回避责任</p>
<p>第四种：强人所难</p>
<h5 id="三-思维纲要"><a href="#三-思维纲要" class="headerlink" title="三.思维纲要"></a><strong>三.思维纲要</strong></h5><p><img src="https://s1.ax1x.com/2020/04/27/JhgxTH.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/27/Jh2F6f.png"></p>
<h5 id="四-感受"><a href="#四-感受" class="headerlink" title="四.感受"></a><strong>四.感受</strong></h5><p>其实这本书，是我接触《樊登读书会》，听的第一本书，听了也不止一次。这一套沟通的逻辑思维是很缜密的，一环套一环。在整个过程中，有些细节方面，并没有去做详细的罗列，比如说：什么是习得性无助、什么样的方式才算叫真正的倾听……，更多的我还是想推荐你自己去买一本书或者自己去倾听一下，记得：用心去听，去感受，真的会让你学到东西。这也是我在上海找工作，简历里必定会写的一个职场软技能：“我很擅长团队之间的沟通协作”的原因，就是你有这样的一份自信去跟别人讲。</p>
<p>我去年的话，也就是2019年，接触的人当中就有这样的一个人，她是我之前的就业指导老师。当你去在和她沟通的时候，会发现完全是一种享受，她能够在有限范畴内，最大的捕捉到你内心的最真实的感受，并一直倾听到你要表达结束后，才去给到她的看法和建议。</p>
<p>所以，不管是今后你与别人沟通，还是跟自己的孩子去沟通，方式很重要，《非暴力沟通》教会你的是：控制情绪，给予认可，善于倾听，满足需求。沟通是人与人之间建立关系的重要纽带。</p>
]]></content>
      <categories>
        <category>psychology</category>
      </categories>
  </entry>
  <entry>
    <title>手机及智能穿戴设备的系统测试</title>
    <url>/2020/04/03/%E6%89%8B%E6%9C%BA%E5%8F%8A%E6%99%BA%E8%83%BD%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-uQpSYqqi" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="439121233" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>



<p>  <strong>对于手机和智能穿戴产品来讲，最主要的是进行系统测试，以保证其功能的正常运行，一般来说测试主要会从以下几个角度去开展但不局限。</strong></p>
<h5 id="1-功能模块测试"><a href="#1-功能模块测试" class="headerlink" title="1.功能模块测试"></a><strong>1.功能模块测试</strong></h5><p>  按照正常的测试流程来讲，首先会去测试计划，其次会去进行测试分析。它所阐明的是测试什么的问题，每一个功能模块的功能项都不一样，测试每一个功能项是否能够实现对应的功能。一般来说如果没有什么大的问题，可以根据测试用例或者像一些软件本身的更新迭代过程就可以完成基础性的功能测试，相对于其他角度的测试讲，比较简单，问题也更容易发现和解决。</p>
<h5 id="2-交叉冲突测试"><a href="#2-交叉冲突测试" class="headerlink" title="2.交叉冲突测试"></a><strong>2.交叉冲突测试</strong></h5><p>  顾名思义，就是在我们正常测试某一个功能项时，突然发生另一个功能项的介入，造成测试过程中的干扰，有点类似中断测试的意思。比如说：在接听电话的过程中，突然收到短信，那么这种情况下，是否会出现短信提示音被载入到通话中。一般来说，我们在执行交叉冲突测试时，测试用例都会有优先级的划分，判定时可根据测试情况进行抉择。</p>
<h5 id="3-内存容量测试"><a href="#3-内存容量测试" class="headerlink" title="3.内存容量测试"></a><strong>3.内存容量测试</strong></h5><p>  手机内存在测试过程中，稍微正规性的测试流程都会去开展这个系列的专项测试，应为不管是手机自身的操作系统，还是手机软件都会去请求手机存储空间的权限。而在测试过程中往往会利用内存填充工具，快速填充，进行后续的一些测试操作，比如：打开手机设置功能，是否出现界面卡顿，过度动画是否出现延迟拖影，相机功能是否能够正常打开使用……</p>
<h5 id="4-兼容性测试"><a href="#4-兼容性测试" class="headerlink" title="4.兼容性测试"></a><strong>4.兼容性测试</strong></h5><p>  其实兼容性测试涉及的面是很少的，关键是在于量。手机的操作系统，由于国内的厂家比较多，在使用的过程中都会对Android原生的操作系统，进行二次打包，比如：MIUI，ColorOS，EMUI……，这些系统都会适配自家的手机上。另外一方面，由于各手机采用的处理器芯片不一样，兼容效果，都均有差异。但是在智能穿戴设备上，就目前接触的所有项目过程中，全部是采用Google的Wear OS，在测试过程中，很多时候会拿其他的样机去进行对比，非常具有对比性，因为毕竟不同的手表之间，是竞品关系。</p>
<h5 id="5-安全性测试"><a href="#5-安全性测试" class="headerlink" title="5.安全性测试"></a><strong>5.安全性测试</strong></h5><p>  在这里，主要是在手机上进行测试，智能穿戴设备很少，比不上手机操作系统。在接触的项目中，比如：手机锁屏安全，手机已登录账户安全，儿童模式安全…..。最多的是手机的解锁和账户这一块，就现在市面主流的手机，几乎都囊括了像一下几种方式：指纹解锁，数字母解锁，面容解锁，不排除后期技术更新，进行声音解锁，每一种解锁方式，运用的算法都不一样，测试点都各有差异。但对于账户这一块，一般来说是需要结合后台数据库的协助，完成测试，像手机丢了，我怎样可以通过手机已登录的账户去删除手机里面的数据……。而智能穿戴设备的安全性在这一方面，略显单薄，只有锁屏。因为智能穿戴设备，即便是已经和你的手机进行绑定，但是照样可以在设置里进行还原出厂设置，重新绑定。所以如果说智能穿戴设备丢了，你就只能重新购买。</p>
<h5 id="6-中断测试"><a href="#6-中断测试" class="headerlink" title="6.中断测试"></a><strong>6.中断测试</strong></h5><p>  在我简单理解看来，中断测试是交叉冲突测试的一种极端状况。为什么这样去讲，其实中断中断，无非就是测试某一个功能项时，直接被外来突发状况打断。比如：当你进入手机设置选项，突然碰到关机按钮灭屏了，这就属于一种简单的中断，那如果我重新解锁，手机之前已经设置好的设置选项是否已被保存。其次中断测试，据我所了解在像一些金融领域，是直接进入专项测试的，之前接触银行类的项目时，印象比较深的就是在支付阶段，经常会出现断网，网络切换的原因，造成订单数据发往数据服务器，多次反复来往请求。</p>
<h5 id="7-压力-性能测试"><a href="#7-压力-性能测试" class="headerlink" title="7.压力&#x2F;性能测试"></a><strong>7.压力&#x2F;性能测试</strong></h5><p>  注意一下，两者是不一样的测试，但是之所以放在一起，是因为在很多项目中，这两者是互不分离的。不涉及到数据的处理来讲，简单从手机角度去谈的话，包含像手机内存，手机网络流量阀值，指令发出到响应的处理时间，长时间视频，拍照…..。但按照目前所接触的项目中，主要像这一块，一般都会牵涉到数据服务器、Web之类的，包括接口之类的很多，这里不扩展讲。</p>
]]></content>
      <categories>
        <category>software testing</category>
      </categories>
  </entry>
  <entry>
    <title>亚瑟·阿伦的36个心理学问题</title>
    <url>/2020/03/31/%E4%BA%9A%E7%91%9F%C2%B7%E9%98%BF%E4%BC%A6%E7%9A%8436%E4%B8%AA%E5%BF%83%E7%90%86%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-kcMnzefb" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="528326686" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>



<h4 id="具体如下："><a href="#具体如下：" class="headerlink" title="具体如下："></a>具体如下：</h4><ol>
<li>如果你能在全世界任选一个人和你共进晚餐，你会选谁？</li>
<li>你想出名吗？你希望以什么样的方式成名？</li>
<li>打电话前，你会预演你即将要说的话吗？为什么？</li>
<li>对你来说，“完美”的一天是什么样的？</li>
<li>上一次一个人唱歌是什么时候？和别人一起是什么时候？</li>
<li>如果你能够活到90岁，并能在你生命的最后60年保留一个30岁的人所拥有的精神或身体，你会选择哪个？</li>
<li>你内心能预感自己何时会离世吗？</li>
<li>说出3个你和对方在外表上的共同特征。</li>
<li>生命中什么事情让你感激不尽？</li>
<li>如果你可以改变自己的成长轨迹，你希望改成什么样子？</li>
<li>用4分钟尽可能详细地告诉对方你的生活故事。</li>
<li>如果明天醒来你可以获得一个品质或一种能力，你希望是什么？</li>
<li>如果有颗水晶球能向你揭示关于你自己、你的生活、你的未来，或是其他任何事情的真相，你想知道些什么？</li>
<li>你有没有一直梦想要做的事情？为什么没有做呢?</li>
<li>你人生中最大的成就是什么？</li>
<li>一段友谊中，你最重视的是什么？</li>
<li>珍贵中最珍贵的事情是什么？</li>
<li>记忆中最可怕的事情是什么？</li>
<li>如果你知道一年后你会突然离世，你会改变现在的生活方式吗？为什么？</li>
<li>朋友对你来说意味着什么？</li>
<li>恋爱和感情在你的生活中扮演着什么样的角色？</li>
<li>逐个列出对方好的一面，共列举5个。</li>
<li>你的家庭成员彼此亲密吗？氛围温馨吗？你觉得你的童年比大部分人都开心吗？</li>
<li>你和母亲的关系如何？</li>
<li>用“我们”组3个基于现有场景的句子，比如，我们在这个房间都感觉……</li>
<li>把这个句子补充完整：“我希望有个人能跟我分享……”</li>
<li>如果你想和对方成为亲密的朋友，请列举出对他&#x2F;她来说最重要的事情。</li>
<li>告诉对方你喜欢他&#x2F;她的地方，这一次你要非常诚恳，说一些你平常不会跟刚认识的人说的话。</li>
<li>和对方分享人生中最尴尬的时刻。</li>
<li>上一次你在他人面前哭是什么时候？是莫名地哭吗？</li>
<li>告诉对方你已经喜欢他&#x2F;她很久了。</li>
<li>有没有什么事情是你认为非常严肃，不能开玩笑的？</li>
<li>假如你今晚会离世，并且没有机会跟任何人交流，你最后悔没有对谁吐露心声？为什么到现在还没有对这个人说出想说的话？</li>
<li>你的房子着火了，所有的财产都在里面。救出了亲人和宠物之后，如果你还有时间最后努力一次，并且安全地挽救任何一件物品，你会选择什么？为什么？</li>
<li>如果有家庭成员去世，你认为谁的离开最让你恐慌？为什么？</li>
<li>说一个个人问题并询问对方的处理意见，让对方向你反馈，你对这个问题所表现出的态度。</li>
</ol>
]]></content>
      <categories>
        <category>psychology</category>
      </categories>
  </entry>
</search>
